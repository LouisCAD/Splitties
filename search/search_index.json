{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Splitties \u00b6 Splitties is a collection of small Kotlin multiplatform libraries (with Android as first target). These libraries are intended to reduce the amount of code you have to write, freeing code reading and writing time, so you can focus more on what you want to build for your users (even if you're the only one), or have more time to have fun . This project is named \"Splitties\" because it is split in small modules, distributed as independent libraries, so you can add only the ones you need to your project/module, helping reduce the size of the final binary that users devices will need to download and keep in the limited storage (BTW, everything is limited). Some Android targeting modules have a content similar to what Anko offers. See a short comparison of Splitties with Anko here . Each module has been designed to have a small footprint and be as efficient as possible. A few examples \u00b6 Splitties is all about simplifying your code. Here are a few examples: Kotlin: startActivity ( Intent ( this , DemoActivity :: class . java )) Kotlin with Splitties Activities : start < DemoActivity > () Kotlin: Snackbar . make ( root , R . string . refresh_successful , Snackbar . LENGTH_SHORT ) . show () Kotlin with Splitties Snackbar : root . snack ( R . string . refresh_successful ) Racing coroutines: ( raceOf(\u2026) comes from the Coroutines module ) suspend fun awaitUserChoice ( ui : SomeUi , choices : List < Stuff > ): Stuff? = raceOf ({ ui . awaitSomeUserAction ( choices ) }, { ui . awaitDismissal () null }, { ui . showSomethingInRealtimeUntilCancelled () // Returns Nothing, will run, but never \"win\". }) Kotlin: Snackbar . make ( root , getString ( R . string . deleted_x_items , deletedCount ), Snackbar . LENGTH_LONG ) . setAction ( android . R . string . cancel ) { deleteOperation . requestRollback () } . setActionTextColor ( ContextCompat . getColor ( this , R . color . fancy_color )) . show () Kotlin with Splitties Snackbar : root . longSnack ( str ( R . string . deleted_x_items , deletedCount )) { action ( android . R . string . cancel , textColor = color ( R . color . fancy_color )) { deleteOperation . requestRollback () } } Overview \u00b6 System interaction (Android only) User input and user interface related splits Small messages (Android only) Dialogs (Android only) System UI (Android only) Extensions for Views (Android only) Creating View based UIs with the power of Kotlin (Android only) Various UI utilities (Android only) Material Design helpers (Android only) Inter and cross app communication: Activities, Fragments, Intents, and Bundles Concurrency (Multiplatform) Data persistence (Multiplatform) Utilities (Multiplatform) Debugging (Android only) Legacy (Android only) System interaction (Android only): \u00b6 App Context: Always have your application Context at hand with appCtx . System Services: No more context.getSystemService(NAME_OF_SERVICE) as NameOfManager . User input and user interface related splits: \u00b6 Small messages (Android only) \u00b6 Snackbar: Grab a snack without ceremony with snack(\u2026) and longSnack(\u2026) . Toast: Show a toast by just calling toast(yourText) , and dodge API 25 BadTokenException . Dialogs (Android only) \u00b6 Alert Dialog: Create simple alert dialogs with simple code. Alert Dialog AppCompat: AppCompat version of Alert Dialog . Alert Dialog AppCompat Coroutines: showAndAwait extension functions for AppCompat AlertDialog. Alert Dialog Material: Material Components extension of Alert Dialog AppCompat . System UI (Android only) \u00b6 Dangerous permissions: Request runtime permissions without polluting your codebase. Extensions for Views (Android only) \u00b6 Views: Extensions function and properties on View s. Views AppCompat: AppCompat extension of Views . Includes helpers for ImageView tinting, ActionBar and tooltip. Views CardView: CardView extension of Views . Provides a contentPadding property. Views Material: Material Components extension of Views . Views Coroutines Material: Material Components + Kotlin coroutines. Views RecyclerView: RecyclerView extension of Views . Views Coroutines: Android Views + Kotlin coroutines. Creating View based UIs with the power of Kotlin (Android only) \u00b6 Views DSL: Create UIs with readable Kotlin code (IDE preview supported). Views DSL AppCompat: AppCompat extension of Views DSL . Views DSL ConstraintLayout: ConstraintLayout extension of Views DSL . Views DSL CoordinatorLayout: CoordinatorLayout extension of Views DSL . Views DSL Material: Material Components extension of Views DSL . Views DSL RecyclerView: RecyclerView extension of Views DSL . Various UI utilities (Android only) \u00b6 Resources: Extensions to get resources like strings, colors or drawables easily, with support for themed attributes. Dimensions: Android dp extensions for View and Context . Particularly handy when using Views DSL . Selectable views Selectable Views: Selectable Views with foreground property before API 23. Selectable Views AppCompat: Selectable Views for AppCompatTextView. Selectable Views ConstraintLayout: Selectable Views for ConstraintLayout. Typesafe RecyclerView: Typesafe ViewHolder and ItemViewHolder for easy basic usage of RecyclerView . Material Design helpers (Android only) \u00b6 Material Colors: 2014 Material Design color palettes as color resources. Material Lists: List item Views implementing Material Design guidelines (perfect for usage in a RecyclerView ). Inter and cross app communication: Activities, Fragments, Intents, and Bundles \u00b6 Activities: Start activities with minimal boilerplate. Intents: Transform companion object s into powerful typesafe intent specs, and create PendingIntent s the clean and easy way. Fragments: Start activities from fragments and do transactions with minimal boilerplate. Fragment Args: Fragment arguments without ceremony thanks to delegated properties. Bundle: BundleSpec to use Bundle with property syntax for Intent extras and more. Concurrency (Multiplatform) \u00b6 Coroutines: General purpose extensions to kotlinx.coroutines. Lifecycle Coroutines (Android only): Coroutines integration with AndroidX Lifecycle . Main Thread: Properties and precondition checkers related to the main thread. Main Handler (Android only): Top-level mainHandler property to stop allocating multiple Handler s for main Looper . Checked Lazy (Android only): mainThreadLazy that checks property access on Data persistence (Multiplatform) \u00b6 Preferences: Property syntax for Android's SharedPreferences / DataStore and macOS/iOS/watchOS NSUserDefaults . Arch Room: Room helpers to instantiate your DB and perform transactions in Kotlin. Utilities (Multiplatform) \u00b6 Bit Flags: hasFlag , withFlag and minusFlag extensions on Long , Int , Short , Byte , and their unsigned counterparts. Collections: forEach for List s without Iterator allocation. Debugging (Android only) \u00b6 Stetho init: Have Stetho for your debug builds, without writing any code! Legacy (Android only) \u00b6 Exceptions: unexpectedValue(\u2026) , unsupportedAction(\u2026) and similar functions that return Nothing . Arch Lifecycle: Extensions to get ViewModel s, use LiveData and observe Lifecycle s. Download \u00b6 Gradle instructions \u00b6 Make sure you have mavenCentral() in the repositories defined in your project's (root) build.gradle file (default for new Android Studio projects). To make it easier to take advantage of the contents of Splitties for your Android projects, there are grouping artifacts that include most splits. Android base \u00b6 Adding with refreshVersions : Splitties.pack.androidBase or Splitties.pack.androidBaseWithViewsDsl . These 2 packs don't include AppCompat and are suitable for WearOS apps. Includes the following modules: - activities - appctx - bitflags - bundle - collections - coroutines - dimensions - fragments - fragmentargs - intents - lifecycle-coroutines - mainhandler - mainthread - material-colors - permissions - preferences - resources - systemservices - toast - views - views-coroutines - views-recyclerview - views-selectable - views-selectable-constraintlayout Gradle dependency: implementation ( \"com.louiscad.splitties:splitties-fun-pack-android-base:3.0.0\" ) There's also a version with Views DSL. It additionally includes the following modules: views-dsl views-dsl-constraintlayout views-dsl-recyclerview Gradle dependency: implementation ( \"com.louiscad.splitties:splitties-fun-pack-android-base-with-views-dsl:3.0.0\" ) Android AppCompat \u00b6 Adding with refreshVersions : Splitties.pack.appCompat or Splitties.pack.appCompatWithViewsDsl . These 2 packs include the Android base pack, and the following modules: - alertdialog-appcompat - alertdialog-appcompat-coroutines - views-appcompat - views-selectable-appcompat Gradle dependency: implementation ( \"com.louiscad.splitties:splitties-fun-pack-android-appcompat:3.0.0\" ) There's also a version with Views DSL. It additionally includes the Views DSL version of the Android base pack and the following module: - views-dsl-appcompat Gradle dependency: implementation ( \"com.louiscad.splitties:splitties-fun-pack-android-appcompat-with-views-dsl:3.0.0\" ) Android Material Components \u00b6 Adding with refreshVersions : Splitties.pack.androidMdc or Splitties.pack.androidMdcWithViewsDsl . These 2 packs include the Android AppCompat pack, and the following modules: - alertdialog-material - material-lists - snackbar - views-cardview - views-coroutines-material - views-material Gradle dependency: implementation ( \"com.louiscad.splitties:splitties-fun-pack-android-material-components:3.0.0\" ) There's also a version with Views DSL. It additionally includes the Views DSL version of the Android AppCompat pack and the following modules: - views-dsl-coordinatorlayout - views-dsl-material Gradle dependency: implementation ( \"com.louiscad.splitties:splitties-fun-pack-android-material-components-with-views-dsl:3.0.0\" ) All the artifacts (47) \u00b6 Since you might use multiple artifacts, to not repeat yourself, we recommend you to put the version in a central place, so it's little effort to upgrade to newer versions. The best way to do this is to use refreshVersions , it has built-in dependency notations for Splitties , and also many other popular and qualitative libraries, like kotlinx, AndroidX, libraries from Square/CashApp and libraries from Google. Most importantly, with it, running the refreshVersions task will show you the available updates in a matter of seconds, for all of your dependencies, right into the versions.properties , in a way that makes upgrading effortless, even with just the keyboard. FYI, the current latest release of Splitties is the version 3.0.0 Here are the maven coordinates of all the artifacts of this library, for reference. (Click to expand) com.louiscad.splitties:splitties-activities com.louiscad.splitties:splitties-alertdialog com.louiscad.splitties:splitties-alertdialog-appcompat com.louiscad.splitties:splitties-alertdialog-appcompat-coroutines com.louiscad.splitties:splitties-appctx com.louiscad.splitties:splitties-arch-lifecycle com.louiscad.splitties:splitties-arch-room com.louiscad.splitties:splitties-bitflags com.louiscad.splitties:splitties-bundle com.louiscad.splitties:splitties-checkedlazy com.louiscad.splitties:splitties-collections com.louiscad.splitties:splitties-coroutines com.louiscad.splitties:splitties-dimensions com.louiscad.splitties:splitties-exceptions com.louiscad.splitties:splitties-fragments com.louiscad.splitties:splitties-fragmentargs com.louiscad.splitties:splitties-intents com.louiscad.splitties:splitties-lifecycle-coroutines com.louiscad.splitties:splitties-mainhandler com.louiscad.splitties:splitties-mainthread com.louiscad.splitties:splitties-material-colors com.louiscad.splitties:splitties-material-lists com.louiscad.splitties:splitties-permissions com.louiscad.splitties:splitties-preferences com.louiscad.splitties:splitties-resources com.louiscad.splitties:splitties-snackbar com.louiscad.splitties:splitties-stetho-init com.louiscad.splitties:splitties-systemservices com.louiscad.splitties:splitties-toast com.louiscad.splitties:splitties-typesaferecyclerview com.louiscad.splitties:splitties-views com.louiscad.splitties:splitties-views-appcompat com.louiscad.splitties:splitties-views-cardview com.louiscad.splitties:splitties-views-coroutines com.louiscad.splitties:splitties-views-coroutines-material com.louiscad.splitties:splitties-views-dsl com.louiscad.splitties:splitties-views-dsl-appcompat com.louiscad.splitties:splitties-views-dsl-constraintlayout com.louiscad.splitties:splitties-views-dsl-coordinatorlayout com.louiscad.splitties:splitties-views-dsl-ide-preview com.louiscad.splitties:splitties-views-dsl-material com.louiscad.splitties:splitties-views-dsl-recyclerview com.louiscad.splitties:splitties-views-material com.louiscad.splitties:splitties-views-recyclerview com.louiscad.splitties:splitties-views-selectable com.louiscad.splitties:splitties-views-selectable-appcompat com.louiscad.splitties:splitties-views-selectable-constraintlayout Snapshots \u00b6 Let's say you need to try a new feature or a fix that did not make it to a release yet: You can grab it in the snapshot version by adding the corresponding repository as shown below, and changing the library version to the latest snapshot, 3.0.0-SNAPSHOT : allProjects { repositories { mavenCentral () google () // Add sonatype snapshots repo below maven ( url = \"https://oss.sonatype.org/content/repositories/snapshots\" ) } } New versions notifications \u00b6 Releases are announced on GitHub, you can subscribe by clicking on \"Watch\", then \"Releases only\" . However, if you use refreshVersions , you'll also learn about updates when you run the refreshVersions task right in the versions.properties file. Improve this library \u00b6 If you want this library to have a new feature or an improvement in a new or in an existing module, please, open an issue or vote/comment a similar one first, so it can be discussed. Documentation contributions are also welcome. For typos or other small improvements, feel free to submit a PR (pull request) directly. For more significant doc contributions, please open an issue first, so it can be discussed. If you find a bug , please open an issue with all the important details. If you know a simple fix that is not API breaking and that does not have side effects that need to be considered, you may also directly submit a PR. You can also join the discussion on Kotlin's Slack in the #splitties channel (you can get an invitation here ). What is a split \u00b6 A \"split\" is a module of the Splitties library that you can add as a dependency. It only includes the required transitive dependencies. This allows you to only add what you need in your app or library module, so the final apk/ipa/app is as small as possible and doesn't include stuff not used by your app. Let's say you're building a Wear OS app using the Views DSL. Wear OS apps don't need AppCompat. Including it would be a waste of bandwidth and storage. The Views DSL core module relies on the Android SDK but not on AppCompat, so you don't bloat your wrist app with AppCompat by using Views DSL. However, if you are building a phone, tablet or computer Android app, there's a Views DSL AppCompat split with a few extensions for you to use. Credits \u00b6 Special thanks to Jovche Mitrejchevski for helping in taking decisions for this project. Thanks to JetBrains and the contributors for Anko , which was a great source of inspiration, especially for Views DSL, and of course thanks for the excellent Kotlin programming language that makes this project possible. Thanks to Doug Stevenson for his articles \"Kotlin & Android: A Brass Tacks Experiment\" . It is fair to say that Views DSL has its root in this experiment. License \u00b6 This library is published under Apache License version 2.0 which you can see here .","title":"Overview"},{"location":"#splitties","text":"Splitties is a collection of small Kotlin multiplatform libraries (with Android as first target). These libraries are intended to reduce the amount of code you have to write, freeing code reading and writing time, so you can focus more on what you want to build for your users (even if you're the only one), or have more time to have fun . This project is named \"Splitties\" because it is split in small modules, distributed as independent libraries, so you can add only the ones you need to your project/module, helping reduce the size of the final binary that users devices will need to download and keep in the limited storage (BTW, everything is limited). Some Android targeting modules have a content similar to what Anko offers. See a short comparison of Splitties with Anko here . Each module has been designed to have a small footprint and be as efficient as possible.","title":"Splitties"},{"location":"#a-few-examples","text":"Splitties is all about simplifying your code. Here are a few examples: Kotlin: startActivity ( Intent ( this , DemoActivity :: class . java )) Kotlin with Splitties Activities : start < DemoActivity > () Kotlin: Snackbar . make ( root , R . string . refresh_successful , Snackbar . LENGTH_SHORT ) . show () Kotlin with Splitties Snackbar : root . snack ( R . string . refresh_successful ) Racing coroutines: ( raceOf(\u2026) comes from the Coroutines module ) suspend fun awaitUserChoice ( ui : SomeUi , choices : List < Stuff > ): Stuff? = raceOf ({ ui . awaitSomeUserAction ( choices ) }, { ui . awaitDismissal () null }, { ui . showSomethingInRealtimeUntilCancelled () // Returns Nothing, will run, but never \"win\". }) Kotlin: Snackbar . make ( root , getString ( R . string . deleted_x_items , deletedCount ), Snackbar . LENGTH_LONG ) . setAction ( android . R . string . cancel ) { deleteOperation . requestRollback () } . setActionTextColor ( ContextCompat . getColor ( this , R . color . fancy_color )) . show () Kotlin with Splitties Snackbar : root . longSnack ( str ( R . string . deleted_x_items , deletedCount )) { action ( android . R . string . cancel , textColor = color ( R . color . fancy_color )) { deleteOperation . requestRollback () } }","title":"A few examples"},{"location":"#overview","text":"System interaction (Android only) User input and user interface related splits Small messages (Android only) Dialogs (Android only) System UI (Android only) Extensions for Views (Android only) Creating View based UIs with the power of Kotlin (Android only) Various UI utilities (Android only) Material Design helpers (Android only) Inter and cross app communication: Activities, Fragments, Intents, and Bundles Concurrency (Multiplatform) Data persistence (Multiplatform) Utilities (Multiplatform) Debugging (Android only) Legacy (Android only)","title":"Overview"},{"location":"#system-interaction-android-only","text":"App Context: Always have your application Context at hand with appCtx . System Services: No more context.getSystemService(NAME_OF_SERVICE) as NameOfManager .","title":"System interaction (Android only):"},{"location":"#user-input-and-user-interface-related-splits","text":"","title":"User input and user interface related splits:"},{"location":"#small-messages-android-only","text":"Snackbar: Grab a snack without ceremony with snack(\u2026) and longSnack(\u2026) . Toast: Show a toast by just calling toast(yourText) , and dodge API 25 BadTokenException .","title":"Small messages (Android only)"},{"location":"#dialogs-android-only","text":"Alert Dialog: Create simple alert dialogs with simple code. Alert Dialog AppCompat: AppCompat version of Alert Dialog . Alert Dialog AppCompat Coroutines: showAndAwait extension functions for AppCompat AlertDialog. Alert Dialog Material: Material Components extension of Alert Dialog AppCompat .","title":"Dialogs (Android only)"},{"location":"#system-ui-android-only","text":"Dangerous permissions: Request runtime permissions without polluting your codebase.","title":"System UI (Android only)"},{"location":"#extensions-for-views-android-only","text":"Views: Extensions function and properties on View s. Views AppCompat: AppCompat extension of Views . Includes helpers for ImageView tinting, ActionBar and tooltip. Views CardView: CardView extension of Views . Provides a contentPadding property. Views Material: Material Components extension of Views . Views Coroutines Material: Material Components + Kotlin coroutines. Views RecyclerView: RecyclerView extension of Views . Views Coroutines: Android Views + Kotlin coroutines.","title":"Extensions for Views (Android only)"},{"location":"#creating-view-based-uis-with-the-power-of-kotlin-android-only","text":"Views DSL: Create UIs with readable Kotlin code (IDE preview supported). Views DSL AppCompat: AppCompat extension of Views DSL . Views DSL ConstraintLayout: ConstraintLayout extension of Views DSL . Views DSL CoordinatorLayout: CoordinatorLayout extension of Views DSL . Views DSL Material: Material Components extension of Views DSL . Views DSL RecyclerView: RecyclerView extension of Views DSL .","title":"Creating View based UIs with the power of Kotlin (Android only)"},{"location":"#various-ui-utilities-android-only","text":"Resources: Extensions to get resources like strings, colors or drawables easily, with support for themed attributes. Dimensions: Android dp extensions for View and Context . Particularly handy when using Views DSL . Selectable views Selectable Views: Selectable Views with foreground property before API 23. Selectable Views AppCompat: Selectable Views for AppCompatTextView. Selectable Views ConstraintLayout: Selectable Views for ConstraintLayout. Typesafe RecyclerView: Typesafe ViewHolder and ItemViewHolder for easy basic usage of RecyclerView .","title":"Various UI utilities (Android only)"},{"location":"#material-design-helpers-android-only","text":"Material Colors: 2014 Material Design color palettes as color resources. Material Lists: List item Views implementing Material Design guidelines (perfect for usage in a RecyclerView ).","title":"Material Design helpers (Android only)"},{"location":"#inter-and-cross-app-communication-activities-fragments-intents-and-bundles","text":"Activities: Start activities with minimal boilerplate. Intents: Transform companion object s into powerful typesafe intent specs, and create PendingIntent s the clean and easy way. Fragments: Start activities from fragments and do transactions with minimal boilerplate. Fragment Args: Fragment arguments without ceremony thanks to delegated properties. Bundle: BundleSpec to use Bundle with property syntax for Intent extras and more.","title":"Inter and cross app communication: Activities, Fragments, Intents, and Bundles"},{"location":"#concurrency-multiplatform","text":"Coroutines: General purpose extensions to kotlinx.coroutines. Lifecycle Coroutines (Android only): Coroutines integration with AndroidX Lifecycle . Main Thread: Properties and precondition checkers related to the main thread. Main Handler (Android only): Top-level mainHandler property to stop allocating multiple Handler s for main Looper . Checked Lazy (Android only): mainThreadLazy that checks property access on","title":"Concurrency (Multiplatform)"},{"location":"#data-persistence-multiplatform","text":"Preferences: Property syntax for Android's SharedPreferences / DataStore and macOS/iOS/watchOS NSUserDefaults . Arch Room: Room helpers to instantiate your DB and perform transactions in Kotlin.","title":"Data persistence (Multiplatform)"},{"location":"#utilities-multiplatform","text":"Bit Flags: hasFlag , withFlag and minusFlag extensions on Long , Int , Short , Byte , and their unsigned counterparts. Collections: forEach for List s without Iterator allocation.","title":"Utilities (Multiplatform)"},{"location":"#debugging-android-only","text":"Stetho init: Have Stetho for your debug builds, without writing any code!","title":"Debugging (Android only)"},{"location":"#legacy-android-only","text":"Exceptions: unexpectedValue(\u2026) , unsupportedAction(\u2026) and similar functions that return Nothing . Arch Lifecycle: Extensions to get ViewModel s, use LiveData and observe Lifecycle s.","title":"Legacy (Android only)"},{"location":"#download","text":"","title":"Download"},{"location":"#gradle-instructions","text":"Make sure you have mavenCentral() in the repositories defined in your project's (root) build.gradle file (default for new Android Studio projects). To make it easier to take advantage of the contents of Splitties for your Android projects, there are grouping artifacts that include most splits.","title":"Gradle instructions"},{"location":"#android-base","text":"Adding with refreshVersions : Splitties.pack.androidBase or Splitties.pack.androidBaseWithViewsDsl . These 2 packs don't include AppCompat and are suitable for WearOS apps. Includes the following modules: - activities - appctx - bitflags - bundle - collections - coroutines - dimensions - fragments - fragmentargs - intents - lifecycle-coroutines - mainhandler - mainthread - material-colors - permissions - preferences - resources - systemservices - toast - views - views-coroutines - views-recyclerview - views-selectable - views-selectable-constraintlayout Gradle dependency: implementation ( \"com.louiscad.splitties:splitties-fun-pack-android-base:3.0.0\" ) There's also a version with Views DSL. It additionally includes the following modules: views-dsl views-dsl-constraintlayout views-dsl-recyclerview Gradle dependency: implementation ( \"com.louiscad.splitties:splitties-fun-pack-android-base-with-views-dsl:3.0.0\" )","title":"Android base"},{"location":"#android-appcompat","text":"Adding with refreshVersions : Splitties.pack.appCompat or Splitties.pack.appCompatWithViewsDsl . These 2 packs include the Android base pack, and the following modules: - alertdialog-appcompat - alertdialog-appcompat-coroutines - views-appcompat - views-selectable-appcompat Gradle dependency: implementation ( \"com.louiscad.splitties:splitties-fun-pack-android-appcompat:3.0.0\" ) There's also a version with Views DSL. It additionally includes the Views DSL version of the Android base pack and the following module: - views-dsl-appcompat Gradle dependency: implementation ( \"com.louiscad.splitties:splitties-fun-pack-android-appcompat-with-views-dsl:3.0.0\" )","title":"Android AppCompat"},{"location":"#android-material-components","text":"Adding with refreshVersions : Splitties.pack.androidMdc or Splitties.pack.androidMdcWithViewsDsl . These 2 packs include the Android AppCompat pack, and the following modules: - alertdialog-material - material-lists - snackbar - views-cardview - views-coroutines-material - views-material Gradle dependency: implementation ( \"com.louiscad.splitties:splitties-fun-pack-android-material-components:3.0.0\" ) There's also a version with Views DSL. It additionally includes the Views DSL version of the Android AppCompat pack and the following modules: - views-dsl-coordinatorlayout - views-dsl-material Gradle dependency: implementation ( \"com.louiscad.splitties:splitties-fun-pack-android-material-components-with-views-dsl:3.0.0\" )","title":"Android Material Components"},{"location":"#all-the-artifacts-47","text":"Since you might use multiple artifacts, to not repeat yourself, we recommend you to put the version in a central place, so it's little effort to upgrade to newer versions. The best way to do this is to use refreshVersions , it has built-in dependency notations for Splitties , and also many other popular and qualitative libraries, like kotlinx, AndroidX, libraries from Square/CashApp and libraries from Google. Most importantly, with it, running the refreshVersions task will show you the available updates in a matter of seconds, for all of your dependencies, right into the versions.properties , in a way that makes upgrading effortless, even with just the keyboard. FYI, the current latest release of Splitties is the version 3.0.0 Here are the maven coordinates of all the artifacts of this library, for reference. (Click to expand) com.louiscad.splitties:splitties-activities com.louiscad.splitties:splitties-alertdialog com.louiscad.splitties:splitties-alertdialog-appcompat com.louiscad.splitties:splitties-alertdialog-appcompat-coroutines com.louiscad.splitties:splitties-appctx com.louiscad.splitties:splitties-arch-lifecycle com.louiscad.splitties:splitties-arch-room com.louiscad.splitties:splitties-bitflags com.louiscad.splitties:splitties-bundle com.louiscad.splitties:splitties-checkedlazy com.louiscad.splitties:splitties-collections com.louiscad.splitties:splitties-coroutines com.louiscad.splitties:splitties-dimensions com.louiscad.splitties:splitties-exceptions com.louiscad.splitties:splitties-fragments com.louiscad.splitties:splitties-fragmentargs com.louiscad.splitties:splitties-intents com.louiscad.splitties:splitties-lifecycle-coroutines com.louiscad.splitties:splitties-mainhandler com.louiscad.splitties:splitties-mainthread com.louiscad.splitties:splitties-material-colors com.louiscad.splitties:splitties-material-lists com.louiscad.splitties:splitties-permissions com.louiscad.splitties:splitties-preferences com.louiscad.splitties:splitties-resources com.louiscad.splitties:splitties-snackbar com.louiscad.splitties:splitties-stetho-init com.louiscad.splitties:splitties-systemservices com.louiscad.splitties:splitties-toast com.louiscad.splitties:splitties-typesaferecyclerview com.louiscad.splitties:splitties-views com.louiscad.splitties:splitties-views-appcompat com.louiscad.splitties:splitties-views-cardview com.louiscad.splitties:splitties-views-coroutines com.louiscad.splitties:splitties-views-coroutines-material com.louiscad.splitties:splitties-views-dsl com.louiscad.splitties:splitties-views-dsl-appcompat com.louiscad.splitties:splitties-views-dsl-constraintlayout com.louiscad.splitties:splitties-views-dsl-coordinatorlayout com.louiscad.splitties:splitties-views-dsl-ide-preview com.louiscad.splitties:splitties-views-dsl-material com.louiscad.splitties:splitties-views-dsl-recyclerview com.louiscad.splitties:splitties-views-material com.louiscad.splitties:splitties-views-recyclerview com.louiscad.splitties:splitties-views-selectable com.louiscad.splitties:splitties-views-selectable-appcompat com.louiscad.splitties:splitties-views-selectable-constraintlayout","title":"All the artifacts (47)"},{"location":"#snapshots","text":"Let's say you need to try a new feature or a fix that did not make it to a release yet: You can grab it in the snapshot version by adding the corresponding repository as shown below, and changing the library version to the latest snapshot, 3.0.0-SNAPSHOT : allProjects { repositories { mavenCentral () google () // Add sonatype snapshots repo below maven ( url = \"https://oss.sonatype.org/content/repositories/snapshots\" ) } }","title":"Snapshots"},{"location":"#new-versions-notifications","text":"Releases are announced on GitHub, you can subscribe by clicking on \"Watch\", then \"Releases only\" . However, if you use refreshVersions , you'll also learn about updates when you run the refreshVersions task right in the versions.properties file.","title":"New versions notifications"},{"location":"#improve-this-library","text":"If you want this library to have a new feature or an improvement in a new or in an existing module, please, open an issue or vote/comment a similar one first, so it can be discussed. Documentation contributions are also welcome. For typos or other small improvements, feel free to submit a PR (pull request) directly. For more significant doc contributions, please open an issue first, so it can be discussed. If you find a bug , please open an issue with all the important details. If you know a simple fix that is not API breaking and that does not have side effects that need to be considered, you may also directly submit a PR. You can also join the discussion on Kotlin's Slack in the #splitties channel (you can get an invitation here ).","title":"Improve this library"},{"location":"#what-is-a-split","text":"A \"split\" is a module of the Splitties library that you can add as a dependency. It only includes the required transitive dependencies. This allows you to only add what you need in your app or library module, so the final apk/ipa/app is as small as possible and doesn't include stuff not used by your app. Let's say you're building a Wear OS app using the Views DSL. Wear OS apps don't need AppCompat. Including it would be a waste of bandwidth and storage. The Views DSL core module relies on the Android SDK but not on AppCompat, so you don't bloat your wrist app with AppCompat by using Views DSL. However, if you are building a phone, tablet or computer Android app, there's a Views DSL AppCompat split with a few extensions for you to use.","title":"What is a split"},{"location":"#credits","text":"Special thanks to Jovche Mitrejchevski for helping in taking decisions for this project. Thanks to JetBrains and the contributors for Anko , which was a great source of inspiration, especially for Views DSL, and of course thanks for the excellent Kotlin programming language that makes this project possible. Thanks to Doug Stevenson for his articles \"Kotlin & Android: A Brass Tacks Experiment\" . It is fair to say that Views DSL has its root in this experiment.","title":"Credits"},{"location":"#license","text":"This library is published under Apache License version 2.0 which you can see here .","title":"License"},{"location":"CHANGELOG/","text":"Change log for Splitties \u00b6 Version 3.0.0 (2021-08-20) \u00b6 Compiled with Kotlin 1.5.21 and kotlinx.coroutines 1.5.1-native-mt. Finally! Splitties 3.0.0 is there, and it's ready to keep iterating. The last 2.x version, the 2.1.1 dates back from 2018-11-25, close to 3 years ago. Why did it take so long to have version 3.0.0? Let's say making a multi-modules, multiplatform library isn't full of easy and straightforward steps. A blog post (my first!) will be published later to share that experience from start to now. Feel free to click follow on blog.louiscad.com , or on Twitter to know when the story is published. I'll also share a roadmap for Splitties there, which I hope will get you excited for your future endeavors. Let's get into the actual content of this release: Documentation updates and improvements, and website \u00b6 In case you missed it, Splitties now has a website, happily powered by Material for MKDocs . The address is splitties.louiscad.com . The main page shows a better overview of what Splitties is about, and its content. It should be helpful for newcomers. The setup info for each module is now upfront in their respective doc pages, be it on the website, or on GitHub, and they have been updated to recommend using the dependency notations from refreshVersions , which will also help you update Splitties, along with other libraries, and all that in less time. Full disclosure: I am working on refreshVersions myself, in close collaboration with its author, Jean-Michel Fayard. I use it, and I totally recommend it for all Gradle projects. Splitties is using it of course. Bit Flags \u00b6 Changed \u00b6 The hasFlag , withFlag , and minusFlag extensions for unsigned integers ( UByte , UShort , UInt , and ULong ) are no longer annotated with the @ExperimentalUnsignedTypes annotation. Preferences \u00b6 Added \u00b6 There's a new DataStorePreferences class for the Android side, which you can use as a substitute of the Preferences class. If you were already using SuspendPrefsAccessor , that's all you need to change. This AndroidX DataStore backed implementation should remove the risks of your app and their users being affected by the potential performance issues of Android platform's SharedPreferences . Be sure to check out the updated docs ! Version 3.0.0-rc03 (2021-08-06) \u00b6 Compiled with Kotlin 1.5.21 and kotlinx.coroutines 1.5.1-native-mt. App Context \u00b6 Added \u00b6 The AppCtxInitializer class is now public, so you can put it in the list of dependencies of your own AndroidX App Startup Initializer in case it relies on appCtx to be initialized. Resources \u00b6 Fix \u00b6 In 3.0.0-rc02, changes in styledColorSL made it break when the theme attribute was pointing to a color resource that had no selector (i.e. a non inlined plain color code like #00bbff ). This has now been fixed, and the code also got simpler. Version 3.0.0-rc02 (2021-08-03) \u00b6 Compiled with Kotlin 1.5.21 and kotlinx.coroutines 1.5.1-native-mt. Resources \u00b6 Fixes \u00b6 By resolving a subtle issue that could break IDE preview, the version 3.0.0-alpha07 of Splitties also broke the styledColor function and some other in come cases. If you had a color theme attribute and had a theme that was setting its value, pointing to another color resource, you'd be in luck. However, if the color value was set inline, right into the theme, it'd crash ( as you can see in this issue ). This release fixes this kind of problem for all the affected functions: - styledColor - styledColorSL - styledDimen - styledDimenPxSize - styledDimenPxOffset - styledBool - styledInt - styledTxt - styledStr Version 3.0.0-rc01 (2021-08-01) \u00b6 Compiled with Kotlin 1.5.21 and kotlinx.coroutines 1.5.1-native-mt. This release removes previously deprecated code. Make sure you don't have transitive dependencies that relied on deprecated code from a previous release of Splitties! If that's the case, you'll see the host app crash at runtime. Removed \u00b6 The \"Init provider\" split has been removed and is no longer published starting with this release. You can find if you are using it by searching for its maven coordinates: com.louiscad.splitties:splitties-initprovider (the \"Find in Path\" IDE option can help you locate it). If you used it, you'll need to move to AndroidX App Startup . All the other previously deprecated symbols at hidden level have been removed. This completes the deprecation cycle for the upcoming Splitties 3.0.0 release. Version 3.0.0-beta06 (2021-08-01) \u00b6 Compiled with Kotlin 1.5.21 and kotlinx.coroutines 1.5.1-native-mt. This release is advancing deprecation cycles further before the upcoming 3.0.0 release. Deprecation cycle \u00b6 All previously deprecated symbols were either removed, or hidden: Error \u2192 Hidden Hidden \u2192 Removed Version 3.0.0-beta05 (2021-08-01) \u00b6 Compiled with Kotlin 1.5.21 and kotlinx.coroutines 1.5.1-native-mt. This release is advancing deprecation cycles before the upcoming 3.0.0 release. Deprecation cycle \u00b6 All previously deprecated symbols were either removed, or moved one step closer to it: Warning \u2192 Error Error \u2192 Hidden Hidden \u2192 Removed Version 3.0.0-beta04 (2021-07-30) \u00b6 Compiled with Kotlin 1.5.21 and kotlinx.coroutines 1.5.1-native-mt. Fix \u00b6 Fix iOS/multiplatform publication (see issue #280 ). Version 3.0.0-beta03 (2021-07-17) \u00b6 Compiled with Kotlin 1.5.21 and kotlinx.coroutines 1.5.1-native-mt. Other transitive dependencies have also been upgraded to the latest stable version. It includes upgrades to various AndroidX libraries, Material Design Components 1.4.0, and Stetho 1.6.0. This release is advancing deprecation cycles before the upcoming, long awaited 3.0.0 release. Coroutines \u00b6 Deprecations \u00b6 The SendChannel.offerCatching has been deprecated in favor of trySend from kotlinx.coroutines 1.5+ The deprecation level of awaitCancellation() has been raised from warning to error. Use the one from kotlinx.coroutines instead. Lifecycle coroutines \u00b6 Deprecations \u00b6 Dispatchers.MainAndroid deprecation level has been raised from warning to error. Using Dispatchers.Main is fine performance wise since kotlinx.coroutines 1.3.3. The PotentialFutureAndroidXLifecycleKtxApi annotation deprecation level was also raised to error. The following symbols that were previously deprecated at error level are now hidden and will be removed in the next release: - Lifecycle.coroutineScope - Lifecycle.job - LifecycleOwner.lifecycleScope - MainDispatcherPerformanceIssueWorkaround Preferences \u00b6 Deprecations \u00b6 Raise the deprecation level of the implicit key delegates from warning to error. Resources \u00b6 Deprecations \u00b6 Raise the deprecation level of Context.withStyledAttributes to error. Views AppCompat \u00b6 Deprecations \u00b6 Raise the deprecation level of ActionBar.showHomeAsUp to error. Version 3.0.0-beta02 (2021-07-08) \u00b6 Compiled with Kotlin 1.4.32 and kotlinx.coroutines 1.4.3-native-mt. This is the first release of Splitties that is published on MavenCentral! The maven coordinates are the same. Also, there's now a documentation website on splitties.louiscad.com , check it out! Alert Dialog \u00b6 Add \"calls in place exactly once\" contracts for the lambdas of all the alertDialog functions. Alert Dialog AppCompat \u00b6 Add \"calls in place exactly once\" contracts for the lambdas of all the alertDialog functions. Alert Dialog AppCompat Coroutines \u00b6 Fix rare crash that could happen when waiting for a button click if multiple ones were clicked simultaneously. Now, only the first one to be considered clicked by the system will trigger, and the second one will be ignored. Alert Dialog Material \u00b6 Add \"calls in place exactly once\" contracts for the lambdas of all the materialAlertDialog functions. App Context \u00b6 Replace the initializing ContentProvider with AndroidX App Startup. Coroutines \u00b6 Deprecate awaitCancellation() in favor of the one now included right into kotlinx.coroutines. Lifecycle Coroutines \u00b6 Introduce the whileStarted(Lifecyle) extension function for Flow to have a flow emit values only while the passed Lifecycle is started. Stetho Init \u00b6 Replace the initializing ContentProvider with AndroidX App Startup. Version 3.0.0-beta01 (2020-09-14) \u00b6 Compiled with Kotlin 1.4.10 and kotlinx.coroutines 1.3.9-native-mt. This release has multiplatform splits compatible with iOS, macOS and watchOS projects that use Kotlin/Native 1.4.0 and 1.4.10. Feedback is appreciated (Twitter, Kotlin's Slack, GitHub issues\u2026). Platforms added \u00b6 watchOS support has been added to the following splits : - Bit Flags - Collections - Coroutines - Main Thread - Preferences All CPU architectures are supported (arm32, arm64 & X86 for simulator). Arch Room \u00b6 Deprecated \u00b6 Deprecated the transaction and inTransaction extension functions in favor of withTransaction (Room KTX) and runInTransaction (Room runtime) itself. Init Provider \u00b6 Changed \u00b6 Now requires to opt-in to @ObsoleteContentProviderHack . This split will be deprecated once App Startup from AndroidX goes stable. Lifecycle Coroutines \u00b6 Deprecated \u00b6 Deprecated symbols now have error level. Next release will remove them. Removed \u00b6 LifecycleOwner.coroutineScope that was at error deprecation level. Use LifecycleOwner.lifecycleScope from AndroidX instead. Toast \u00b6 Changed \u00b6 Using this API now requires to opt-in to @UnreliableToastApi so the developers acknowledge the gotchas of android.widget.Toast or use something else (like snackbars, banners or dialogs). Views \u00b6 Added \u00b6 Add the following read/write extensions properties for View : - startPadding - endPadding - leftPadding - rightPadding Changed \u00b6 The onClick parameter changed from a crossinline lambda to a View.OnClickListener now that Kotlin 1.4 brings SAM conversion for Kotlin functions taking SAM Java interfaces. Usage should not change. Note that there is now an implicit it parameter of type View that might break existing code if an outer it was used in the onClick lambda. Views DSL \u00b6 Changed \u00b6 All lambdas in AndroidStyles now have a contract. That allows you to initialize val s declared in the outer scope. Views DSL AppCompat \u00b6 Changed \u00b6 Only instantiate AppCompat version of Android widgets if the current theme inherits an AppCompat theme. All lambdas in AppCompatStyles now have a contract. That allows you to initialize val s declared in the outer scope. Added \u00b6 Add the missing AppCompat version of ToggleButton . Views DSL Material \u00b6 Changed \u00b6 Only instantiate Material Components version of Android widgets if the current theme inherits a material theme. All lambdas in MaterialComponentsStyles now have a contract. That allows you to initialize val s declared in the outer scope. Added \u00b6 Add the following missing Material Components counterparts of Android widgets: CheckBox , RadioButton , TextView , AutoCompleteTextView . Version 3.0.0-alpha07 (2020-09-01) \u00b6 Compiled with Kotlin 1.3.72 and kotlinx.coroutines 1.3.8. This release introduces 2 new splits: - Alert Dialog Material (Android only) It is included in the \"Android Material Components\" fun pack. Thanks @ivoberger for the contribution! - Coroutines (supports macOS, iOS, JS, JVM & Android) It is included in the \"Android base\" fun pack. Alert Dialog and Alert Dialog AppCompat \u00b6 Added \u00b6 Add isCancellable parameter (defaults to true , as when unspecified) to alertDialog builders. Arch Lifecycle \u00b6 Added \u00b6 viewModels { \u2026 } for FragmentActivity and Fragment activityViewModels { \u2026 } for Fragment Changed \u00b6 This split no longer depends on the androidx.lifecycle:lifecycle-extensions artifact that has been deprecated in AndroidX Lifecycle 2.2.0 and is no longer published in later versions. Deprecated \u00b6 AndroidX Lifecycle KTX artifacts caught up with features that this split originally provided, so we've deprecated that overlap: activityScope() for Activity -> viewModels() activityScope() for Fragment -> activityViewModels() fragmentScope() for Fragment -> viewModels() Also, we provided variants of these that took a lambda. Since AndroidX doesn't provide such a facility, they have been kept, but the old naming has been deprecated to match the AndroidX naming. Note that these changes provide a ReplaceWith clause for easy migration. Important: Next alpha release will move the deprecation level to error, and the alpha release after will remove them completely. (So it's best to not skip this update if you were using these extensions.) Collections \u00b6 Added \u00b6 forEachReversedWithIndex extension for List now has an allowSafeModifications parameter. When set to true (default is false ), you can mutate the list as long as it doesn't prevent the next iteration from happening (or that you perform a non local return to stop iterating altogether). As usual, unsafe operations while iterating a list can result in a ConcurrentModificationException or in an IndexOutOfBoundsException to be thrown. Dimensions \u00b6 Changed \u00b6 The dip and dp functions now return the type of their argument ( Int or Float ). You'll need to migrate usages of the previous dp function, so they pass a Float . Use \"Find in Path\" in the IDE to find them before fixing. If you often passed the same value to dp , the \"Replace in Path\" IDE option can save you even more time. Lifecycle Coroutines \u00b6 Added \u00b6 Lifecycle.isStartedFlow() Lifecycle.isStartedFlow(timeout: Duration) Lifecycle.isResumedFlow() Lifecycle.isResumedFlow(timeout: Duration) Lifecycle.stateFlow(): Flow<Lifecycle.State> Changed \u00b6 The following extension functions for Lifecycle have been promoted to @ExperimentalSplittiesApi (from @PotentialFutureAndroidXLifecycleKtxApi ): - createScope - createJob - awaitResumed - awaitStarted - awaitCreated - awaitState Deprecated \u00b6 Dispatchers.MainAndroid is no longer needed and has been deprecated since the performance issue that affected Dispatchers.Main has been fixed since kotlinx.coroutines 1.3.3 . The following extension properties have been deprecated because they are now provided by AndroidX Lifecycle Runtime KTX: - Lifecycle.coroutineScope - LifecycleOwner.lifecycleScope Lifecycle.job has also been deprecated even though there's no as-concise replacement because it doesn't satisfy a common use case. Main Thread \u00b6 Added \u00b6 Now supports macOS, iOS and JS. Material Lists \u00b6 Changed \u00b6 Ensure all TextView s in the list items are at least one line tall, even if the text is empty. Support enabled/disabled state by making child views duplicate parent state. Permissions \u00b6 Added \u00b6 New ensureAllPermissions function available in top-level and as extension for FragmentActivity and Fragment to request multiple permissions in a row and ensure you have them all granted. Preferences \u00b6 Added \u00b6 Now supports macOS and iOS (backed by NSUserDefaults , but supports custom implementation too, just like on Android). Added preferences property to PrefDelegate s. Added key property to PrefDelegate s. Added valueFlow() function to PrefDelegate s to get current value and changes of a pref field. Changed \u00b6 The availableAtDirectBoot parameter has been renamed to androidAvailableAtDirectBoot . The XxxPref classes (e.g. BoolPref , StringPref , etc.) are no longer inner classes but are now part of the PrefDelegate sealed class hierarchy. Resources \u00b6 Added \u00b6 New resolveThemeAttribute extension function for Context . This is the replacement for withStyledAttributes . Deprecated \u00b6 withStyledAttributes must be replaced by new resolveThemeAttribute that also has an implementation that is working reliably in IDE Preview. It will be removed in a future release. Snackbar \u00b6 Changed \u00b6 The snack , longSnack and snackForever extension functions now work with any View instead of just CoordinatorLayout . System Services \u00b6 Added \u00b6 Add biometricManager from API 29. Add roleManager from API 29. Views AppCompat \u00b6 Added \u00b6 configActionBar extension function for AppCompatActivity . homeAsUp extension read/write property for ActionBar . Changed \u00b6 ActionBar.showTitle now supports reading current value. ActionBar.showHome now supports reading current value. ActionBar.useLogo now supports reading current value. ActionBar.showCustomView now supports reading current value. Deprecated \u00b6 ActionBar.showHomeAsUp has been deprecated and must be replaced by homeAsUp . It will be removed in a future release. Views Coroutines & Views Coroutines Material \u00b6 Bug fixes \u00b6 Fix a very rare crash that would occur when performing two clicks or long clicks in a row (e.g. by calling performClick twice without a UI thread dispatch) when using View.awaitOneClick() , View.awaitOneLongClick() or FloatingActionButton.showAndAwaitOneClickThenHide() . Views DSL \u00b6 Added \u00b6 UiPreView is now included by default, the extra \"Views DSL IDE Preview\" module is no longer needed. If you never use it in your production code, R8 should remove it from your release app. This has been done to simplify setup. The isInPreview extension properties for Ui and View allow you to condition content to show based on whether it's the actual app or the IDE preview. Note that it statically evaluates to false in release builds (unlike View.isInEditmode ), so the compiler will remove any code placed in the branch of an if (isInPreview) condition, and will allow R8 to remove any code that was only used in IDE preview. There's 2 new overloads of the ViewGroup.add extension functions that take either a beforeChild or an afterChild parameter. You must use the parameter name to call one of these overloads. It comes handy in ViewGroup s where the order of the child View s matters (e.g. FrameLayout and LinearLayout ). space to create an android.widget.Space from a Ui , a View or a Context reference. Thanks to @Miha-x64 for the contribution! Changed \u00b6 UiPreView now shows known error cases in the preview itself with a red warning triangle icon. Views DSL ConstraintLayout \u00b6 Added \u00b6 Add new extensions: above , below , before and after for ConstraintLayout.LayoutParams . Views DSL Material \u00b6 Added \u00b6 Add slider , rangeSlider and shapeableImageView extensions for View , Ui and Context . They can instantiate the new widgets from the version 1.2.0 of the material-components-android library. Views DSL IDE preview \u00b6 This module has been deprecated. It will no longer published in future releases. Its content has been moved to the main \"Views DSL\" split. Version 3.0.0-alpha06 (2019-05-03) \u00b6 Compiled with Kotlin 1.3.31. Permissions \u00b6 Handle empty grantResults for permission request ( #191 ). Version 3.0.0-alpha05 (2019-04-29) \u00b6 Compiled with Kotlin 1.3.31. This release introduces 3 new splits: Alert Dialog AppCompat Coroutines Permissions Views Coroutines Material The most important change though, is how simpler integrating Splitties in your Android projects has become starting from this release, thanks to the new grouping artifacts. See their content and their maven coordinates in the dedicated part of the README . There is also new features and changes in existing splits, as detailed below. Alert Dialog & Alert Dialog AppCompat \u00b6 The alert functions have been deprecated in favor of a more accurate naming: alertDialog . These alertDialog functions are now usable on Context (vs previously only on Activity ), and they have optional parameters to specify the title, the message and even an icon (using a resource id or a Drawable . Also, the title and the message properties are now nullable, in respect to their accepted value. Fragments \u00b6 The show and showAsync extension functions allow you to show a DialogFragment without fearing the infamous IllegalStateException if the state has already been saved, because it will wait for the lifecycle to be in the RESUMED state before showing the DialogFragment . These 2 extension functions are defined for FragmentManager , FragmentActivity and Fragment . show is a suspending function that resumes after the lifecycle was resumed and the DialogFragment was shown. showAsync is when you are outside of a coroutine but it is marked as experimental because it has \"async\" in its name while not returning a Deferred . Feel free to suggest a better name in the issues or in the #splitties channel of Kotlin's Slack. Lifecycle Coroutines \u00b6 New suspending inline extensions functions for Lifecycle have been added for convenience: awaitResumed , awaitStarted & awaitCreated . They can replace code like awaitState(Lifecycle.State.RESUMED) for improved readability. Material Lists \u00b6 A new IconTwoLinesCheckBoxListItem class has been added. What it does is self-explanatory. Also, all the list items are now fully xml friendly. Resources \u00b6 The colorSL and appColorSL extension functions no longer return the nullable version of ColorStateList . Views DSL ConstraintLayout \u00b6 All the ConstraintLayout.LayoutParams extension functions now have overloads that allow specifying the margin. For example, the following code: centerHorizontally () horizontalMargin = dip ( 16 ) can now be written on one line: centerHorizontally(margin = dip(16)) . That improves readability as the word \"horizontal\" is no longer repeated, and it is still explicit. Views Material \u00b6 Two set-only extensions properties have been added for MaterialButton : iconResource and iconTintAndTextColor . Version 3.0.0-alpha04 (2019-03-03) \u00b6 Compiled with Kotlin 1.3.21. New features \u00b6 The wrapContent and matchParent extensions for ViewGroup now apply for View too. Add wrapInScrollView and wrapInHorizontalScrollView extension functions for View . Add experimental multiplatform support with initial Kotlin/JS support for the Bit Flags and Collections splits. Changes \u00b6 Rename LifecycleOwner.coroutineScope to lifecycleScope . This change is binary compatible. Make wrapInRecyclerView lambda inline. This change is not binary compatible. Fixes \u00b6 Remove contract in the Intents split that would cause compilation to fail when used. Version 3.0.0-alpha03 (2019-02-05) \u00b6 Compiled with Kotlin 1.3.20. This release introduces a new split: Views Coroutines . New features \u00b6 Added radioGroup { ... } functions in Views DSL. Added first class support for ConstraintLayout barriers, guidelines and groups. New styledView function for use when making an API for xml styles usage in Kotlin. See an example in AppCompatStyles . The MaterialComponentsStyles class brings access to all the xml styles defined in Google's Material Components library for Android in a typesafe way. Add materialCardView { ... } functions in Views DSL Material. Add navigationView { ... } functions in Views DSL Material. Make EditText inputType typesafe with the set only type extension property and the InputType inline class. Views DSL IDE Preview now supports CoroutineContext and CoroutineScope as constructor parameters for Ui subclasses. Added contracts for all the lParams functions from Views DSL and variants. Also added to the roomDb function from Arch Room as well as the verticalListLayoutParams and horizontalListLayoutParams functions from Views DSL RecyclerView. Add support for unsigned numbers in Bit Flags (i.e. UByte , UShort , UInt and ULong ). Changes \u00b6 When using the button function from Views DSL, MaterialButton is now automatically used in place of AppCompatButton if you also use Views DSL Material. Make mainHandler async by default to avoid vSync delays. It is used for Dispatchers.MainAndroid , so it will result in speed improvements when using Lifecycle Coroutines. If you really need sync behavior, you can use the new mainHandlerSync top level property instead. Make Dispatchers.MainAndroid of type MainCoroutineDispatcher so the immediate property is available. Make the awaitState function from Lifecycle Coroutines safe to use off the main thread, and document it. Call validate() from the lParams { ... } function for ConstraintLayout . Make xml styles related classes inline again (thanks to compiler bug fixed in Kotlin 1.3.20). The reified generic variant of view from Views DSL is now an internal API. ViewFactory and related symbols are now an internal API. Mark some SystemServices as nullable to be instant app tolerant. That includes WallpaperManager , WifiManager , WifiP2pManager , UsbManager , DevicePolicyManager , FingerprintManager , ShortcutManager and WifiAwareManager . The Views DSL IDE Preview documentation now states that running the compileDebugKotlin gradle task is enough to update the preview. This is faster than a full build. Fixes \u00b6 Make viewFactory from Views DSL internal API compatible with IDE Preview. Deprecation \u00b6 The illegal top level function from Exceptions has been deprecated in favor of error from Kotlin stdlib. New artifact \u00b6 This release has the following new artifact: \"com.louiscad.splitties:splitties-views-coroutines:3.0.0-alpha03\" Version 3.0.0-alpha02 (2019-01-06) \u00b6 This release introduces a new split: Lifecycle Coroutines . New artifact \u00b6 This release has the following new artifact: \"com.louiscad.splitties:splitties-lifecycle-coroutines:3.0.0-alpha02\" Version 3.0.0-alpha01 (2018-12-21) \u00b6 This release is compiled with Kotlin 1.3.11. It is a breaking release (more details in the changes section), and the API is subject to changes as it is back to an alpha stage. APIs that are likely to change have an experimental annotation that triggers a warning (which can be removed by opt-in), to prevent you from using them unintentionally. Migration to AndroidX \u00b6 All the old support library artifacts have been replaced by AndroidX ones. If your project has not migrated to AndroidX yet, please follow the quick steps below. Migrating your project to AndroidX in a `fun` way. (Click to expand) Theoretically, migrating a project to AndroidX is easy: you just select \"Migrate to AndroidX\" from the \"Refactor\" menu. Unfortunately, in addition to being unacceptably slow, it didn't work properly for Splitties (except for a past attempt which had to be abandoned for API stability reasons). _Our experience was waiting minutes with an unresponsive IDE, then giving up with no other choice than force closing Android Studio, and finally getting a broken project, with some dangling fully qualified references (instead of proper import replacement). We reverted and looked for an alternative that would work properly, and perform faster._ The solution has been a Kotlin script that is a white box, and runs in a matter of seconds. You can use it for your project too, so you can migrate to AndroidX quickly, and in a `fun` way. It is available [here](https://github.com/LouisCAD/Splitties/tree/main/scripts/AndroidX-migrator.kts), and depends on [this csv file](https://github.com/LouisCAD/Splitties/tree/main/scripts/androidx-class-mapping.csv). _Note that this script doesn't migrate the dependencies, because we changed the way we define dependencies (using constants defined in `buildSrc`), and it would have been harder to handle all the edge cases, and doing it by hand with Replace in Path from IDE was quick enough for us. If you prefer to have it, you are free to contribute and reach out in the issues or elsewhere._ To use it in your project, follow these simple steps: 1. Replace the support libraries dependencies by AndroidX dependencies (and update Splitties ones if you already used it). 2. Copy paste the two files linked above at the root of the gradle project. 3. Edit the `expectedNumberOfModules` property defined in the `AndroidX-migrator.gradle.kts` file to match the number of modules that your project has. 4. Make sure you have `kotlinc` 1.3+ available (see [easy installation in official docs here]( https://kotlinlang.org/docs/tutorials/command-line.html )). 5. Open a terminal at the root of the gradle project. 6. Run `kotlinc -script AndroidX-migrator.gradle.kts` and wait for completion. 7. Sync gradle project. 8. Build the project to ensure everything has migrated properly, or fix and try again. Improved API to use xml styles defined in Android or AppCompat \u00b6 Now, you pass the Context only once to the AndroidStyles or AppCompatStyles constructor, and you no longer have to pass it to the subsequent functions call. It is advised to obviously cache this instance to reduce boilerplate and avoid overhead. This is a breaking change. Package name changes and replaced artifacts \u00b6 The design support library no longer exists in AndroidX. It is replaced by several AndroidX artifacts and the Google Material Components library. Consequently, the package names no longer reference \"design\" but \"coordinatorlayout\" and \"material\" instead. As you can see below, the design support library dependent artifacts have been replaced. Note that Views DSL Material has a transitive dependency to Views DSL CoordinatorLayout, so you don't need to add an explicit dependency for the latter if you already use the former. New artifacts \u00b6 This release has the following new artifacts: \"com.louiscad.splitties:splitties-views-material:3.0.0-alpha01\" \"com.louiscad.splitties:splitties-views-dsl-coordinatorlayout:3.0.0-alpha01\" \"com.louiscad.splitties:splitties-views-dsl-material:3.0.0-alpha01\" Removed artifacts \u00b6 This release removes these two artifacts: \"com.louiscad.splitties:splitties-views-design-styles:2.1.1\" \"com.louiscad.splitties:splitties-views-dsl-design-styles:2.1.1\" Version 2.1.1 (2018-11-25) \u00b6 This release is compiled with Kotlin 1.3.10. Changes \u00b6 Enforce read-only in the withExtras extension function for Activity . Any attempt to mutate a property inside it will result in an IllegalStateException to be thrown, because this should be done in putExtras instead. You can see more info in the updated KDoc of these functions. Add a withExtras extension function for Intent (previously only available for Activity ). Add a putExtras extension function for Activity (previously only available for Intent ). Fix nullability warning in FragmentArgDelegate. Add KDoc to all public symbols from the Activities split. Add KDoc to all public symbols from the AlertDialog split. Add KDoc to all public symbols from the AlertDialog AppCompat split. Version 2.1.0 (2018-11-13) \u00b6 This release targets Android SDK 28, and splits depending on support libraries use version 28.0.0. Changes \u00b6 System Services from API 28 are now included into the same named split. Update ConfigChangesHandlingCollapsingToolbarLayout from View DSL Design to be compatible with design support library version 28.0.0. Update for nullability warnings brought by SDK 28. Version 2.0.0 (2018-11-13) \u00b6 This release targets Android SDK 27, and splits depending on support libraries use version 27.1.1. Changes \u00b6 Room updated to version 1.1.1 in Arch Room. Lambdas of onCreate and onOpen functions in Arch Room are now crossinline . The LifecycleObserver class is now marked as experimental. Version 2.0.0-beta1 (2018-11-13) \u00b6 This release breaks binary and source compatibility . Kotlin 1.3.0 \u00b6 This is not just a compiler update for Splitties. This release already takes advantage of Kotlin 1.3 features, beyond stable coroutines: The XmlStyle class from Views DSL is now inline, for minimal footprint at runtime. SuspendPrefsAccessor from Preferences is no longer experimental as coroutines graduated. Functions that take a lambda in Views DSL (except lParams functions) have a contract. This directly translates to more freedom in your UI code as you can initialize a property later. withExtras , putExtras and with from Bundle have a contract. This allows to initialize local variables from contents of a Bundle passing through a BundleSpec naturally! Symbols that could change are marked as experimental, for less surprises in the future when they are replaced, renamed or removed (still with a deprecation cycle whenever possible). Only verticalListLayoutParams and horizontalListLayoutParams extension functions for RecyclerView.LayoutManager are experimental for now, but this could change, especially in alpha, or beta stage. Version 2.0.0-alpha9 (2018-11-13) \u00b6 This release breaks binary and source compatibility . It renames several package names and modules, for more consistency across the project. View DSL has a new name: Views DSL. That also applies to its additional modules. Just like an extra s can make a new generation of smartphones, it can also make a new version of Splitties. The artifact names of all Selectable Views and View DSL changed, and so did the package names. Consequently, after updating the artifact names and the version, you'll need to update the imports. Fortunately, this is easily done with the \"Replace in Path\" IDE option present in IntelliJ IDEA and Android Studio. All you need to do is find an old import ( import splitties.viewdsl. ), select it, select the \"Replace in Path\" option paste ( import splitties.views.dsl. ) in the second input field, and validate. Then, you just have to do the same for Selectable Views with import splitties.selectableviews. and import splitties.views.selectable. \u2026 and voil\u00e0! You just migrated to latest Splitties version! New artifacts \u00b6 Here are all the artifacts added in this version. Just use the ones you need. (Click to expand) implementation ( \"com.louiscad.splitties:splitties-views-dsl:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-views-dsl-appcompat:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-views-dsl-constraintlayout:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-views-dsl-design:$splitties_version\" ) debugImplementation ( \"com.louiscad.splitties:splitties-views-dsl-ide-preview:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-views-dsl-recyclerview:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-views-selectable:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-views-selectable-appcompat:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-views-selectable-constraintlayout:$splitties_version\" ) All the lines above assume you defined the `splitties_version` ext property in your root project's `build.gradle` file to `2.0.0-alpha9` as shown in this snippet: allProjects { ext { splitties_version = '2.0.0-alpha9' } } Removed artifacts \u00b6 This release removes all these artifacts: implementation(\"com.louiscad.splitties:splitties-selectableviews:$splitties_version\") implementation(\"com.louiscad.splitties:splitties-selectableviews-appcompat:$splitties_version\") implementation(\"com.louiscad.splitties:splitties-selectableviews-constraintlayout:$splitties_version\") implementation(\"com.louiscad.splitties:splitties-viewdsl:$splitties_version\") implementation(\"com.louiscad.splitties:splitties-viewdsl-appcompat:$splitties_version\") implementation(\"com.louiscad.splitties:splitties-viewdsl-constraintlayout:$splitties_version\") implementation(\"com.louiscad.splitties:splitties-viewdsl-design:$splitties_version\") debugImplementation(\"com.louiscad.splitties:splitties-viewdsl-ide-preview:$splitties_version\") implementation(\"com.louiscad.splitties:splitties-viewdsl-recyclerview:$splitties_version\") Version 2.0.0-alpha8 (2018-11-12) \u00b6 This release breaks binary compatibility . It removes all deprecated symbols that had their deprecation level raised to error in 2.0.0-alpha7. Make sure you don't rely on any library that uses an old version of a Splitties artifact that relies on these previously deprecated and now removed symbols, or your app is likely not build, or to crash at runtime because of not found classes. Version 2.0.0-alpha7 (2018-11-12) \u00b6 Raise all deprecated symbols deprecation level to error. Use this version to make sure you don't use them in your projects, next version will remove them! Version 2.0.0-alpha6 (2018-11-11) \u00b6 Version 2.0.0-alpha5 broke the API, this version fixes this. Like version 2.0.0-alpha5, but without breaking the API from 2.0.0-alpha4 \u00b6 This release is mostly the same as 2.0.0-alpha5, but also has 2 very important things: - binary compatibility (minor change in Preferences experimental API excluded) - source compatibility, except an overload resolution ambiguity in View DSL, see the migration guide for a smooth migration. Removed splits and versions sync \u00b6 Version 2.0.0-alpha5 technically removed 2 splits (one was actually a renaming, the other one a merging). Consequently, you have to make sure your dependencies no longer reference these removed artifacts. Easily done. Problems arise when you depend on libraries that themselves depend on Splitties, which may be older versions. These libraries may bring transitive dependencies to old modules that will clash with ones from newer versions, and the versions they rely on may also mismatch with the ones you need, and these older versions will take precedence if they are in library modules of your project that don't depend explicitly on a newer version. Fortunately, Gradle dependency resolution strategy allows to easily fix these issues all over your project. All you need to do is to make sure you have the following snippet into your root project's build.gradle file: allprojects { ext { splitties_version = '2.0.0-alpha6' } configurations . all { resolutionStrategy . eachDependency { DependencyResolveDetails details -> def req = details . requested if ( req . group != \"com.louiscad.splitties\" ) return if ( req . name == \"splitties-uithread\" ) { details . useTarget ( group: req . group , name: \"splitties-mainthread\" , version: splitties_version ) details . because ( \"Splitties uithread has been renamed to mainthread\" ) } else if ( req . name == \"splitties-viewdsl-appcompat-styles\" ) { details . useTarget ( group: req . group , name: \"splitties-viewdsl-appcompat\" , version: splitties_version ) details . because ( \"[Splitties] Split merged and removed\" ) } else { details . useTarget ( group: req . group , name: req . name , version: splitties_version ) details . because ( \"Transitive dependencies could take precedence otherwise\" ) } } } } The snippet above, for all sub-projects (aka. modules): 1. defines Splitties version in an ext property so it can be used in all build.gradle files. 2. sets a resolution strategy for all configurations (like implementation or api ) which: 1. redirects any usage of the old splitties-mainthread artifact to the new splitties-mainthread one. 2. redirects any usage of the old splitties-viewdsl-appcompat-styles artifact to the one it has been merged into: splitties-viewdsl-appcompat . 3. makes sure all splitties artifacts versions are in sync, across all sub-projects. If you don't do this but have a library using an old artifact in your dependencies, you'll encounter gradle sync issues, or runtime issues, and the real cause may not appear clearly (because of bugs in tooling). Changes per module \u00b6 Checked Lazy \u00b6 uiLazy has been deprecated in favor of mainThreadLazy . View DSL RecyclerView \u00b6 The wrapInRecyclerView extension function now accepts an optional lambda to configure the wrapping RecyclerView easily. Version 2.0.0-alpha5 (2018-11-02) \u00b6 This release is breaking if you come from version 2.0.0-alpha4, especially if you were using View DSL. It's highly recommended to directly migrate from version 2.0.0-alpha4 to 2.0.0-alpha6, which has a smoother migration path, and a guide to do so. Project wide changes \u00b6 Add consumer proguard rules for splits with optional dependencies. Update to Kotlin 1.2.71 Update kotlinx.coroutines to version 0.30.2 Changes per module \u00b6 Collections \u00b6 Add allocation-free reverse List forEach extensions: forEachReversedByIndex and forEachReversedWithIndex . Intents \u00b6 Add toPendingActivities() extension function for Array<Intent> . Material Lists \u00b6 The following previously deprecated classes have been removed: SingleLineIconListItem (use IconOneLineListItem instead) TwoLinesIconListItem (use IconTwoLinesListItem instead) TwoLinesIconSwitchListItem (use IconTwoLinesSwitchListItem instead) All the xml files (except view_ids.xml ) have been removed. Preferences \u00b6 Enhancements \u00b6 The preferences are now loaded in Dispatchers.IO when using SuspendPrefsAccessor . Fix clash with private property name and non imported extension for Preferences. (#96). Breaking changes (in experimental API) \u00b6 The SuspendPrefsAccessor constructor parameter of type CoroutineDispatcher has been removed now that Dispatchers.IO is always used. If you didn't specify a custom dispatcher, you don't need to do anything. Selectable Views (all variants) \u00b6 All the final methods have been opened up, and now have the @CallSuper annotation instead. This makes the classes more useful to develop custom views, like the extended Floating Action Button with SelectableConstraintLayout where you need to clip the view in onDraw(\u2026) . The dispatchDrawableHotspotChanged overridden method in the classes of the Selectable Views splits family was annotated with @TargetApi , but is not correctly annotated with @RequiresApi . This likely caused no issue as you usually don't call this method directly but let Android do, but now, it's fixed! ~UI Thread~ -> Main Thread \u00b6 The UI Thread split has been renamed to Main thread (for the same reasons kotlinx.coroutines replaced UI by Dispatchers.Main ). While the artifact has been changed , the old symbols have only been deprecated in favor of new ones defined in new package, with new names ( ui -> main ). If you use a library that depends on the old artifact, see \"Removed splits and versions sync\" in version 2.0.0-alpha6 release notes. View DSL (and additional modules) \u00b6 The API of View DSL (and its additional modules) has been improved, and there's some new features, along with some deprecations. However, this release (2.0.0-alpha5) is breaking when updating from previous versions. This has been fixed in 2.0.0-alpha6, so please skip this release if you are upgrading , and follow thoroughly the migration guide . Regardless, there has been improvements in View DSL additional modules. Please, review them below. ~View DSL AppCompat Styles~ -> View DSL AppCompat \u00b6 The View DSL AppCompat Styles split has been merged into View DSL AppCompat. If you use a library that depends on the old artifact, see \"Removed splits and versions sync\" in version 2.0.0-alpha6 release notes. View DSL ConstraintLayout \u00b6 Probably the best change in this split is that now, you no longer need to specify any View id. If there's none and you add a constraint using extension functions from this split, an id that can't clash with aapt/xml ids will be generated and assigned to the view so constraints work. Keep in mind you may still want to use stable ids defined in xml or elsewhere in cases where you use views that need to have their state saved, like a RecyclerView , an EditText or a CheckBox . Added support for chains with the two horizontalChain and verticalChain new extension functions for ConstraintLayout . Also added horizontalMargin and verticalMargin extension properties for List<View> that are designed for use in a ConstraintLayout when you made a chain with the two new methods that take a list of views. View DSL Design \u00b6 When instantiating an AppBarLayout or a CollapsingToolbarLayout with the new appBarLayout and collapsingToolbarLayout functions, you'll automatically get instances that have known bugs in the design support library fixed, including config changes handling (supports rotation or layout changes without recreating the Activity). View DSL RecyclerView \u00b6 The setSingleView extension function for RecyclerView has been deprecated. Use the wrapInRecyclerView extension function for View instead, it is simpler to use and supports horizontal scrolling. Views \u00b6 Deprecated View visibility extension properties and functions in favor of Android KTX ones. Added lines write only extension property for TextView . Change the signature of the lambda of the onClick extension function for View . It no longer passes the clicked view . This is to avoid it shadowing when you nest lambdas, and has been done because this parameter is almost never used. Add 1 extension function, 1 extension property and 1 top level function, related to View id generation: View.assignAndGetGeneratedId() , View.existingOrNewId and generateViewId() . Upcoming APIs preview in the sample \u00b6 The sample of Splitties is a place where you can preview several extensions or other work that can be integrated into Splitties as a library later. In addition to what was already present in the sample, there has been an important addition: An example of how to request a dangerous permission with a single suspend call, plus a try/catch to handle user deny. New artifact \u00b6 This release has a new artifact: implementation ( \"com.louiscad.splitties:splitties-mainthread:$splitties_version\" ) Removed artifacts \u00b6 This release removes these two artifacts: implementation(\"com.louiscad.splitties:splitties-uithread:$splitties_version\") implementation(\"com.louiscad.splitties:splitties-viewdsl-appcompat-styles:$splitties_version\") Version 2.0.0-alpha4 (2018-07-09) \u00b6 Provide ReplaceWith migrations for add methods deprecated in version 2.0.0-alpha2. Add default empty lambda for startActivity(action: String\u2026) methods. Compiled with Kotlin 1.2.51 Version 2.0.0-alpha3 (2018-06-09) \u00b6 New features \u00b6 Bundle \u00b6 There are 2 new methods: bundleOrDefault(\u2026) and bundleOrElse { \u2026 } to allow default values in BundleSpec delegated properties. Fragment Args \u00b6 Like for BundleSpec , there are 2 new methods: argOrDefault(\u2026) and argOrElse { \u2026 } to allow default values in Fragment delegated argument properties. Breaking changes \u00b6 Bundle \u00b6 The delegates previously returned by bundle() and bundleOrNull() are no longer part of the public API and have been replaced by the ReadWriteProperty interface. Fragment Args \u00b6 The arg() and argOrNull() functions have moved out of the support subpackage as there's no longer any ambiguity since platform Fragments are deprecated and going away. Auto-import should import the versions from the new package for you. The delegates previously returned by arg() and argOrNull() are no longer part of the public API and have been replaced by the ReadWriteProperty interface. Version 2.0.0-alpha2 (2018-05-21) \u00b6 9 new library modules (amounting to a total of 42 splits): \u00b6 Activities : Start activities with minimal boilerplate Collections : forEach for List s without Iterator allocation Fragments : Start activities from fragments and do transactions with minimal boilerplate Intents : Transform companion object s into powerful typesafe intent specs Material Colors : 2014 Material Design color palettes as color resources View DSL RecyclerView : RecyclerView extension of View DSL Views CardView : CardView extension of Views. Provides a contentPadding property View Design : Design Support library extension of Views Views RecyclerView : RecyclerView extension of Views Other changes: \u00b6 AppCtx \u00b6 The consume { \u2026 } utility function from the splitties.init package has been deprecated. Replace it with true.also { _ -> \u2026 } or false.also { _ -> \u2026 } . Arch Lifecycle \u00b6 New mapNotNull , switchMap and switchMapNotNull extension functions for LiveData . activityScope and fragmentScope extension functions to get a ViewModel now accept an optional lambda (which creates a ViewModelProvider under the hood. This allows to pass arguments to your ViewModel when it's first created. observe and observeNotNull now return the created Observer so it can be unregistered manually later if needed. Arch Room \u00b6 The new inTransaction { \u2026 } extension function for RoomDatabase s does the same as transaction { \u2026 } but also returns the value of the last expression of the lambda. New onCreate { \u2026 } and onOpen { \u2026 } extension functions for RoomDatabase.Builder . Bundle \u00b6 BundleHelper has been renamed to BundleSpec , but a typealias keeps the source compatibility. However, there's no binary compatibility, which means you'll need to recompile any library using it. BundleSpec and the methods relying on it can now be used safely on any thread! Material Lists \u00b6 Allow disabling default icon tint on list items with optional constructor parameter. Preferences \u00b6 A new experimental SuspendPrefsAccessor for coroutines users allows you to ensure you can't load the preferences (which does I/O) on the UI thread. Resources \u00b6 The str extension functions formatArgs now accept null arguments. View DSL \u00b6 The higher order function add has been deprecated because it went in the way of promoting a view to a property easily. View DSL AppCompat styles \u00b6 Added flatButton , imgActionButton and largeProgressBar . View DSL ConstraintLayout \u00b6 Add baselineToBaselineOf(\u2026) extension function for ConstraintLayout.LayoutParams . View DSL IDE Preview \u00b6 UiPreView injects a valid value into appCtx so your Ui s can depend on it (probably indirectly) without breaking preview! Views \u00b6 New Gravity flags aliases (e.g. gravityStartCenter instead of Gravity.START or Gravity.CENTER_VERTICAL ). Change case of imageBitMap to imageBitmap to make it more consistent with the class name Bitmap Views AppCompat \u00b6 tooltipTxt now accepts null to remove any tooltip previously set on the view. New artifacts \u00b6 Here are all the artifacts added in this version. Just use the ones you need. (Click to expand) implementation ( \"com.louiscad.splitties:splitties-activities:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-collections:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-fragments:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-intents:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-material-colors:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-viewdsl-recyclerview:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-views-cardview:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-views-design:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-views-recyclerview:$splitties_version\" ) All the lines above assume you defined the `splitties_version` ext property in your root project's `build.gradle` file to `2.0.0-alpha2` as shown in this snippet: allProjects { ext { splitties_version = '2.0.0-alpha2' } } Version 2.0.0-alpha1 (2018-03-11) \u00b6 26 new library modules (amounting to a total of 33 splits): \u00b6 Alert Dialog : Create simple alert dialogs with simple code Alert Dialog AppCompat : AppCompat version of Alert Dialog Arch Lifecycle : Extensions to get ViewModel s, use LiveData and observe Lifecycle s Arch Room : Room helpers to instantiate your DB and perform transactions in Kotlin Bit Flags : hasFlag , withFlag and minusFlag extensions on Long , Int , Short and Byte Bundle : BundleHelper to use Bundle with property syntax for Intent extras and more Dimensions : Android dp extensions for View and Context . Particularly handy when using View DSL Exceptions : illegal(\u2026) and similar functions that return Nothing , handy for impossible or illegal when branches Fragment Args : Fragment arguments without ceremony thanks to delegated properties Init Provider : Base class for ContentProvider s used for automatic initialization purposes Main Handler : Top-level mainHandler property to stop allocating multiple Handler s for main Looper Resources : Extensions to get resources like strings, colors or drawables easily, with support for themed attributes Selectable Views AppCompat : Selectable Views for AppCompatTextView Selectable Views ConstraintLayout : Selectable Views for ConstraintLayout Snackbar : Grab a snack without ceremony with snack(\u2026) and longSnack(\u2026) System Services : No more context.getSystemService(NAME_OF_SERVICE) as NameOfManager Toast : Show a toast by just calling toast(yourText) , and dodge API 25 BadTokenException UI Thread : Properties related to Android UI thread, and checkUiThread() precondition checker View DSL : Create UIs with readable Kotlin code View DSL AppCompat : AppCompat extension of View DSL View DSL AppCompat styles : AppCompat styles for View DSL View DSL ConstraintLayout : ConstraintLayout extension of View DSL View DSL Design : Design Support Library extension of View DSL View DSL IDE preview : Preview View DSL UIs in the IDE Views : Extensions function and properties on View s Views AppCompat : AppCompat extension of Views. Includes helpers for ImageView tinting, ActionBar and tooltip 1 renamed module: \u00b6 \"Checked Lazy\" replaces the \"Concurrency\" module. Other changes: \u00b6 The groupId of the library changed from xyz.louiscad.splitties to com.louiscad.splitties . Check dependencies list below. All previous modules migrated to Kotlin, excepted the ViewHolder class from the Typesafe RecyclerView module that can't be written in Kotlin at the moment due to hiding super fields not being supported. App Context module has a new, memory leak safe injectAsAppCtx() method, that uses the new canLeakMemory() extension function on Context that is also public. Preferences StringPref and stringPref don't allow null values anymore. Use StringOrNullPref and stringOrNullPref if you need nullable strings. Same for StringSetPref and stringSetPref . The isUiThread property moved from the old \"Concurrency\" module to the \"UI Thread\" module. Material Lists are now written in Kotlin with View DSL, fixing icon tinting support on day/night themes and behavior on long texts. Also, the naming has been improved. Old named items are now deprecated. Checked Lazy does no longer depend on Timber but is now more configurable, allowing to write reporting behavior if needed. Selectable Views has been split in base module (that includes only dependencies on Android platform), AppCompat module and ConstraintLayout module. Selectable Views don't support the foreground xml attribute from app namespace anymore, but there's a new foregroundSelector property. New artifacts \u00b6 Here are all the artifacts added in this version. Just use the ones you need. (Click to expand) implementation ( \"com.louiscad.splitties:splitties-alertdialog:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-alertdialog-appcompat:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-appctx:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-arch-lifecycle:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-arch-room:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-bitflags:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-bundle:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-checkedlazy:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-dimensions:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-exceptions:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-initprovider:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-mainhandler:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-material-lists:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-preferences:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-resources:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-fragmentargs:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-selectableviews:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-selectableviews-appcompat:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-selectableviews-constraintlayout:$splitties_version\" ) debugImplementation ( \"com.louiscad.splitties:splitties-stetho-init:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-systemservices:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-toast:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-typesaferecyclerview:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-uithread:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-snackbar:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-viewdsl:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-viewdsl-appcompat:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-viewdsl-appcompat-styles:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-viewdsl-constraintlayout:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-viewdsl-design:$splitties_version\" ) debugImplementation ( \"com.louiscad.splitties:splitties-viewdsl-ide-preview:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-views:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-views-appcompat:$splitties_version\" ) All the lines above assume you defined the `splitties_version` ext property in your root project's `build.gradle` file to `2.0.0-alpha1` as show in this snippet: allProjects { ext { splitties_version = '2.0.0-alpha1' } } Version 1.3.0 (2017-04-17) \u00b6 5 new library modules: \u00b6 App Context : Have a Context everywhere Concurrency : Single thread lazy implementations, with reporting via Timber support Material Lists : List Items for RecyclerView implementing Material Design Guidelines Preferences : Property syntax for Android's SharedPreferences Stetho init : Have Stetho without writing any code! 1 renamed module: \u00b6 Selectable Views replaces Selectable ViewGroups Other changes: \u00b6 Selectable Views now has a SelectableTextView . Made to use it on simple, single-line list items. Typesafe RecyclerView now depends on Kotlin Typesafe RecyclerView has a new ItemViewHolder helper class for simple but common use cases. Version 1.2 (2016-09-19) \u00b6 This version adds the setHost(Host host) method in ViewWrapper.Binder interface where Host can be any type you want you can use from the implementing item View to communicate with your Activity, Fragment, Presenter, or whatever. Note this adds a third type parameter to the ViewWrapper class, and a second one for the ViewWrapper.Binder class. Version 1.1 (2016-09-11) \u00b6 This version adds the setViewHolder(ViewWrapper holder) method in ViewWrapper.Binder interface so list item View s can now get a reference to their ViewHolder , and call getAdapterPosition() on it for example. Version 1.0 (2016-08-24) \u00b6 This is the first release of Splitties. It includes two independent modules: - Typesafe RecyclerView - Selectable ViewGroups For gradle projects from jcenter() repo: compile 'xyz.louiscad.splitties:selectableviewgroups:1.0' compile 'xyz.louiscad.splitties:typesaferecyclerview:1.0'","title":"Change Log"},{"location":"CHANGELOG/#change-log-for-splitties","text":"","title":"Change log for Splitties"},{"location":"CHANGELOG/#version-300-2021-08-20","text":"Compiled with Kotlin 1.5.21 and kotlinx.coroutines 1.5.1-native-mt. Finally! Splitties 3.0.0 is there, and it's ready to keep iterating. The last 2.x version, the 2.1.1 dates back from 2018-11-25, close to 3 years ago. Why did it take so long to have version 3.0.0? Let's say making a multi-modules, multiplatform library isn't full of easy and straightforward steps. A blog post (my first!) will be published later to share that experience from start to now. Feel free to click follow on blog.louiscad.com , or on Twitter to know when the story is published. I'll also share a roadmap for Splitties there, which I hope will get you excited for your future endeavors. Let's get into the actual content of this release:","title":"Version 3.0.0 (2021-08-20)"},{"location":"CHANGELOG/#documentation-updates-and-improvements-and-website","text":"In case you missed it, Splitties now has a website, happily powered by Material for MKDocs . The address is splitties.louiscad.com . The main page shows a better overview of what Splitties is about, and its content. It should be helpful for newcomers. The setup info for each module is now upfront in their respective doc pages, be it on the website, or on GitHub, and they have been updated to recommend using the dependency notations from refreshVersions , which will also help you update Splitties, along with other libraries, and all that in less time. Full disclosure: I am working on refreshVersions myself, in close collaboration with its author, Jean-Michel Fayard. I use it, and I totally recommend it for all Gradle projects. Splitties is using it of course.","title":"Documentation updates and improvements, and website"},{"location":"CHANGELOG/#bit-flags","text":"","title":"Bit Flags"},{"location":"CHANGELOG/#changed","text":"The hasFlag , withFlag , and minusFlag extensions for unsigned integers ( UByte , UShort , UInt , and ULong ) are no longer annotated with the @ExperimentalUnsignedTypes annotation.","title":"Changed"},{"location":"CHANGELOG/#preferences","text":"","title":"Preferences"},{"location":"CHANGELOG/#added","text":"There's a new DataStorePreferences class for the Android side, which you can use as a substitute of the Preferences class. If you were already using SuspendPrefsAccessor , that's all you need to change. This AndroidX DataStore backed implementation should remove the risks of your app and their users being affected by the potential performance issues of Android platform's SharedPreferences . Be sure to check out the updated docs !","title":"Added"},{"location":"CHANGELOG/#version-300-rc03-2021-08-06","text":"Compiled with Kotlin 1.5.21 and kotlinx.coroutines 1.5.1-native-mt.","title":"Version 3.0.0-rc03 (2021-08-06)"},{"location":"CHANGELOG/#app-context","text":"","title":"App Context"},{"location":"CHANGELOG/#added_1","text":"The AppCtxInitializer class is now public, so you can put it in the list of dependencies of your own AndroidX App Startup Initializer in case it relies on appCtx to be initialized.","title":"Added"},{"location":"CHANGELOG/#resources","text":"","title":"Resources"},{"location":"CHANGELOG/#fix","text":"In 3.0.0-rc02, changes in styledColorSL made it break when the theme attribute was pointing to a color resource that had no selector (i.e. a non inlined plain color code like #00bbff ). This has now been fixed, and the code also got simpler.","title":"Fix"},{"location":"CHANGELOG/#version-300-rc02-2021-08-03","text":"Compiled with Kotlin 1.5.21 and kotlinx.coroutines 1.5.1-native-mt.","title":"Version 3.0.0-rc02 (2021-08-03)"},{"location":"CHANGELOG/#resources_1","text":"","title":"Resources"},{"location":"CHANGELOG/#fixes","text":"By resolving a subtle issue that could break IDE preview, the version 3.0.0-alpha07 of Splitties also broke the styledColor function and some other in come cases. If you had a color theme attribute and had a theme that was setting its value, pointing to another color resource, you'd be in luck. However, if the color value was set inline, right into the theme, it'd crash ( as you can see in this issue ). This release fixes this kind of problem for all the affected functions: - styledColor - styledColorSL - styledDimen - styledDimenPxSize - styledDimenPxOffset - styledBool - styledInt - styledTxt - styledStr","title":"Fixes"},{"location":"CHANGELOG/#version-300-rc01-2021-08-01","text":"Compiled with Kotlin 1.5.21 and kotlinx.coroutines 1.5.1-native-mt. This release removes previously deprecated code. Make sure you don't have transitive dependencies that relied on deprecated code from a previous release of Splitties! If that's the case, you'll see the host app crash at runtime.","title":"Version 3.0.0-rc01 (2021-08-01)"},{"location":"CHANGELOG/#removed","text":"The \"Init provider\" split has been removed and is no longer published starting with this release. You can find if you are using it by searching for its maven coordinates: com.louiscad.splitties:splitties-initprovider (the \"Find in Path\" IDE option can help you locate it). If you used it, you'll need to move to AndroidX App Startup . All the other previously deprecated symbols at hidden level have been removed. This completes the deprecation cycle for the upcoming Splitties 3.0.0 release.","title":"Removed"},{"location":"CHANGELOG/#version-300-beta06-2021-08-01","text":"Compiled with Kotlin 1.5.21 and kotlinx.coroutines 1.5.1-native-mt. This release is advancing deprecation cycles further before the upcoming 3.0.0 release.","title":"Version 3.0.0-beta06 (2021-08-01)"},{"location":"CHANGELOG/#deprecation-cycle","text":"All previously deprecated symbols were either removed, or hidden: Error \u2192 Hidden Hidden \u2192 Removed","title":"Deprecation cycle"},{"location":"CHANGELOG/#version-300-beta05-2021-08-01","text":"Compiled with Kotlin 1.5.21 and kotlinx.coroutines 1.5.1-native-mt. This release is advancing deprecation cycles before the upcoming 3.0.0 release.","title":"Version 3.0.0-beta05 (2021-08-01)"},{"location":"CHANGELOG/#deprecation-cycle_1","text":"All previously deprecated symbols were either removed, or moved one step closer to it: Warning \u2192 Error Error \u2192 Hidden Hidden \u2192 Removed","title":"Deprecation cycle"},{"location":"CHANGELOG/#version-300-beta04-2021-07-30","text":"Compiled with Kotlin 1.5.21 and kotlinx.coroutines 1.5.1-native-mt.","title":"Version 3.0.0-beta04 (2021-07-30)"},{"location":"CHANGELOG/#fix_1","text":"Fix iOS/multiplatform publication (see issue #280 ).","title":"Fix"},{"location":"CHANGELOG/#version-300-beta03-2021-07-17","text":"Compiled with Kotlin 1.5.21 and kotlinx.coroutines 1.5.1-native-mt. Other transitive dependencies have also been upgraded to the latest stable version. It includes upgrades to various AndroidX libraries, Material Design Components 1.4.0, and Stetho 1.6.0. This release is advancing deprecation cycles before the upcoming, long awaited 3.0.0 release.","title":"Version 3.0.0-beta03 (2021-07-17)"},{"location":"CHANGELOG/#coroutines","text":"","title":"Coroutines"},{"location":"CHANGELOG/#deprecations","text":"The SendChannel.offerCatching has been deprecated in favor of trySend from kotlinx.coroutines 1.5+ The deprecation level of awaitCancellation() has been raised from warning to error. Use the one from kotlinx.coroutines instead.","title":"Deprecations"},{"location":"CHANGELOG/#lifecycle-coroutines","text":"","title":"Lifecycle coroutines"},{"location":"CHANGELOG/#deprecations_1","text":"Dispatchers.MainAndroid deprecation level has been raised from warning to error. Using Dispatchers.Main is fine performance wise since kotlinx.coroutines 1.3.3. The PotentialFutureAndroidXLifecycleKtxApi annotation deprecation level was also raised to error. The following symbols that were previously deprecated at error level are now hidden and will be removed in the next release: - Lifecycle.coroutineScope - Lifecycle.job - LifecycleOwner.lifecycleScope - MainDispatcherPerformanceIssueWorkaround","title":"Deprecations"},{"location":"CHANGELOG/#preferences_1","text":"","title":"Preferences"},{"location":"CHANGELOG/#deprecations_2","text":"Raise the deprecation level of the implicit key delegates from warning to error.","title":"Deprecations"},{"location":"CHANGELOG/#resources_2","text":"","title":"Resources"},{"location":"CHANGELOG/#deprecations_3","text":"Raise the deprecation level of Context.withStyledAttributes to error.","title":"Deprecations"},{"location":"CHANGELOG/#views-appcompat","text":"","title":"Views AppCompat"},{"location":"CHANGELOG/#deprecations_4","text":"Raise the deprecation level of ActionBar.showHomeAsUp to error.","title":"Deprecations"},{"location":"CHANGELOG/#version-300-beta02-2021-07-08","text":"Compiled with Kotlin 1.4.32 and kotlinx.coroutines 1.4.3-native-mt. This is the first release of Splitties that is published on MavenCentral! The maven coordinates are the same. Also, there's now a documentation website on splitties.louiscad.com , check it out!","title":"Version 3.0.0-beta02 (2021-07-08)"},{"location":"CHANGELOG/#alert-dialog","text":"Add \"calls in place exactly once\" contracts for the lambdas of all the alertDialog functions.","title":"Alert Dialog"},{"location":"CHANGELOG/#alert-dialog-appcompat","text":"Add \"calls in place exactly once\" contracts for the lambdas of all the alertDialog functions.","title":"Alert Dialog AppCompat"},{"location":"CHANGELOG/#alert-dialog-appcompat-coroutines","text":"Fix rare crash that could happen when waiting for a button click if multiple ones were clicked simultaneously. Now, only the first one to be considered clicked by the system will trigger, and the second one will be ignored.","title":"Alert Dialog AppCompat Coroutines"},{"location":"CHANGELOG/#alert-dialog-material","text":"Add \"calls in place exactly once\" contracts for the lambdas of all the materialAlertDialog functions.","title":"Alert Dialog Material"},{"location":"CHANGELOG/#app-context_1","text":"Replace the initializing ContentProvider with AndroidX App Startup.","title":"App Context"},{"location":"CHANGELOG/#coroutines_1","text":"Deprecate awaitCancellation() in favor of the one now included right into kotlinx.coroutines.","title":"Coroutines"},{"location":"CHANGELOG/#lifecycle-coroutines_1","text":"Introduce the whileStarted(Lifecyle) extension function for Flow to have a flow emit values only while the passed Lifecycle is started.","title":"Lifecycle Coroutines"},{"location":"CHANGELOG/#stetho-init","text":"Replace the initializing ContentProvider with AndroidX App Startup.","title":"Stetho Init"},{"location":"CHANGELOG/#version-300-beta01-2020-09-14","text":"Compiled with Kotlin 1.4.10 and kotlinx.coroutines 1.3.9-native-mt. This release has multiplatform splits compatible with iOS, macOS and watchOS projects that use Kotlin/Native 1.4.0 and 1.4.10. Feedback is appreciated (Twitter, Kotlin's Slack, GitHub issues\u2026).","title":"Version 3.0.0-beta01 (2020-09-14)"},{"location":"CHANGELOG/#platforms-added","text":"watchOS support has been added to the following splits : - Bit Flags - Collections - Coroutines - Main Thread - Preferences All CPU architectures are supported (arm32, arm64 & X86 for simulator).","title":"Platforms added"},{"location":"CHANGELOG/#arch-room","text":"","title":"Arch Room"},{"location":"CHANGELOG/#deprecated","text":"Deprecated the transaction and inTransaction extension functions in favor of withTransaction (Room KTX) and runInTransaction (Room runtime) itself.","title":"Deprecated"},{"location":"CHANGELOG/#init-provider","text":"","title":"Init Provider"},{"location":"CHANGELOG/#changed_1","text":"Now requires to opt-in to @ObsoleteContentProviderHack . This split will be deprecated once App Startup from AndroidX goes stable.","title":"Changed"},{"location":"CHANGELOG/#lifecycle-coroutines_2","text":"","title":"Lifecycle Coroutines"},{"location":"CHANGELOG/#deprecated_1","text":"Deprecated symbols now have error level. Next release will remove them.","title":"Deprecated"},{"location":"CHANGELOG/#removed_1","text":"LifecycleOwner.coroutineScope that was at error deprecation level. Use LifecycleOwner.lifecycleScope from AndroidX instead.","title":"Removed"},{"location":"CHANGELOG/#toast","text":"","title":"Toast"},{"location":"CHANGELOG/#changed_2","text":"Using this API now requires to opt-in to @UnreliableToastApi so the developers acknowledge the gotchas of android.widget.Toast or use something else (like snackbars, banners or dialogs).","title":"Changed"},{"location":"CHANGELOG/#views","text":"","title":"Views"},{"location":"CHANGELOG/#added_2","text":"Add the following read/write extensions properties for View : - startPadding - endPadding - leftPadding - rightPadding","title":"Added"},{"location":"CHANGELOG/#changed_3","text":"The onClick parameter changed from a crossinline lambda to a View.OnClickListener now that Kotlin 1.4 brings SAM conversion for Kotlin functions taking SAM Java interfaces. Usage should not change. Note that there is now an implicit it parameter of type View that might break existing code if an outer it was used in the onClick lambda.","title":"Changed"},{"location":"CHANGELOG/#views-dsl","text":"","title":"Views DSL"},{"location":"CHANGELOG/#changed_4","text":"All lambdas in AndroidStyles now have a contract. That allows you to initialize val s declared in the outer scope.","title":"Changed"},{"location":"CHANGELOG/#views-dsl-appcompat","text":"","title":"Views DSL AppCompat"},{"location":"CHANGELOG/#changed_5","text":"Only instantiate AppCompat version of Android widgets if the current theme inherits an AppCompat theme. All lambdas in AppCompatStyles now have a contract. That allows you to initialize val s declared in the outer scope.","title":"Changed"},{"location":"CHANGELOG/#added_3","text":"Add the missing AppCompat version of ToggleButton .","title":"Added"},{"location":"CHANGELOG/#views-dsl-material","text":"","title":"Views DSL Material"},{"location":"CHANGELOG/#changed_6","text":"Only instantiate Material Components version of Android widgets if the current theme inherits a material theme. All lambdas in MaterialComponentsStyles now have a contract. That allows you to initialize val s declared in the outer scope.","title":"Changed"},{"location":"CHANGELOG/#added_4","text":"Add the following missing Material Components counterparts of Android widgets: CheckBox , RadioButton , TextView , AutoCompleteTextView .","title":"Added"},{"location":"CHANGELOG/#version-300-alpha07-2020-09-01","text":"Compiled with Kotlin 1.3.72 and kotlinx.coroutines 1.3.8. This release introduces 2 new splits: - Alert Dialog Material (Android only) It is included in the \"Android Material Components\" fun pack. Thanks @ivoberger for the contribution! - Coroutines (supports macOS, iOS, JS, JVM & Android) It is included in the \"Android base\" fun pack.","title":"Version 3.0.0-alpha07 (2020-09-01)"},{"location":"CHANGELOG/#alert-dialog-and-alert-dialog-appcompat","text":"","title":"Alert Dialog and Alert Dialog AppCompat"},{"location":"CHANGELOG/#added_5","text":"Add isCancellable parameter (defaults to true , as when unspecified) to alertDialog builders.","title":"Added"},{"location":"CHANGELOG/#arch-lifecycle","text":"","title":"Arch Lifecycle"},{"location":"CHANGELOG/#added_6","text":"viewModels { \u2026 } for FragmentActivity and Fragment activityViewModels { \u2026 } for Fragment","title":"Added"},{"location":"CHANGELOG/#changed_7","text":"This split no longer depends on the androidx.lifecycle:lifecycle-extensions artifact that has been deprecated in AndroidX Lifecycle 2.2.0 and is no longer published in later versions.","title":"Changed"},{"location":"CHANGELOG/#deprecated_2","text":"AndroidX Lifecycle KTX artifacts caught up with features that this split originally provided, so we've deprecated that overlap: activityScope() for Activity -> viewModels() activityScope() for Fragment -> activityViewModels() fragmentScope() for Fragment -> viewModels() Also, we provided variants of these that took a lambda. Since AndroidX doesn't provide such a facility, they have been kept, but the old naming has been deprecated to match the AndroidX naming. Note that these changes provide a ReplaceWith clause for easy migration. Important: Next alpha release will move the deprecation level to error, and the alpha release after will remove them completely. (So it's best to not skip this update if you were using these extensions.)","title":"Deprecated"},{"location":"CHANGELOG/#collections","text":"","title":"Collections"},{"location":"CHANGELOG/#added_7","text":"forEachReversedWithIndex extension for List now has an allowSafeModifications parameter. When set to true (default is false ), you can mutate the list as long as it doesn't prevent the next iteration from happening (or that you perform a non local return to stop iterating altogether). As usual, unsafe operations while iterating a list can result in a ConcurrentModificationException or in an IndexOutOfBoundsException to be thrown.","title":"Added"},{"location":"CHANGELOG/#dimensions","text":"","title":"Dimensions"},{"location":"CHANGELOG/#changed_8","text":"The dip and dp functions now return the type of their argument ( Int or Float ). You'll need to migrate usages of the previous dp function, so they pass a Float . Use \"Find in Path\" in the IDE to find them before fixing. If you often passed the same value to dp , the \"Replace in Path\" IDE option can save you even more time.","title":"Changed"},{"location":"CHANGELOG/#lifecycle-coroutines_3","text":"","title":"Lifecycle Coroutines"},{"location":"CHANGELOG/#added_8","text":"Lifecycle.isStartedFlow() Lifecycle.isStartedFlow(timeout: Duration) Lifecycle.isResumedFlow() Lifecycle.isResumedFlow(timeout: Duration) Lifecycle.stateFlow(): Flow<Lifecycle.State>","title":"Added"},{"location":"CHANGELOG/#changed_9","text":"The following extension functions for Lifecycle have been promoted to @ExperimentalSplittiesApi (from @PotentialFutureAndroidXLifecycleKtxApi ): - createScope - createJob - awaitResumed - awaitStarted - awaitCreated - awaitState","title":"Changed"},{"location":"CHANGELOG/#deprecated_3","text":"Dispatchers.MainAndroid is no longer needed and has been deprecated since the performance issue that affected Dispatchers.Main has been fixed since kotlinx.coroutines 1.3.3 . The following extension properties have been deprecated because they are now provided by AndroidX Lifecycle Runtime KTX: - Lifecycle.coroutineScope - LifecycleOwner.lifecycleScope Lifecycle.job has also been deprecated even though there's no as-concise replacement because it doesn't satisfy a common use case.","title":"Deprecated"},{"location":"CHANGELOG/#main-thread","text":"","title":"Main Thread"},{"location":"CHANGELOG/#added_9","text":"Now supports macOS, iOS and JS.","title":"Added"},{"location":"CHANGELOG/#material-lists","text":"","title":"Material Lists"},{"location":"CHANGELOG/#changed_10","text":"Ensure all TextView s in the list items are at least one line tall, even if the text is empty. Support enabled/disabled state by making child views duplicate parent state.","title":"Changed"},{"location":"CHANGELOG/#permissions","text":"","title":"Permissions"},{"location":"CHANGELOG/#added_10","text":"New ensureAllPermissions function available in top-level and as extension for FragmentActivity and Fragment to request multiple permissions in a row and ensure you have them all granted.","title":"Added"},{"location":"CHANGELOG/#preferences_2","text":"","title":"Preferences"},{"location":"CHANGELOG/#added_11","text":"Now supports macOS and iOS (backed by NSUserDefaults , but supports custom implementation too, just like on Android). Added preferences property to PrefDelegate s. Added key property to PrefDelegate s. Added valueFlow() function to PrefDelegate s to get current value and changes of a pref field.","title":"Added"},{"location":"CHANGELOG/#changed_11","text":"The availableAtDirectBoot parameter has been renamed to androidAvailableAtDirectBoot . The XxxPref classes (e.g. BoolPref , StringPref , etc.) are no longer inner classes but are now part of the PrefDelegate sealed class hierarchy.","title":"Changed"},{"location":"CHANGELOG/#resources_3","text":"","title":"Resources"},{"location":"CHANGELOG/#added_12","text":"New resolveThemeAttribute extension function for Context . This is the replacement for withStyledAttributes .","title":"Added"},{"location":"CHANGELOG/#deprecated_4","text":"withStyledAttributes must be replaced by new resolveThemeAttribute that also has an implementation that is working reliably in IDE Preview. It will be removed in a future release.","title":"Deprecated"},{"location":"CHANGELOG/#snackbar","text":"","title":"Snackbar"},{"location":"CHANGELOG/#changed_12","text":"The snack , longSnack and snackForever extension functions now work with any View instead of just CoordinatorLayout .","title":"Changed"},{"location":"CHANGELOG/#system-services","text":"","title":"System Services"},{"location":"CHANGELOG/#added_13","text":"Add biometricManager from API 29. Add roleManager from API 29.","title":"Added"},{"location":"CHANGELOG/#views-appcompat_1","text":"","title":"Views AppCompat"},{"location":"CHANGELOG/#added_14","text":"configActionBar extension function for AppCompatActivity . homeAsUp extension read/write property for ActionBar .","title":"Added"},{"location":"CHANGELOG/#changed_13","text":"ActionBar.showTitle now supports reading current value. ActionBar.showHome now supports reading current value. ActionBar.useLogo now supports reading current value. ActionBar.showCustomView now supports reading current value.","title":"Changed"},{"location":"CHANGELOG/#deprecated_5","text":"ActionBar.showHomeAsUp has been deprecated and must be replaced by homeAsUp . It will be removed in a future release.","title":"Deprecated"},{"location":"CHANGELOG/#views-coroutines-views-coroutines-material","text":"","title":"Views Coroutines &amp; Views Coroutines Material"},{"location":"CHANGELOG/#bug-fixes","text":"Fix a very rare crash that would occur when performing two clicks or long clicks in a row (e.g. by calling performClick twice without a UI thread dispatch) when using View.awaitOneClick() , View.awaitOneLongClick() or FloatingActionButton.showAndAwaitOneClickThenHide() .","title":"Bug fixes"},{"location":"CHANGELOG/#views-dsl_1","text":"","title":"Views DSL"},{"location":"CHANGELOG/#added_15","text":"UiPreView is now included by default, the extra \"Views DSL IDE Preview\" module is no longer needed. If you never use it in your production code, R8 should remove it from your release app. This has been done to simplify setup. The isInPreview extension properties for Ui and View allow you to condition content to show based on whether it's the actual app or the IDE preview. Note that it statically evaluates to false in release builds (unlike View.isInEditmode ), so the compiler will remove any code placed in the branch of an if (isInPreview) condition, and will allow R8 to remove any code that was only used in IDE preview. There's 2 new overloads of the ViewGroup.add extension functions that take either a beforeChild or an afterChild parameter. You must use the parameter name to call one of these overloads. It comes handy in ViewGroup s where the order of the child View s matters (e.g. FrameLayout and LinearLayout ). space to create an android.widget.Space from a Ui , a View or a Context reference. Thanks to @Miha-x64 for the contribution!","title":"Added"},{"location":"CHANGELOG/#changed_14","text":"UiPreView now shows known error cases in the preview itself with a red warning triangle icon.","title":"Changed"},{"location":"CHANGELOG/#views-dsl-constraintlayout","text":"","title":"Views DSL ConstraintLayout"},{"location":"CHANGELOG/#added_16","text":"Add new extensions: above , below , before and after for ConstraintLayout.LayoutParams .","title":"Added"},{"location":"CHANGELOG/#views-dsl-material_1","text":"","title":"Views DSL Material"},{"location":"CHANGELOG/#added_17","text":"Add slider , rangeSlider and shapeableImageView extensions for View , Ui and Context . They can instantiate the new widgets from the version 1.2.0 of the material-components-android library.","title":"Added"},{"location":"CHANGELOG/#views-dsl-ide-preview","text":"This module has been deprecated. It will no longer published in future releases. Its content has been moved to the main \"Views DSL\" split.","title":"Views DSL IDE preview"},{"location":"CHANGELOG/#version-300-alpha06-2019-05-03","text":"Compiled with Kotlin 1.3.31.","title":"Version 3.0.0-alpha06 (2019-05-03)"},{"location":"CHANGELOG/#permissions_1","text":"Handle empty grantResults for permission request ( #191 ).","title":"Permissions"},{"location":"CHANGELOG/#version-300-alpha05-2019-04-29","text":"Compiled with Kotlin 1.3.31. This release introduces 3 new splits: Alert Dialog AppCompat Coroutines Permissions Views Coroutines Material The most important change though, is how simpler integrating Splitties in your Android projects has become starting from this release, thanks to the new grouping artifacts. See their content and their maven coordinates in the dedicated part of the README . There is also new features and changes in existing splits, as detailed below.","title":"Version 3.0.0-alpha05 (2019-04-29)"},{"location":"CHANGELOG/#alert-dialog-alert-dialog-appcompat","text":"The alert functions have been deprecated in favor of a more accurate naming: alertDialog . These alertDialog functions are now usable on Context (vs previously only on Activity ), and they have optional parameters to specify the title, the message and even an icon (using a resource id or a Drawable . Also, the title and the message properties are now nullable, in respect to their accepted value.","title":"Alert Dialog &amp; Alert Dialog AppCompat"},{"location":"CHANGELOG/#fragments","text":"The show and showAsync extension functions allow you to show a DialogFragment without fearing the infamous IllegalStateException if the state has already been saved, because it will wait for the lifecycle to be in the RESUMED state before showing the DialogFragment . These 2 extension functions are defined for FragmentManager , FragmentActivity and Fragment . show is a suspending function that resumes after the lifecycle was resumed and the DialogFragment was shown. showAsync is when you are outside of a coroutine but it is marked as experimental because it has \"async\" in its name while not returning a Deferred . Feel free to suggest a better name in the issues or in the #splitties channel of Kotlin's Slack.","title":"Fragments"},{"location":"CHANGELOG/#lifecycle-coroutines_4","text":"New suspending inline extensions functions for Lifecycle have been added for convenience: awaitResumed , awaitStarted & awaitCreated . They can replace code like awaitState(Lifecycle.State.RESUMED) for improved readability.","title":"Lifecycle Coroutines"},{"location":"CHANGELOG/#material-lists_1","text":"A new IconTwoLinesCheckBoxListItem class has been added. What it does is self-explanatory. Also, all the list items are now fully xml friendly.","title":"Material Lists"},{"location":"CHANGELOG/#resources_4","text":"The colorSL and appColorSL extension functions no longer return the nullable version of ColorStateList .","title":"Resources"},{"location":"CHANGELOG/#views-dsl-constraintlayout_1","text":"All the ConstraintLayout.LayoutParams extension functions now have overloads that allow specifying the margin. For example, the following code: centerHorizontally () horizontalMargin = dip ( 16 ) can now be written on one line: centerHorizontally(margin = dip(16)) . That improves readability as the word \"horizontal\" is no longer repeated, and it is still explicit.","title":"Views DSL ConstraintLayout"},{"location":"CHANGELOG/#views-material","text":"Two set-only extensions properties have been added for MaterialButton : iconResource and iconTintAndTextColor .","title":"Views Material"},{"location":"CHANGELOG/#version-300-alpha04-2019-03-03","text":"Compiled with Kotlin 1.3.21.","title":"Version 3.0.0-alpha04 (2019-03-03)"},{"location":"CHANGELOG/#new-features","text":"The wrapContent and matchParent extensions for ViewGroup now apply for View too. Add wrapInScrollView and wrapInHorizontalScrollView extension functions for View . Add experimental multiplatform support with initial Kotlin/JS support for the Bit Flags and Collections splits.","title":"New features"},{"location":"CHANGELOG/#changes","text":"Rename LifecycleOwner.coroutineScope to lifecycleScope . This change is binary compatible. Make wrapInRecyclerView lambda inline. This change is not binary compatible.","title":"Changes"},{"location":"CHANGELOG/#fixes_1","text":"Remove contract in the Intents split that would cause compilation to fail when used.","title":"Fixes"},{"location":"CHANGELOG/#version-300-alpha03-2019-02-05","text":"Compiled with Kotlin 1.3.20. This release introduces a new split: Views Coroutines .","title":"Version 3.0.0-alpha03 (2019-02-05)"},{"location":"CHANGELOG/#new-features_1","text":"Added radioGroup { ... } functions in Views DSL. Added first class support for ConstraintLayout barriers, guidelines and groups. New styledView function for use when making an API for xml styles usage in Kotlin. See an example in AppCompatStyles . The MaterialComponentsStyles class brings access to all the xml styles defined in Google's Material Components library for Android in a typesafe way. Add materialCardView { ... } functions in Views DSL Material. Add navigationView { ... } functions in Views DSL Material. Make EditText inputType typesafe with the set only type extension property and the InputType inline class. Views DSL IDE Preview now supports CoroutineContext and CoroutineScope as constructor parameters for Ui subclasses. Added contracts for all the lParams functions from Views DSL and variants. Also added to the roomDb function from Arch Room as well as the verticalListLayoutParams and horizontalListLayoutParams functions from Views DSL RecyclerView. Add support for unsigned numbers in Bit Flags (i.e. UByte , UShort , UInt and ULong ).","title":"New features"},{"location":"CHANGELOG/#changes_1","text":"When using the button function from Views DSL, MaterialButton is now automatically used in place of AppCompatButton if you also use Views DSL Material. Make mainHandler async by default to avoid vSync delays. It is used for Dispatchers.MainAndroid , so it will result in speed improvements when using Lifecycle Coroutines. If you really need sync behavior, you can use the new mainHandlerSync top level property instead. Make Dispatchers.MainAndroid of type MainCoroutineDispatcher so the immediate property is available. Make the awaitState function from Lifecycle Coroutines safe to use off the main thread, and document it. Call validate() from the lParams { ... } function for ConstraintLayout . Make xml styles related classes inline again (thanks to compiler bug fixed in Kotlin 1.3.20). The reified generic variant of view from Views DSL is now an internal API. ViewFactory and related symbols are now an internal API. Mark some SystemServices as nullable to be instant app tolerant. That includes WallpaperManager , WifiManager , WifiP2pManager , UsbManager , DevicePolicyManager , FingerprintManager , ShortcutManager and WifiAwareManager . The Views DSL IDE Preview documentation now states that running the compileDebugKotlin gradle task is enough to update the preview. This is faster than a full build.","title":"Changes"},{"location":"CHANGELOG/#fixes_2","text":"Make viewFactory from Views DSL internal API compatible with IDE Preview.","title":"Fixes"},{"location":"CHANGELOG/#deprecation","text":"The illegal top level function from Exceptions has been deprecated in favor of error from Kotlin stdlib.","title":"Deprecation"},{"location":"CHANGELOG/#new-artifact","text":"This release has the following new artifact: \"com.louiscad.splitties:splitties-views-coroutines:3.0.0-alpha03\"","title":"New artifact"},{"location":"CHANGELOG/#version-300-alpha02-2019-01-06","text":"This release introduces a new split: Lifecycle Coroutines .","title":"Version 3.0.0-alpha02 (2019-01-06)"},{"location":"CHANGELOG/#new-artifact_1","text":"This release has the following new artifact: \"com.louiscad.splitties:splitties-lifecycle-coroutines:3.0.0-alpha02\"","title":"New artifact"},{"location":"CHANGELOG/#version-300-alpha01-2018-12-21","text":"This release is compiled with Kotlin 1.3.11. It is a breaking release (more details in the changes section), and the API is subject to changes as it is back to an alpha stage. APIs that are likely to change have an experimental annotation that triggers a warning (which can be removed by opt-in), to prevent you from using them unintentionally.","title":"Version 3.0.0-alpha01 (2018-12-21)"},{"location":"CHANGELOG/#migration-to-androidx","text":"All the old support library artifacts have been replaced by AndroidX ones. If your project has not migrated to AndroidX yet, please follow the quick steps below. Migrating your project to AndroidX in a `fun` way. (Click to expand) Theoretically, migrating a project to AndroidX is easy: you just select \"Migrate to AndroidX\" from the \"Refactor\" menu. Unfortunately, in addition to being unacceptably slow, it didn't work properly for Splitties (except for a past attempt which had to be abandoned for API stability reasons). _Our experience was waiting minutes with an unresponsive IDE, then giving up with no other choice than force closing Android Studio, and finally getting a broken project, with some dangling fully qualified references (instead of proper import replacement). We reverted and looked for an alternative that would work properly, and perform faster._ The solution has been a Kotlin script that is a white box, and runs in a matter of seconds. You can use it for your project too, so you can migrate to AndroidX quickly, and in a `fun` way. It is available [here](https://github.com/LouisCAD/Splitties/tree/main/scripts/AndroidX-migrator.kts), and depends on [this csv file](https://github.com/LouisCAD/Splitties/tree/main/scripts/androidx-class-mapping.csv). _Note that this script doesn't migrate the dependencies, because we changed the way we define dependencies (using constants defined in `buildSrc`), and it would have been harder to handle all the edge cases, and doing it by hand with Replace in Path from IDE was quick enough for us. If you prefer to have it, you are free to contribute and reach out in the issues or elsewhere._ To use it in your project, follow these simple steps: 1. Replace the support libraries dependencies by AndroidX dependencies (and update Splitties ones if you already used it). 2. Copy paste the two files linked above at the root of the gradle project. 3. Edit the `expectedNumberOfModules` property defined in the `AndroidX-migrator.gradle.kts` file to match the number of modules that your project has. 4. Make sure you have `kotlinc` 1.3+ available (see [easy installation in official docs here]( https://kotlinlang.org/docs/tutorials/command-line.html )). 5. Open a terminal at the root of the gradle project. 6. Run `kotlinc -script AndroidX-migrator.gradle.kts` and wait for completion. 7. Sync gradle project. 8. Build the project to ensure everything has migrated properly, or fix and try again.","title":"Migration to AndroidX"},{"location":"CHANGELOG/#improved-api-to-use-xml-styles-defined-in-android-or-appcompat","text":"Now, you pass the Context only once to the AndroidStyles or AppCompatStyles constructor, and you no longer have to pass it to the subsequent functions call. It is advised to obviously cache this instance to reduce boilerplate and avoid overhead. This is a breaking change.","title":"Improved API to use xml styles defined in Android or AppCompat"},{"location":"CHANGELOG/#package-name-changes-and-replaced-artifacts","text":"The design support library no longer exists in AndroidX. It is replaced by several AndroidX artifacts and the Google Material Components library. Consequently, the package names no longer reference \"design\" but \"coordinatorlayout\" and \"material\" instead. As you can see below, the design support library dependent artifacts have been replaced. Note that Views DSL Material has a transitive dependency to Views DSL CoordinatorLayout, so you don't need to add an explicit dependency for the latter if you already use the former.","title":"Package name changes and replaced artifacts"},{"location":"CHANGELOG/#new-artifacts","text":"This release has the following new artifacts: \"com.louiscad.splitties:splitties-views-material:3.0.0-alpha01\" \"com.louiscad.splitties:splitties-views-dsl-coordinatorlayout:3.0.0-alpha01\" \"com.louiscad.splitties:splitties-views-dsl-material:3.0.0-alpha01\"","title":"New artifacts"},{"location":"CHANGELOG/#removed-artifacts","text":"This release removes these two artifacts: \"com.louiscad.splitties:splitties-views-design-styles:2.1.1\" \"com.louiscad.splitties:splitties-views-dsl-design-styles:2.1.1\"","title":"Removed artifacts"},{"location":"CHANGELOG/#version-211-2018-11-25","text":"This release is compiled with Kotlin 1.3.10.","title":"Version 2.1.1 (2018-11-25)"},{"location":"CHANGELOG/#changes_2","text":"Enforce read-only in the withExtras extension function for Activity . Any attempt to mutate a property inside it will result in an IllegalStateException to be thrown, because this should be done in putExtras instead. You can see more info in the updated KDoc of these functions. Add a withExtras extension function for Intent (previously only available for Activity ). Add a putExtras extension function for Activity (previously only available for Intent ). Fix nullability warning in FragmentArgDelegate. Add KDoc to all public symbols from the Activities split. Add KDoc to all public symbols from the AlertDialog split. Add KDoc to all public symbols from the AlertDialog AppCompat split.","title":"Changes"},{"location":"CHANGELOG/#version-210-2018-11-13","text":"This release targets Android SDK 28, and splits depending on support libraries use version 28.0.0.","title":"Version 2.1.0 (2018-11-13)"},{"location":"CHANGELOG/#changes_3","text":"System Services from API 28 are now included into the same named split. Update ConfigChangesHandlingCollapsingToolbarLayout from View DSL Design to be compatible with design support library version 28.0.0. Update for nullability warnings brought by SDK 28.","title":"Changes"},{"location":"CHANGELOG/#version-200-2018-11-13","text":"This release targets Android SDK 27, and splits depending on support libraries use version 27.1.1.","title":"Version 2.0.0 (2018-11-13)"},{"location":"CHANGELOG/#changes_4","text":"Room updated to version 1.1.1 in Arch Room. Lambdas of onCreate and onOpen functions in Arch Room are now crossinline . The LifecycleObserver class is now marked as experimental.","title":"Changes"},{"location":"CHANGELOG/#version-200-beta1-2018-11-13","text":"This release breaks binary and source compatibility .","title":"Version 2.0.0-beta1 (2018-11-13)"},{"location":"CHANGELOG/#kotlin-130","text":"This is not just a compiler update for Splitties. This release already takes advantage of Kotlin 1.3 features, beyond stable coroutines: The XmlStyle class from Views DSL is now inline, for minimal footprint at runtime. SuspendPrefsAccessor from Preferences is no longer experimental as coroutines graduated. Functions that take a lambda in Views DSL (except lParams functions) have a contract. This directly translates to more freedom in your UI code as you can initialize a property later. withExtras , putExtras and with from Bundle have a contract. This allows to initialize local variables from contents of a Bundle passing through a BundleSpec naturally! Symbols that could change are marked as experimental, for less surprises in the future when they are replaced, renamed or removed (still with a deprecation cycle whenever possible). Only verticalListLayoutParams and horizontalListLayoutParams extension functions for RecyclerView.LayoutManager are experimental for now, but this could change, especially in alpha, or beta stage.","title":"Kotlin 1.3.0"},{"location":"CHANGELOG/#version-200-alpha9-2018-11-13","text":"This release breaks binary and source compatibility . It renames several package names and modules, for more consistency across the project. View DSL has a new name: Views DSL. That also applies to its additional modules. Just like an extra s can make a new generation of smartphones, it can also make a new version of Splitties. The artifact names of all Selectable Views and View DSL changed, and so did the package names. Consequently, after updating the artifact names and the version, you'll need to update the imports. Fortunately, this is easily done with the \"Replace in Path\" IDE option present in IntelliJ IDEA and Android Studio. All you need to do is find an old import ( import splitties.viewdsl. ), select it, select the \"Replace in Path\" option paste ( import splitties.views.dsl. ) in the second input field, and validate. Then, you just have to do the same for Selectable Views with import splitties.selectableviews. and import splitties.views.selectable. \u2026 and voil\u00e0! You just migrated to latest Splitties version!","title":"Version 2.0.0-alpha9 (2018-11-13)"},{"location":"CHANGELOG/#new-artifacts_1","text":"Here are all the artifacts added in this version. Just use the ones you need. (Click to expand) implementation ( \"com.louiscad.splitties:splitties-views-dsl:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-views-dsl-appcompat:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-views-dsl-constraintlayout:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-views-dsl-design:$splitties_version\" ) debugImplementation ( \"com.louiscad.splitties:splitties-views-dsl-ide-preview:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-views-dsl-recyclerview:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-views-selectable:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-views-selectable-appcompat:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-views-selectable-constraintlayout:$splitties_version\" ) All the lines above assume you defined the `splitties_version` ext property in your root project's `build.gradle` file to `2.0.0-alpha9` as shown in this snippet: allProjects { ext { splitties_version = '2.0.0-alpha9' } }","title":"New artifacts"},{"location":"CHANGELOG/#removed-artifacts_1","text":"This release removes all these artifacts: implementation(\"com.louiscad.splitties:splitties-selectableviews:$splitties_version\") implementation(\"com.louiscad.splitties:splitties-selectableviews-appcompat:$splitties_version\") implementation(\"com.louiscad.splitties:splitties-selectableviews-constraintlayout:$splitties_version\") implementation(\"com.louiscad.splitties:splitties-viewdsl:$splitties_version\") implementation(\"com.louiscad.splitties:splitties-viewdsl-appcompat:$splitties_version\") implementation(\"com.louiscad.splitties:splitties-viewdsl-constraintlayout:$splitties_version\") implementation(\"com.louiscad.splitties:splitties-viewdsl-design:$splitties_version\") debugImplementation(\"com.louiscad.splitties:splitties-viewdsl-ide-preview:$splitties_version\") implementation(\"com.louiscad.splitties:splitties-viewdsl-recyclerview:$splitties_version\")","title":"Removed artifacts"},{"location":"CHANGELOG/#version-200-alpha8-2018-11-12","text":"This release breaks binary compatibility . It removes all deprecated symbols that had their deprecation level raised to error in 2.0.0-alpha7. Make sure you don't rely on any library that uses an old version of a Splitties artifact that relies on these previously deprecated and now removed symbols, or your app is likely not build, or to crash at runtime because of not found classes.","title":"Version 2.0.0-alpha8 (2018-11-12)"},{"location":"CHANGELOG/#version-200-alpha7-2018-11-12","text":"Raise all deprecated symbols deprecation level to error. Use this version to make sure you don't use them in your projects, next version will remove them!","title":"Version 2.0.0-alpha7 (2018-11-12)"},{"location":"CHANGELOG/#version-200-alpha6-2018-11-11","text":"Version 2.0.0-alpha5 broke the API, this version fixes this.","title":"Version 2.0.0-alpha6 (2018-11-11)"},{"location":"CHANGELOG/#like-version-200-alpha5-but-without-breaking-the-api-from-200-alpha4","text":"This release is mostly the same as 2.0.0-alpha5, but also has 2 very important things: - binary compatibility (minor change in Preferences experimental API excluded) - source compatibility, except an overload resolution ambiguity in View DSL, see the migration guide for a smooth migration.","title":"Like version 2.0.0-alpha5, but without breaking the API from 2.0.0-alpha4"},{"location":"CHANGELOG/#removed-splits-and-versions-sync","text":"Version 2.0.0-alpha5 technically removed 2 splits (one was actually a renaming, the other one a merging). Consequently, you have to make sure your dependencies no longer reference these removed artifacts. Easily done. Problems arise when you depend on libraries that themselves depend on Splitties, which may be older versions. These libraries may bring transitive dependencies to old modules that will clash with ones from newer versions, and the versions they rely on may also mismatch with the ones you need, and these older versions will take precedence if they are in library modules of your project that don't depend explicitly on a newer version. Fortunately, Gradle dependency resolution strategy allows to easily fix these issues all over your project. All you need to do is to make sure you have the following snippet into your root project's build.gradle file: allprojects { ext { splitties_version = '2.0.0-alpha6' } configurations . all { resolutionStrategy . eachDependency { DependencyResolveDetails details -> def req = details . requested if ( req . group != \"com.louiscad.splitties\" ) return if ( req . name == \"splitties-uithread\" ) { details . useTarget ( group: req . group , name: \"splitties-mainthread\" , version: splitties_version ) details . because ( \"Splitties uithread has been renamed to mainthread\" ) } else if ( req . name == \"splitties-viewdsl-appcompat-styles\" ) { details . useTarget ( group: req . group , name: \"splitties-viewdsl-appcompat\" , version: splitties_version ) details . because ( \"[Splitties] Split merged and removed\" ) } else { details . useTarget ( group: req . group , name: req . name , version: splitties_version ) details . because ( \"Transitive dependencies could take precedence otherwise\" ) } } } } The snippet above, for all sub-projects (aka. modules): 1. defines Splitties version in an ext property so it can be used in all build.gradle files. 2. sets a resolution strategy for all configurations (like implementation or api ) which: 1. redirects any usage of the old splitties-mainthread artifact to the new splitties-mainthread one. 2. redirects any usage of the old splitties-viewdsl-appcompat-styles artifact to the one it has been merged into: splitties-viewdsl-appcompat . 3. makes sure all splitties artifacts versions are in sync, across all sub-projects. If you don't do this but have a library using an old artifact in your dependencies, you'll encounter gradle sync issues, or runtime issues, and the real cause may not appear clearly (because of bugs in tooling).","title":"Removed splits and versions sync"},{"location":"CHANGELOG/#changes-per-module","text":"","title":"Changes per module"},{"location":"CHANGELOG/#checked-lazy","text":"uiLazy has been deprecated in favor of mainThreadLazy .","title":"Checked Lazy"},{"location":"CHANGELOG/#view-dsl-recyclerview","text":"The wrapInRecyclerView extension function now accepts an optional lambda to configure the wrapping RecyclerView easily.","title":"View DSL RecyclerView"},{"location":"CHANGELOG/#version-200-alpha5-2018-11-02","text":"This release is breaking if you come from version 2.0.0-alpha4, especially if you were using View DSL. It's highly recommended to directly migrate from version 2.0.0-alpha4 to 2.0.0-alpha6, which has a smoother migration path, and a guide to do so.","title":"Version 2.0.0-alpha5 (2018-11-02)"},{"location":"CHANGELOG/#project-wide-changes","text":"Add consumer proguard rules for splits with optional dependencies. Update to Kotlin 1.2.71 Update kotlinx.coroutines to version 0.30.2","title":"Project wide changes"},{"location":"CHANGELOG/#changes-per-module_1","text":"","title":"Changes per module"},{"location":"CHANGELOG/#collections_1","text":"Add allocation-free reverse List forEach extensions: forEachReversedByIndex and forEachReversedWithIndex .","title":"Collections"},{"location":"CHANGELOG/#intents","text":"Add toPendingActivities() extension function for Array<Intent> .","title":"Intents"},{"location":"CHANGELOG/#material-lists_2","text":"The following previously deprecated classes have been removed: SingleLineIconListItem (use IconOneLineListItem instead) TwoLinesIconListItem (use IconTwoLinesListItem instead) TwoLinesIconSwitchListItem (use IconTwoLinesSwitchListItem instead) All the xml files (except view_ids.xml ) have been removed.","title":"Material Lists"},{"location":"CHANGELOG/#preferences_3","text":"","title":"Preferences"},{"location":"CHANGELOG/#enhancements","text":"The preferences are now loaded in Dispatchers.IO when using SuspendPrefsAccessor . Fix clash with private property name and non imported extension for Preferences. (#96).","title":"Enhancements"},{"location":"CHANGELOG/#breaking-changes-in-experimental-api","text":"The SuspendPrefsAccessor constructor parameter of type CoroutineDispatcher has been removed now that Dispatchers.IO is always used. If you didn't specify a custom dispatcher, you don't need to do anything.","title":"Breaking changes (in experimental API)"},{"location":"CHANGELOG/#selectable-views-all-variants","text":"All the final methods have been opened up, and now have the @CallSuper annotation instead. This makes the classes more useful to develop custom views, like the extended Floating Action Button with SelectableConstraintLayout where you need to clip the view in onDraw(\u2026) . The dispatchDrawableHotspotChanged overridden method in the classes of the Selectable Views splits family was annotated with @TargetApi , but is not correctly annotated with @RequiresApi . This likely caused no issue as you usually don't call this method directly but let Android do, but now, it's fixed!","title":"Selectable Views (all variants)"},{"location":"CHANGELOG/#ui-thread-main-thread","text":"The UI Thread split has been renamed to Main thread (for the same reasons kotlinx.coroutines replaced UI by Dispatchers.Main ). While the artifact has been changed , the old symbols have only been deprecated in favor of new ones defined in new package, with new names ( ui -> main ). If you use a library that depends on the old artifact, see \"Removed splits and versions sync\" in version 2.0.0-alpha6 release notes.","title":"~UI Thread~ -&gt; Main Thread"},{"location":"CHANGELOG/#view-dsl-and-additional-modules","text":"The API of View DSL (and its additional modules) has been improved, and there's some new features, along with some deprecations. However, this release (2.0.0-alpha5) is breaking when updating from previous versions. This has been fixed in 2.0.0-alpha6, so please skip this release if you are upgrading , and follow thoroughly the migration guide . Regardless, there has been improvements in View DSL additional modules. Please, review them below.","title":"View DSL (and additional modules)"},{"location":"CHANGELOG/#view-dsl-appcompat-styles-view-dsl-appcompat","text":"The View DSL AppCompat Styles split has been merged into View DSL AppCompat. If you use a library that depends on the old artifact, see \"Removed splits and versions sync\" in version 2.0.0-alpha6 release notes.","title":"~View DSL AppCompat Styles~ -&gt; View DSL AppCompat"},{"location":"CHANGELOG/#view-dsl-constraintlayout","text":"Probably the best change in this split is that now, you no longer need to specify any View id. If there's none and you add a constraint using extension functions from this split, an id that can't clash with aapt/xml ids will be generated and assigned to the view so constraints work. Keep in mind you may still want to use stable ids defined in xml or elsewhere in cases where you use views that need to have their state saved, like a RecyclerView , an EditText or a CheckBox . Added support for chains with the two horizontalChain and verticalChain new extension functions for ConstraintLayout . Also added horizontalMargin and verticalMargin extension properties for List<View> that are designed for use in a ConstraintLayout when you made a chain with the two new methods that take a list of views.","title":"View DSL ConstraintLayout"},{"location":"CHANGELOG/#view-dsl-design","text":"When instantiating an AppBarLayout or a CollapsingToolbarLayout with the new appBarLayout and collapsingToolbarLayout functions, you'll automatically get instances that have known bugs in the design support library fixed, including config changes handling (supports rotation or layout changes without recreating the Activity).","title":"View DSL Design"},{"location":"CHANGELOG/#view-dsl-recyclerview_1","text":"The setSingleView extension function for RecyclerView has been deprecated. Use the wrapInRecyclerView extension function for View instead, it is simpler to use and supports horizontal scrolling.","title":"View DSL RecyclerView"},{"location":"CHANGELOG/#views_1","text":"Deprecated View visibility extension properties and functions in favor of Android KTX ones. Added lines write only extension property for TextView . Change the signature of the lambda of the onClick extension function for View . It no longer passes the clicked view . This is to avoid it shadowing when you nest lambdas, and has been done because this parameter is almost never used. Add 1 extension function, 1 extension property and 1 top level function, related to View id generation: View.assignAndGetGeneratedId() , View.existingOrNewId and generateViewId() .","title":"Views"},{"location":"CHANGELOG/#upcoming-apis-preview-in-the-sample","text":"The sample of Splitties is a place where you can preview several extensions or other work that can be integrated into Splitties as a library later. In addition to what was already present in the sample, there has been an important addition: An example of how to request a dangerous permission with a single suspend call, plus a try/catch to handle user deny.","title":"Upcoming APIs preview in the sample"},{"location":"CHANGELOG/#new-artifact_2","text":"This release has a new artifact: implementation ( \"com.louiscad.splitties:splitties-mainthread:$splitties_version\" )","title":"New artifact"},{"location":"CHANGELOG/#removed-artifacts_2","text":"This release removes these two artifacts: implementation(\"com.louiscad.splitties:splitties-uithread:$splitties_version\") implementation(\"com.louiscad.splitties:splitties-viewdsl-appcompat-styles:$splitties_version\")","title":"Removed artifacts"},{"location":"CHANGELOG/#version-200-alpha4-2018-07-09","text":"Provide ReplaceWith migrations for add methods deprecated in version 2.0.0-alpha2. Add default empty lambda for startActivity(action: String\u2026) methods. Compiled with Kotlin 1.2.51","title":"Version 2.0.0-alpha4 (2018-07-09)"},{"location":"CHANGELOG/#version-200-alpha3-2018-06-09","text":"","title":"Version 2.0.0-alpha3 (2018-06-09)"},{"location":"CHANGELOG/#new-features_2","text":"","title":"New features"},{"location":"CHANGELOG/#bundle","text":"There are 2 new methods: bundleOrDefault(\u2026) and bundleOrElse { \u2026 } to allow default values in BundleSpec delegated properties.","title":"Bundle"},{"location":"CHANGELOG/#fragment-args","text":"Like for BundleSpec , there are 2 new methods: argOrDefault(\u2026) and argOrElse { \u2026 } to allow default values in Fragment delegated argument properties.","title":"Fragment Args"},{"location":"CHANGELOG/#breaking-changes","text":"","title":"Breaking changes"},{"location":"CHANGELOG/#bundle_1","text":"The delegates previously returned by bundle() and bundleOrNull() are no longer part of the public API and have been replaced by the ReadWriteProperty interface.","title":"Bundle"},{"location":"CHANGELOG/#fragment-args_1","text":"The arg() and argOrNull() functions have moved out of the support subpackage as there's no longer any ambiguity since platform Fragments are deprecated and going away. Auto-import should import the versions from the new package for you. The delegates previously returned by arg() and argOrNull() are no longer part of the public API and have been replaced by the ReadWriteProperty interface.","title":"Fragment Args"},{"location":"CHANGELOG/#version-200-alpha2-2018-05-21","text":"","title":"Version 2.0.0-alpha2 (2018-05-21)"},{"location":"CHANGELOG/#9-new-library-modules-amounting-to-a-total-of-42-splits","text":"Activities : Start activities with minimal boilerplate Collections : forEach for List s without Iterator allocation Fragments : Start activities from fragments and do transactions with minimal boilerplate Intents : Transform companion object s into powerful typesafe intent specs Material Colors : 2014 Material Design color palettes as color resources View DSL RecyclerView : RecyclerView extension of View DSL Views CardView : CardView extension of Views. Provides a contentPadding property View Design : Design Support library extension of Views Views RecyclerView : RecyclerView extension of Views","title":"9 new library modules (amounting to a total of 42 splits):"},{"location":"CHANGELOG/#other-changes","text":"","title":"Other changes:"},{"location":"CHANGELOG/#appctx","text":"The consume { \u2026 } utility function from the splitties.init package has been deprecated. Replace it with true.also { _ -> \u2026 } or false.also { _ -> \u2026 } .","title":"AppCtx"},{"location":"CHANGELOG/#arch-lifecycle_1","text":"New mapNotNull , switchMap and switchMapNotNull extension functions for LiveData . activityScope and fragmentScope extension functions to get a ViewModel now accept an optional lambda (which creates a ViewModelProvider under the hood. This allows to pass arguments to your ViewModel when it's first created. observe and observeNotNull now return the created Observer so it can be unregistered manually later if needed.","title":"Arch Lifecycle"},{"location":"CHANGELOG/#arch-room_1","text":"The new inTransaction { \u2026 } extension function for RoomDatabase s does the same as transaction { \u2026 } but also returns the value of the last expression of the lambda. New onCreate { \u2026 } and onOpen { \u2026 } extension functions for RoomDatabase.Builder .","title":"Arch Room"},{"location":"CHANGELOG/#bundle_2","text":"BundleHelper has been renamed to BundleSpec , but a typealias keeps the source compatibility. However, there's no binary compatibility, which means you'll need to recompile any library using it. BundleSpec and the methods relying on it can now be used safely on any thread!","title":"Bundle"},{"location":"CHANGELOG/#material-lists_3","text":"Allow disabling default icon tint on list items with optional constructor parameter.","title":"Material Lists"},{"location":"CHANGELOG/#preferences_4","text":"A new experimental SuspendPrefsAccessor for coroutines users allows you to ensure you can't load the preferences (which does I/O) on the UI thread.","title":"Preferences"},{"location":"CHANGELOG/#resources_5","text":"The str extension functions formatArgs now accept null arguments.","title":"Resources"},{"location":"CHANGELOG/#view-dsl","text":"The higher order function add has been deprecated because it went in the way of promoting a view to a property easily.","title":"View DSL"},{"location":"CHANGELOG/#view-dsl-appcompat-styles","text":"Added flatButton , imgActionButton and largeProgressBar .","title":"View DSL AppCompat styles"},{"location":"CHANGELOG/#view-dsl-constraintlayout_1","text":"Add baselineToBaselineOf(\u2026) extension function for ConstraintLayout.LayoutParams .","title":"View DSL ConstraintLayout"},{"location":"CHANGELOG/#view-dsl-ide-preview","text":"UiPreView injects a valid value into appCtx so your Ui s can depend on it (probably indirectly) without breaking preview!","title":"View DSL IDE Preview"},{"location":"CHANGELOG/#views_2","text":"New Gravity flags aliases (e.g. gravityStartCenter instead of Gravity.START or Gravity.CENTER_VERTICAL ). Change case of imageBitMap to imageBitmap to make it more consistent with the class name Bitmap","title":"Views"},{"location":"CHANGELOG/#views-appcompat_2","text":"tooltipTxt now accepts null to remove any tooltip previously set on the view.","title":"Views AppCompat"},{"location":"CHANGELOG/#new-artifacts_2","text":"Here are all the artifacts added in this version. Just use the ones you need. (Click to expand) implementation ( \"com.louiscad.splitties:splitties-activities:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-collections:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-fragments:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-intents:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-material-colors:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-viewdsl-recyclerview:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-views-cardview:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-views-design:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-views-recyclerview:$splitties_version\" ) All the lines above assume you defined the `splitties_version` ext property in your root project's `build.gradle` file to `2.0.0-alpha2` as shown in this snippet: allProjects { ext { splitties_version = '2.0.0-alpha2' } }","title":"New artifacts"},{"location":"CHANGELOG/#version-200-alpha1-2018-03-11","text":"","title":"Version 2.0.0-alpha1 (2018-03-11)"},{"location":"CHANGELOG/#26-new-library-modules-amounting-to-a-total-of-33-splits","text":"Alert Dialog : Create simple alert dialogs with simple code Alert Dialog AppCompat : AppCompat version of Alert Dialog Arch Lifecycle : Extensions to get ViewModel s, use LiveData and observe Lifecycle s Arch Room : Room helpers to instantiate your DB and perform transactions in Kotlin Bit Flags : hasFlag , withFlag and minusFlag extensions on Long , Int , Short and Byte Bundle : BundleHelper to use Bundle with property syntax for Intent extras and more Dimensions : Android dp extensions for View and Context . Particularly handy when using View DSL Exceptions : illegal(\u2026) and similar functions that return Nothing , handy for impossible or illegal when branches Fragment Args : Fragment arguments without ceremony thanks to delegated properties Init Provider : Base class for ContentProvider s used for automatic initialization purposes Main Handler : Top-level mainHandler property to stop allocating multiple Handler s for main Looper Resources : Extensions to get resources like strings, colors or drawables easily, with support for themed attributes Selectable Views AppCompat : Selectable Views for AppCompatTextView Selectable Views ConstraintLayout : Selectable Views for ConstraintLayout Snackbar : Grab a snack without ceremony with snack(\u2026) and longSnack(\u2026) System Services : No more context.getSystemService(NAME_OF_SERVICE) as NameOfManager Toast : Show a toast by just calling toast(yourText) , and dodge API 25 BadTokenException UI Thread : Properties related to Android UI thread, and checkUiThread() precondition checker View DSL : Create UIs with readable Kotlin code View DSL AppCompat : AppCompat extension of View DSL View DSL AppCompat styles : AppCompat styles for View DSL View DSL ConstraintLayout : ConstraintLayout extension of View DSL View DSL Design : Design Support Library extension of View DSL View DSL IDE preview : Preview View DSL UIs in the IDE Views : Extensions function and properties on View s Views AppCompat : AppCompat extension of Views. Includes helpers for ImageView tinting, ActionBar and tooltip","title":"26 new library modules (amounting to a total of 33 splits):"},{"location":"CHANGELOG/#1-renamed-module","text":"\"Checked Lazy\" replaces the \"Concurrency\" module.","title":"1 renamed module:"},{"location":"CHANGELOG/#other-changes_1","text":"The groupId of the library changed from xyz.louiscad.splitties to com.louiscad.splitties . Check dependencies list below. All previous modules migrated to Kotlin, excepted the ViewHolder class from the Typesafe RecyclerView module that can't be written in Kotlin at the moment due to hiding super fields not being supported. App Context module has a new, memory leak safe injectAsAppCtx() method, that uses the new canLeakMemory() extension function on Context that is also public. Preferences StringPref and stringPref don't allow null values anymore. Use StringOrNullPref and stringOrNullPref if you need nullable strings. Same for StringSetPref and stringSetPref . The isUiThread property moved from the old \"Concurrency\" module to the \"UI Thread\" module. Material Lists are now written in Kotlin with View DSL, fixing icon tinting support on day/night themes and behavior on long texts. Also, the naming has been improved. Old named items are now deprecated. Checked Lazy does no longer depend on Timber but is now more configurable, allowing to write reporting behavior if needed. Selectable Views has been split in base module (that includes only dependencies on Android platform), AppCompat module and ConstraintLayout module. Selectable Views don't support the foreground xml attribute from app namespace anymore, but there's a new foregroundSelector property.","title":"Other changes:"},{"location":"CHANGELOG/#new-artifacts_3","text":"Here are all the artifacts added in this version. Just use the ones you need. (Click to expand) implementation ( \"com.louiscad.splitties:splitties-alertdialog:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-alertdialog-appcompat:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-appctx:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-arch-lifecycle:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-arch-room:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-bitflags:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-bundle:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-checkedlazy:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-dimensions:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-exceptions:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-initprovider:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-mainhandler:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-material-lists:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-preferences:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-resources:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-fragmentargs:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-selectableviews:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-selectableviews-appcompat:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-selectableviews-constraintlayout:$splitties_version\" ) debugImplementation ( \"com.louiscad.splitties:splitties-stetho-init:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-systemservices:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-toast:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-typesaferecyclerview:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-uithread:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-snackbar:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-viewdsl:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-viewdsl-appcompat:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-viewdsl-appcompat-styles:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-viewdsl-constraintlayout:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-viewdsl-design:$splitties_version\" ) debugImplementation ( \"com.louiscad.splitties:splitties-viewdsl-ide-preview:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-views:$splitties_version\" ) implementation ( \"com.louiscad.splitties:splitties-views-appcompat:$splitties_version\" ) All the lines above assume you defined the `splitties_version` ext property in your root project's `build.gradle` file to `2.0.0-alpha1` as show in this snippet: allProjects { ext { splitties_version = '2.0.0-alpha1' } }","title":"New artifacts"},{"location":"CHANGELOG/#version-130-2017-04-17","text":"","title":"Version 1.3.0 (2017-04-17)"},{"location":"CHANGELOG/#5-new-library-modules","text":"App Context : Have a Context everywhere Concurrency : Single thread lazy implementations, with reporting via Timber support Material Lists : List Items for RecyclerView implementing Material Design Guidelines Preferences : Property syntax for Android's SharedPreferences Stetho init : Have Stetho without writing any code!","title":"5 new library modules:"},{"location":"CHANGELOG/#1-renamed-module_1","text":"Selectable Views replaces Selectable ViewGroups","title":"1 renamed module:"},{"location":"CHANGELOG/#other-changes_2","text":"Selectable Views now has a SelectableTextView . Made to use it on simple, single-line list items. Typesafe RecyclerView now depends on Kotlin Typesafe RecyclerView has a new ItemViewHolder helper class for simple but common use cases.","title":"Other changes:"},{"location":"CHANGELOG/#version-12-2016-09-19","text":"This version adds the setHost(Host host) method in ViewWrapper.Binder interface where Host can be any type you want you can use from the implementing item View to communicate with your Activity, Fragment, Presenter, or whatever. Note this adds a third type parameter to the ViewWrapper class, and a second one for the ViewWrapper.Binder class.","title":"Version 1.2 (2016-09-19)"},{"location":"CHANGELOG/#version-11-2016-09-11","text":"This version adds the setViewHolder(ViewWrapper holder) method in ViewWrapper.Binder interface so list item View s can now get a reference to their ViewHolder , and call getAdapterPosition() on it for example.","title":"Version 1.1 (2016-09-11)"},{"location":"CHANGELOG/#version-10-2016-08-24","text":"This is the first release of Splitties. It includes two independent modules: - Typesafe RecyclerView - Selectable ViewGroups For gradle projects from jcenter() repo: compile 'xyz.louiscad.splitties:selectableviewgroups:1.0' compile 'xyz.louiscad.splitties:typesaferecyclerview:1.0'","title":"Version 1.0 (2016-08-24)"},{"location":"Comparison_with_anko/","text":"How Splitties differs from Anko \u00b6 There's Splitties Views DSL, and there's Anko layouts. There's many splits, and there's Anko commons. Let's see what are the differences and why Splitties was built while Anko already existed under full awareness of the founder of the Splitties project. TL;DR first : Splitties is lighter, more explicit, more flexible and\u2026 more split. Anko layouts: their issues that Splitties Views DSL avoided \u00b6 A subclass for each View you want to use \u00b6 To use a View in an Anko layout, in addition to a function for DSL usage, a subclass of it, specially tailored to work with Anko layouts is needed. Splitties Views DSL does not require such a thing at all. You can just pass the constructor reference to the view function (e.g. view(::MyShinyCustomView) ), and if you want, for your convenience, you can make an \"alias function\" (e.g. myShinyCustomView() ), which can (should) be inline . Consequently, Splitties is lighter, and more flexible. Views added implicitly \u00b6 In DSL fashion, Anko layouts implicitly add any view you create using the DSL to the receiver ViewGroup if any, or set it as a content view if in an Activity . In the real world, you rarely add a View without specifying the LayoutParams , so this implicit behavior only makes it easier to forget specifying the layout params, and realizing it later, possibly losing time in your development process. Splitties never adds a View implicitly. You always have to supply LayoutParams to the add function. That also makes creating a View without adding it at instantiation place straightforward. Anko commons: misc extensions that could be split \u00b6 Anko commons has several extension functions or helpers for Android to avoid some boilerplate. However, you need to have the full dependency even if you use only a few parts in it, which can make your app bigger (before proguard at least). Splitties, from day one was split (that's where its name comes from). You can use only one module with, let's say, Splitties Intents, but not Splitties Fragment Args. This avoids to integrate what you know you don't need, and helps making your app smaller.","title":"How Splitties differs from Anko"},{"location":"Comparison_with_anko/#how-splitties-differs-from-anko","text":"There's Splitties Views DSL, and there's Anko layouts. There's many splits, and there's Anko commons. Let's see what are the differences and why Splitties was built while Anko already existed under full awareness of the founder of the Splitties project. TL;DR first : Splitties is lighter, more explicit, more flexible and\u2026 more split.","title":"How Splitties differs from Anko"},{"location":"Comparison_with_anko/#anko-layouts-their-issues-that-splitties-views-dsl-avoided","text":"","title":"Anko layouts: their issues that Splitties Views DSL avoided"},{"location":"Comparison_with_anko/#a-subclass-for-each-view-you-want-to-use","text":"To use a View in an Anko layout, in addition to a function for DSL usage, a subclass of it, specially tailored to work with Anko layouts is needed. Splitties Views DSL does not require such a thing at all. You can just pass the constructor reference to the view function (e.g. view(::MyShinyCustomView) ), and if you want, for your convenience, you can make an \"alias function\" (e.g. myShinyCustomView() ), which can (should) be inline . Consequently, Splitties is lighter, and more flexible.","title":"A subclass for each View you want to use"},{"location":"Comparison_with_anko/#views-added-implicitly","text":"In DSL fashion, Anko layouts implicitly add any view you create using the DSL to the receiver ViewGroup if any, or set it as a content view if in an Activity . In the real world, you rarely add a View without specifying the LayoutParams , so this implicit behavior only makes it easier to forget specifying the layout params, and realizing it later, possibly losing time in your development process. Splitties never adds a View implicitly. You always have to supply LayoutParams to the add function. That also makes creating a View without adding it at instantiation place straightforward.","title":"Views added implicitly"},{"location":"Comparison_with_anko/#anko-commons-misc-extensions-that-could-be-split","text":"Anko commons has several extension functions or helpers for Android to avoid some boilerplate. However, you need to have the full dependency even if you use only a few parts in it, which can make your app bigger (before proguard at least). Splitties, from day one was split (that's where its name comes from). You can use only one module with, let's say, Splitties Intents, but not Splitties Fragment Args. This avoids to integrate what you know you don't need, and helps making your app smaller.","title":"Anko commons: misc extensions that could be split"},{"location":"modules/activities/","text":"Activities \u00b6 Start activities with minimal boilerplate. Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.activities , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-activities . Content \u00b6 Starting Activities \u00b6 The start extension function for Context takes advantage of reified type parameters to allow you to write such code: start<AboutActivity>() . There's an optional lambda where the Intent is the receiver so you can edit it (e.g. adding flags) before the activity is started with it. The startActivity extension function for Context is designed for implicit intents. It expects the Intent action as first parameter, and takes an optional lambda to edit the intent further, like start .","title":"Activities"},{"location":"modules/activities/#activities","text":"Start activities with minimal boilerplate. Supported platforms: Android .","title":"Activities"},{"location":"modules/activities/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.activities , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-activities .","title":"Setup"},{"location":"modules/activities/#content","text":"","title":"Content"},{"location":"modules/activities/#starting-activities","text":"The start extension function for Context takes advantage of reified type parameters to allow you to write such code: start<AboutActivity>() . There's an optional lambda where the Intent is the receiver so you can edit it (e.g. adding flags) before the activity is started with it. The startActivity extension function for Context is designed for implicit intents. It expects the Intent action as first parameter, and takes an optional lambda to edit the intent further, like start .","title":"Starting Activities"},{"location":"modules/alertdialog/","text":"Alert Dialog \u00b6 Create simple alert dialogs with simple code Supported platforms: Android . You may be looking for the Material version or the AppCompat version . Setup \u00b6 This dependency is not included in any of the fun-packs , because typical Android apps use the Material or AppCompat version. However, it might prove handy for WearOS apps where you should use the platform one. Add it with refreshVersions : Splitties.alertdialog . For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-alertdialog . Example \u00b6 import splitties.alertdialog.alertDialog import splitties.alertdialog.cancelButton import splitties.alertdialog.messageResource import splitties.alertdialog.okButton import splitties.alertdialog.onShow import splitties.alertdialog.positiveButton class YourActivity : AppCompatActivity { //... private fun doIrreversibleStuffOrCancel () { alertDialog { messageResource = R . string . dialog_msg_confirm_irreversible_stuff okButton { irreversibleStuff () } cancelButton () }. onShow { positiveButton . textColorResource = R . color . red_500 }. show () } }","title":"Alert Dialog"},{"location":"modules/alertdialog/#alert-dialog","text":"Create simple alert dialogs with simple code Supported platforms: Android . You may be looking for the Material version or the AppCompat version .","title":"Alert Dialog"},{"location":"modules/alertdialog/#setup","text":"This dependency is not included in any of the fun-packs , because typical Android apps use the Material or AppCompat version. However, it might prove handy for WearOS apps where you should use the platform one. Add it with refreshVersions : Splitties.alertdialog . For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-alertdialog .","title":"Setup"},{"location":"modules/alertdialog/#example","text":"import splitties.alertdialog.alertDialog import splitties.alertdialog.cancelButton import splitties.alertdialog.messageResource import splitties.alertdialog.okButton import splitties.alertdialog.onShow import splitties.alertdialog.positiveButton class YourActivity : AppCompatActivity { //... private fun doIrreversibleStuffOrCancel () { alertDialog { messageResource = R . string . dialog_msg_confirm_irreversible_stuff okButton { irreversibleStuff () } cancelButton () }. onShow { positiveButton . textColorResource = R . color . red_500 }. show () } }","title":"Example"},{"location":"modules/alertdialog-appcompat/","text":"Alert Dialog AppCompat \u00b6 Create simple alert dialogs with simple code Supported platforms: Android . You may also need the Material version and the coroutines extensions . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.alertdialogAppcompat , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-alertdialog-appcompat . Example \u00b6 import splitties.alertdialog.appcompat.alertDialog import splitties.alertdialog.appcompat.cancelButton import splitties.alertdialog.appcompat.messageResource import splitties.alertdialog.appcompat.okButton import splitties.alertdialog.appcompat.onShow import splitties.alertdialog.appcompat.positiveButton class YourActivity : AppCompatActivity { //... private fun doIrreversibleStuffOrCancel () { alertDialog { messageResource = R . string . dialog_msg_confirm_irreversible_stuff okButton { irreversibleStuff () } cancelButton () }. onShow { positiveButton . textColorResource = R . color . red_500 }. show () } }","title":"Alert Dialog AppCompat"},{"location":"modules/alertdialog-appcompat/#alert-dialog-appcompat","text":"Create simple alert dialogs with simple code Supported platforms: Android . You may also need the Material version and the coroutines extensions .","title":"Alert Dialog AppCompat"},{"location":"modules/alertdialog-appcompat/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.alertdialogAppcompat , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-alertdialog-appcompat .","title":"Setup"},{"location":"modules/alertdialog-appcompat/#example","text":"import splitties.alertdialog.appcompat.alertDialog import splitties.alertdialog.appcompat.cancelButton import splitties.alertdialog.appcompat.messageResource import splitties.alertdialog.appcompat.okButton import splitties.alertdialog.appcompat.onShow import splitties.alertdialog.appcompat.positiveButton class YourActivity : AppCompatActivity { //... private fun doIrreversibleStuffOrCancel () { alertDialog { messageResource = R . string . dialog_msg_confirm_irreversible_stuff okButton { irreversibleStuff () } cancelButton () }. onShow { positiveButton . textColorResource = R . color . red_500 }. show () } }","title":"Example"},{"location":"modules/alertdialog-appcompat-coroutines/","text":"Alert Dialog AppCompat Coroutines \u00b6 showAndAwait extension functions for AppCompat AlertDialog. Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.alertdialogAppcompatCoroutines , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-alertdialog-appcompat-coroutines . Example \u00b6 import splitties.alertdialog.appcompat.alertDialog import splitties.alertdialog.appcompat.messageResource import splitties.alertdialog.appcompat.coroutines.showAndAwait import splitties.resources.txt suspend fun shouldWeReallyDeleteFromTrash (): Boolean = alertDialog ( message = txt ( R . string . dialog_msg_confirm_delete_from_trash ) ). showAndAwait ( okValue = true , cancelValue = false , dismissValue = false )","title":"Alert Dialog AppCompat Coroutines"},{"location":"modules/alertdialog-appcompat-coroutines/#alert-dialog-appcompat-coroutines","text":"showAndAwait extension functions for AppCompat AlertDialog. Supported platforms: Android .","title":"Alert Dialog AppCompat Coroutines"},{"location":"modules/alertdialog-appcompat-coroutines/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.alertdialogAppcompatCoroutines , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-alertdialog-appcompat-coroutines .","title":"Setup"},{"location":"modules/alertdialog-appcompat-coroutines/#example","text":"import splitties.alertdialog.appcompat.alertDialog import splitties.alertdialog.appcompat.messageResource import splitties.alertdialog.appcompat.coroutines.showAndAwait import splitties.resources.txt suspend fun shouldWeReallyDeleteFromTrash (): Boolean = alertDialog ( message = txt ( R . string . dialog_msg_confirm_delete_from_trash ) ). showAndAwait ( okValue = true , cancelValue = false , dismissValue = false )","title":"Example"},{"location":"modules/alertdialog-material/","text":"Alert Dialog Material \u00b6 Create simple alert dialogs in material design with simple code Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.alertdialogMaterial , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-alertdialog-material . Example \u00b6 import splitties.alertdialog.material.materialAlertDialog import splitties.alertdialog.appcompat.cancelButton import splitties.alertdialog.appcompat.messageResource import splitties.alertdialog.appcompat.okButton import splitties.alertdialog.appcompat.onShow import splitties.alertdialog.appcompat.positiveButton class YourActivity : AppCompatActivity { //... private fun doIrreversibleStuffOrCancel () { materialAlertDialog { messageResource = R . string . dialog_msg_confirm_irreversible_stuff okButton { irreversibleStuff () } cancelButton () }. onShow { positiveButton . textColorResource = R . color . red_500 }. show () } }","title":"Alert Dialog Material"},{"location":"modules/alertdialog-material/#alert-dialog-material","text":"Create simple alert dialogs in material design with simple code Supported platforms: Android .","title":"Alert Dialog Material"},{"location":"modules/alertdialog-material/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.alertdialogMaterial , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-alertdialog-material .","title":"Setup"},{"location":"modules/alertdialog-material/#example","text":"import splitties.alertdialog.material.materialAlertDialog import splitties.alertdialog.appcompat.cancelButton import splitties.alertdialog.appcompat.messageResource import splitties.alertdialog.appcompat.okButton import splitties.alertdialog.appcompat.onShow import splitties.alertdialog.appcompat.positiveButton class YourActivity : AppCompatActivity { //... private fun doIrreversibleStuffOrCancel () { materialAlertDialog { messageResource = R . string . dialog_msg_confirm_irreversible_stuff okButton { irreversibleStuff () } cancelButton () }. onShow { positiveButton . textColorResource = R . color . red_500 }. show () } }","title":"Example"},{"location":"modules/appctx/","text":"App Context \u00b6 Always have your application Context at hand with appCtx . Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.appctx , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-appctx . This split provides two read-only properties: appCtx that returns your Application Context directBootCtx for your direct boot aware components where storage is involved, if any. It also brings these 2 extensions functions on Context for advanced usages: - injectAsAppCtx() - canLeakMemory() You can use appCtx and directBootCtx anywhere in your app (without risking leaking a short-lived context such as an Activity or a Service). This makes writing code that needs a Context for non Activity specific purposes more convenient. Important: use the right context! \u00b6 You may not want to use the Application Context in some cases. Context for storage \u00b6 If you need a Context to access storage from a library (for SharedPreferences, a database or other files), you should allow passing a specific Context that could default as appCtx , so it is possible for target apps to use a special Context like directBootCtx . Configuration dependent or themed Context \u00b6 Devices on which your app/library runs may (will) change configuration during the app's process lifecycle, such as screen density, language or orientation. Please, do not use appCtx or directBootCtx if you rely on a \"scoped\" Context to access themed resources from an Activity, or configuration dependent values/resources. Note that in some cases, configuration dependent context usage may be ok if your component handles onConfigurationChanged() properly. More generally, if you wonder if using Application Context is ok, test your app against configuration changes that may affect it and check it reacts correctly. How it works \u00b6 This library takes advantage of Content Providers to automatically initialize appCtx for you before even your Application 's onCreate() is called! This library also takes advantage of manifest placeholders (with the default ${applicationId} ) and gradle manifest merging to avoid two apps using this library clashing with same authority Content Providers. This is the same trick used by Firebase to auto-initialize the library. You can read more on this here . Advanced use cases \u00b6 Multi-process apps and libraries \u00b6 While most apps run in a single-process, on the default one, some need to run some components in different processes. If your app needs to access appCtx or directBootCtx directly, or indirectly, in a component that has its android:process tag in AndroidManifest.xml set to :the_name_of_your_private_process or the_fully_qualified_name_of_your_shared_process , you need to do the following: Call injectAsAppCtx() in the init block (or constructor) of your custom Application subclass. If you're making a library, an alternative solution that will not require further configuration on the app side is to declare your own ContentProvider for that process and call injectAsAppCtx() from its onCreate function.","title":"App Context"},{"location":"modules/appctx/#app-context","text":"Always have your application Context at hand with appCtx . Supported platforms: Android .","title":"App Context"},{"location":"modules/appctx/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.appctx , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-appctx . This split provides two read-only properties: appCtx that returns your Application Context directBootCtx for your direct boot aware components where storage is involved, if any. It also brings these 2 extensions functions on Context for advanced usages: - injectAsAppCtx() - canLeakMemory() You can use appCtx and directBootCtx anywhere in your app (without risking leaking a short-lived context such as an Activity or a Service). This makes writing code that needs a Context for non Activity specific purposes more convenient.","title":"Setup"},{"location":"modules/appctx/#important-use-the-right-context","text":"You may not want to use the Application Context in some cases.","title":"Important: use the right context!"},{"location":"modules/appctx/#context-for-storage","text":"If you need a Context to access storage from a library (for SharedPreferences, a database or other files), you should allow passing a specific Context that could default as appCtx , so it is possible for target apps to use a special Context like directBootCtx .","title":"Context for storage"},{"location":"modules/appctx/#configuration-dependent-or-themed-context","text":"Devices on which your app/library runs may (will) change configuration during the app's process lifecycle, such as screen density, language or orientation. Please, do not use appCtx or directBootCtx if you rely on a \"scoped\" Context to access themed resources from an Activity, or configuration dependent values/resources. Note that in some cases, configuration dependent context usage may be ok if your component handles onConfigurationChanged() properly. More generally, if you wonder if using Application Context is ok, test your app against configuration changes that may affect it and check it reacts correctly.","title":"Configuration dependent or themed Context"},{"location":"modules/appctx/#how-it-works","text":"This library takes advantage of Content Providers to automatically initialize appCtx for you before even your Application 's onCreate() is called! This library also takes advantage of manifest placeholders (with the default ${applicationId} ) and gradle manifest merging to avoid two apps using this library clashing with same authority Content Providers. This is the same trick used by Firebase to auto-initialize the library. You can read more on this here .","title":"How it works"},{"location":"modules/appctx/#advanced-use-cases","text":"","title":"Advanced use cases"},{"location":"modules/appctx/#multi-process-apps-and-libraries","text":"While most apps run in a single-process, on the default one, some need to run some components in different processes. If your app needs to access appCtx or directBootCtx directly, or indirectly, in a component that has its android:process tag in AndroidManifest.xml set to :the_name_of_your_private_process or the_fully_qualified_name_of_your_shared_process , you need to do the following: Call injectAsAppCtx() in the init block (or constructor) of your custom Application subclass. If you're making a library, an alternative solution that will not require further configuration on the app side is to declare your own ContentProvider for that process and call injectAsAppCtx() from its onCreate function.","title":"Multi-process apps and libraries"},{"location":"modules/arch-lifecycle/","text":"Arch Lifecycle \u00b6 Extensions to get ViewModel s, use LiveData and observe Lifecycle s. Supported platforms: Android . This makes using Android Architecture Components nicer in Kotlin. Setup \u00b6 This dependency is not included in any of the fun-packs , because we don't believe all apps need its content nowadays. Add it with refreshVersions : Splitties.archLifecycle . For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-arch-lifecycle . Content \u00b6 LifecycleObserver \u00b6 This is a LifecycleEventObserver sub-interface that has lifecycle state change methods (like onResume(\u2026) or onPause(\u2026) ) with default implementations, so you override only the ones you need. ViewModel providers \u00b6 AndroidX Activity KTX and Fragment KTX provide convenient delegates to get a ViewModel subclass instance, but they lack a facility when you need to pass arguments to a ViewModel . Splitties brings a version that takes a lambda, allowing you to run any logic before instantiating the ViewModel, including accessing the created Activity or Fragment . class YourActivity : AppCompatActivity () { private val viewModel : SomeViewModel by viewModels () // From androidx.activity KTX private val anotherViewModel by viewModels < AnotherViewModel > () // From androidx.activity KTX private val yourViewModel by viewModels { // From Splitties YourViewModel ( someParams ) } } class SomeFragment : Fragment () { private val viewModel : SomeViewModel by viewModels () // From androidx.activity KTX private val anotherViewModel : AnotherViewModel by activityViewModels () // From androidx.activity KTX private val yourViewModel by viewModels { // From Splitties YourViewModel ( someParams ) } } LiveData observing and map extension \u00b6 observe and observeNotNull extension functions on LifecycleOwner \u00b6 These extensions make observing a LiveData null-safe (despite LiveData not being null-safe itself), giving you the choice of whether you want to deal with nulls or ignore them. class YourActivity : AppCompatActivity () { private val viewModel by activityScope < YourViewModel > () override fun onCreate ( savedInstanceState : Bundle?) { observe ( viewModel . yourLiveData ) { data : YourData? -> updateUi ( data ) } observeNotNull ( viewModel . anotherLiveData ) { doSomething ( it . someProperty ) doSomethingElse ( it ) } } } map extension function on LiveData \u00b6 class YourViewModel : ViewModel () { val yourLiveData : LiveData < YourData > = createYourLiveData () val anotherLiveData = yourLiveData . map { it ?. someProperty } } Note that the map lambda runs on UI thread, so very light operations like getting a property is right, but long/blocking operations are not (would result in lags or ANRs).","title":"Arch Lifecycle"},{"location":"modules/arch-lifecycle/#arch-lifecycle","text":"Extensions to get ViewModel s, use LiveData and observe Lifecycle s. Supported platforms: Android . This makes using Android Architecture Components nicer in Kotlin.","title":"Arch Lifecycle"},{"location":"modules/arch-lifecycle/#setup","text":"This dependency is not included in any of the fun-packs , because we don't believe all apps need its content nowadays. Add it with refreshVersions : Splitties.archLifecycle . For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-arch-lifecycle .","title":"Setup"},{"location":"modules/arch-lifecycle/#content","text":"","title":"Content"},{"location":"modules/arch-lifecycle/#lifecycleobserver","text":"This is a LifecycleEventObserver sub-interface that has lifecycle state change methods (like onResume(\u2026) or onPause(\u2026) ) with default implementations, so you override only the ones you need.","title":"LifecycleObserver"},{"location":"modules/arch-lifecycle/#viewmodel-providers","text":"AndroidX Activity KTX and Fragment KTX provide convenient delegates to get a ViewModel subclass instance, but they lack a facility when you need to pass arguments to a ViewModel . Splitties brings a version that takes a lambda, allowing you to run any logic before instantiating the ViewModel, including accessing the created Activity or Fragment . class YourActivity : AppCompatActivity () { private val viewModel : SomeViewModel by viewModels () // From androidx.activity KTX private val anotherViewModel by viewModels < AnotherViewModel > () // From androidx.activity KTX private val yourViewModel by viewModels { // From Splitties YourViewModel ( someParams ) } } class SomeFragment : Fragment () { private val viewModel : SomeViewModel by viewModels () // From androidx.activity KTX private val anotherViewModel : AnotherViewModel by activityViewModels () // From androidx.activity KTX private val yourViewModel by viewModels { // From Splitties YourViewModel ( someParams ) } }","title":"ViewModel providers"},{"location":"modules/arch-lifecycle/#livedata-observing-and-map-extension","text":"","title":"LiveData observing and map extension"},{"location":"modules/arch-lifecycle/#observe-and-observenotnull-extension-functions-on-lifecycleowner","text":"These extensions make observing a LiveData null-safe (despite LiveData not being null-safe itself), giving you the choice of whether you want to deal with nulls or ignore them. class YourActivity : AppCompatActivity () { private val viewModel by activityScope < YourViewModel > () override fun onCreate ( savedInstanceState : Bundle?) { observe ( viewModel . yourLiveData ) { data : YourData? -> updateUi ( data ) } observeNotNull ( viewModel . anotherLiveData ) { doSomething ( it . someProperty ) doSomethingElse ( it ) } } }","title":"observe and observeNotNull extension functions on LifecycleOwner"},{"location":"modules/arch-lifecycle/#map-extension-function-on-livedata","text":"class YourViewModel : ViewModel () { val yourLiveData : LiveData < YourData > = createYourLiveData () val anotherLiveData = yourLiveData . map { it ?. someProperty } } Note that the map lambda runs on UI thread, so very light operations like getting a property is right, but long/blocking operations are not (would result in lags or ANRs).","title":"map extension function on LiveData"},{"location":"modules/arch-room/","text":"Arch Room \u00b6 Room helpers to instantiate your DB and perform transactions in Kotlin. Supported platforms: Android . Setup \u00b6 This dependency is not included in any of the fun-packs , because many apps don't need Room, either because they use SqlDelight or another database system, or because they don't need a database at all. Add it with refreshVersions : Splitties.archRoom . For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-arch-room . Content \u00b6 Room Database instantiation \u00b6 The roomDb(\u2026) function has a reified type parameter used to call Room.databaseBuilder with the proper arguments. name is the only required parameter. You can specify a Context as first parameter if you don't want to use the application context, if you want to use a different context (e.g. to use directBootCtx in a direct boot aware app component). The last parameter is a lambda with the db builder as receiver where you can things like migrations.","title":"Arch Room"},{"location":"modules/arch-room/#arch-room","text":"Room helpers to instantiate your DB and perform transactions in Kotlin. Supported platforms: Android .","title":"Arch Room"},{"location":"modules/arch-room/#setup","text":"This dependency is not included in any of the fun-packs , because many apps don't need Room, either because they use SqlDelight or another database system, or because they don't need a database at all. Add it with refreshVersions : Splitties.archRoom . For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-arch-room .","title":"Setup"},{"location":"modules/arch-room/#content","text":"","title":"Content"},{"location":"modules/arch-room/#room-database-instantiation","text":"The roomDb(\u2026) function has a reified type parameter used to call Room.databaseBuilder with the proper arguments. name is the only required parameter. You can specify a Context as first parameter if you don't want to use the application context, if you want to use a different context (e.g. to use directBootCtx in a direct boot aware app component). The last parameter is a lambda with the db builder as receiver where you can things like migrations.","title":"Room Database instantiation"},{"location":"modules/bitflags/","text":"Bit Flags \u00b6 hasFlag , withFlag and minusFlag extensions on Long , Int , Short , Byte , and their unsigned counterparts. Supported platforms: Linux (x64), MingW (x64) , macOS (x64), iOS (arm32, arm64 & x64), JS , JVM (including Android). These extensions make dealing with bit flags easier. These small inline extensions can be proven handy since bit flags are found in multiple places over the Android API, in low level stuff when you have to deal with raw bytes, and maybe in your own codebase too. Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.bitflags , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-bitflags .","title":"Bit Flags"},{"location":"modules/bitflags/#bit-flags","text":"hasFlag , withFlag and minusFlag extensions on Long , Int , Short , Byte , and their unsigned counterparts. Supported platforms: Linux (x64), MingW (x64) , macOS (x64), iOS (arm32, arm64 & x64), JS , JVM (including Android). These extensions make dealing with bit flags easier. These small inline extensions can be proven handy since bit flags are found in multiple places over the Android API, in low level stuff when you have to deal with raw bytes, and maybe in your own codebase too.","title":"Bit Flags"},{"location":"modules/bitflags/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.bitflags , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-bitflags .","title":"Setup"},{"location":"modules/bundle/","text":"Bundle \u00b6 BundleSpec to use Bundle with property syntax for Intent extras and more. Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.bundle , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-bundle . Non-exhaustive list of use cases \u00b6 Intent extras of Activities, BroadcastReceivers, Services, etc. Instance state of Activities, Fragments and Views. Can be used for Activity extras, but also in Service extras, BroadcastReceiver and other parts where an Intent or a Bundle is used. Usage \u00b6 For Activity extras \u00b6 Let's say you have an Activity subclass named YourActivity . In YourActivity , add a nested object named ExtrasSpec . Make it extend BundleSpec . For each required Intent extra you need, in ExtrasSpec , add a var property with explicit non null type, delegated by bundle() . For each optional Intent extra you need, still in ExtrasSpec , add a var property with either and explicit nullable type, delegated by bundleOrNull() , or with a non null type, delegated by bundleOrDefault(\u2026) or by bundleOrElse { \u2026 } . When setting up the Intent to start your Activity , call putExtras(YourActivity.ExtrasSpec) { \u2026 } on it, setting values on the ExtrasSpec properties in the lambda. From YourActivity , call withExtras(ExtrasSpec) { \u2026 } to get the extras as properties from the lambda (the result of the call is the result of the lambda). Other usages \u00b6 Only Activity has a withExtras(\u2026) { \u2026 } extension, but you can use with(\u2026) { \u2026 } extension on any Bundle and any Intent extras . The putExtras(\u2026) { \u2026 } extension works on any Intent , Activity or not. See the examples below. Important details \u00b6 See the implementation of the put(\u2026) extension on Bundle to check all the supported types (it is likely to suit your needs). You may only access the delegated properties of a BundleSpec subclass inside the withExtras(\u2026) { \u2026 } lambda or inside the someBundle.with(\u2026) { \u2026 } lambda. If you violate this rule, an IllegalStateException will be thrown. The implementation has been optimized for efficiency. The delegates under bundle() and bundleOrNull() are singletons and are shared for all properties app-wide. The versions that accept a key or a default value can't be singletons, but since you're likely using them in object backed specs, they are instantiated only once per property, having a minimal memory impact (especially when compared to the cost of data serialization in Bundles). Examples \u00b6 Extras in an Activity \u00b6 class DemoActivity : AppCompatActivity () { object ExtrasSpec : BundleSpec () { var userName : String by bundle () // Required extra var showGreetingToast by bundleOrDefault ( false ) // Optional extra, defaults to false var optionalExtra : String? by bundleOrNull () // Optional extra } override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) withExtras ( ExtrasSpec ) { // Populates ExtrasSpec with actual extras if ( showGreetingToast ) toast ( android . R . string . ok ) optionalExtras ?. forEach { Timber . i ( \"Character from optional extra: $ it \" ) } } restOfYourCode () } } class StartDemoActivity : AppCompatActivity () { private fun someFunction ( name : String , isUserPolite : Boolean = false ) { startActivity ( Intent ( this , DemoActivity :: class . java ). apply { putExtras ( DemoActivity . ExtrasSpec ) { userName = name showGreetingToast = isUserPolite } }) } } Extras in a BroadcastReceiver \u00b6 class AirplaneModeReceiver : BroadcastReceiver () { object ExtrasSpec : BundleSpec () { var isAirplaneModeOn : Boolean by bundle ( \"state\" ) } override fun onReceive ( context : Context , intent : Intent ) { if ( intent . action != Intent . ACTION_AIRPLANE_MODE_CHANGED ) return val isAirplaneModeOn = intent . extras . with ( ExtrasSpec ) { isAirplaneModeOn } handleAirplaneMode ( isAirplaneModeOn ) } } Instance State in an Activity \u00b6 class DemoActivity : AppCompatActivity () { private object InstanceStateSpec : BundleSpec () { var startTime : Long by bundle () } private var startTimestamp = 0L override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) startTimestamp = savedInstanceState ?. with ( InstanceStateSpec ) { startTime } ?: System . currentTimeMillis () restOfYourCode () } override fun onSaveInstanceState ( outState : Bundle ) { outState . with ( InstanceStateSpec ) { startTime = startTimestamp } super . onSaveInstanceState ( outState ) } }","title":"Bundle"},{"location":"modules/bundle/#bundle","text":"BundleSpec to use Bundle with property syntax for Intent extras and more. Supported platforms: Android .","title":"Bundle"},{"location":"modules/bundle/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.bundle , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-bundle .","title":"Setup"},{"location":"modules/bundle/#non-exhaustive-list-of-use-cases","text":"Intent extras of Activities, BroadcastReceivers, Services, etc. Instance state of Activities, Fragments and Views. Can be used for Activity extras, but also in Service extras, BroadcastReceiver and other parts where an Intent or a Bundle is used.","title":"Non-exhaustive list of use cases"},{"location":"modules/bundle/#usage","text":"","title":"Usage"},{"location":"modules/bundle/#for-activity-extras","text":"Let's say you have an Activity subclass named YourActivity . In YourActivity , add a nested object named ExtrasSpec . Make it extend BundleSpec . For each required Intent extra you need, in ExtrasSpec , add a var property with explicit non null type, delegated by bundle() . For each optional Intent extra you need, still in ExtrasSpec , add a var property with either and explicit nullable type, delegated by bundleOrNull() , or with a non null type, delegated by bundleOrDefault(\u2026) or by bundleOrElse { \u2026 } . When setting up the Intent to start your Activity , call putExtras(YourActivity.ExtrasSpec) { \u2026 } on it, setting values on the ExtrasSpec properties in the lambda. From YourActivity , call withExtras(ExtrasSpec) { \u2026 } to get the extras as properties from the lambda (the result of the call is the result of the lambda).","title":"For Activity extras"},{"location":"modules/bundle/#other-usages","text":"Only Activity has a withExtras(\u2026) { \u2026 } extension, but you can use with(\u2026) { \u2026 } extension on any Bundle and any Intent extras . The putExtras(\u2026) { \u2026 } extension works on any Intent , Activity or not. See the examples below.","title":"Other usages"},{"location":"modules/bundle/#important-details","text":"See the implementation of the put(\u2026) extension on Bundle to check all the supported types (it is likely to suit your needs). You may only access the delegated properties of a BundleSpec subclass inside the withExtras(\u2026) { \u2026 } lambda or inside the someBundle.with(\u2026) { \u2026 } lambda. If you violate this rule, an IllegalStateException will be thrown. The implementation has been optimized for efficiency. The delegates under bundle() and bundleOrNull() are singletons and are shared for all properties app-wide. The versions that accept a key or a default value can't be singletons, but since you're likely using them in object backed specs, they are instantiated only once per property, having a minimal memory impact (especially when compared to the cost of data serialization in Bundles).","title":"Important details"},{"location":"modules/bundle/#examples","text":"","title":"Examples"},{"location":"modules/bundle/#extras-in-an-activity","text":"class DemoActivity : AppCompatActivity () { object ExtrasSpec : BundleSpec () { var userName : String by bundle () // Required extra var showGreetingToast by bundleOrDefault ( false ) // Optional extra, defaults to false var optionalExtra : String? by bundleOrNull () // Optional extra } override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) withExtras ( ExtrasSpec ) { // Populates ExtrasSpec with actual extras if ( showGreetingToast ) toast ( android . R . string . ok ) optionalExtras ?. forEach { Timber . i ( \"Character from optional extra: $ it \" ) } } restOfYourCode () } } class StartDemoActivity : AppCompatActivity () { private fun someFunction ( name : String , isUserPolite : Boolean = false ) { startActivity ( Intent ( this , DemoActivity :: class . java ). apply { putExtras ( DemoActivity . ExtrasSpec ) { userName = name showGreetingToast = isUserPolite } }) } }","title":"Extras in an Activity"},{"location":"modules/bundle/#extras-in-a-broadcastreceiver","text":"class AirplaneModeReceiver : BroadcastReceiver () { object ExtrasSpec : BundleSpec () { var isAirplaneModeOn : Boolean by bundle ( \"state\" ) } override fun onReceive ( context : Context , intent : Intent ) { if ( intent . action != Intent . ACTION_AIRPLANE_MODE_CHANGED ) return val isAirplaneModeOn = intent . extras . with ( ExtrasSpec ) { isAirplaneModeOn } handleAirplaneMode ( isAirplaneModeOn ) } }","title":"Extras in a BroadcastReceiver"},{"location":"modules/bundle/#instance-state-in-an-activity","text":"class DemoActivity : AppCompatActivity () { private object InstanceStateSpec : BundleSpec () { var startTime : Long by bundle () } private var startTimestamp = 0L override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) startTimestamp = savedInstanceState ?. with ( InstanceStateSpec ) { startTime } ?: System . currentTimeMillis () restOfYourCode () } override fun onSaveInstanceState ( outState : Bundle ) { outState . with ( InstanceStateSpec ) { startTime = startTimestamp } super . onSaveInstanceState ( outState ) } }","title":"Instance State in an Activity"},{"location":"modules/checkedlazy/","text":"Checked Lazy \u00b6 mainThreadLazy that checks property access on main thread, and checkedLazy to make your own variant. Supported platforms: Android . NOTE: Coroutines can replace the need for this split altogether in most cases. Setup \u00b6 This dependency is not included in any of the fun-packs , because we don't believe all apps need its content nowadays. Add it with refreshVersions : Splitties.checkedlazy . For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-checkedlazy . Content \u00b6 This library provides a checkedLazy() method that returns a Lazy delegate, as well as mainThreadLazy() . checkedLazy() takes as first parameter a function where you can implement an access check. The second parameter is the lazy initializer, as in Kotlin stdlib lazy . mainThreadLazy { \u2026 } is a shorthand for checkedLazy(::checkMainThread) { \u2026 } . It's there because main thread checking is a common use case on Android due to its synchronized nature and its omnipresence. Example \u00b6 val noMainThreadChecker = noAccessOn ( mainThread ) class YourClass { val greeting : String by mainThreadLazy { \"Hello Splitties!\" } val expensiveObject by checkedLazy ( noMainThreadChecker ) { doHeavyInstantiation () } }","title":"Checked Lazy"},{"location":"modules/checkedlazy/#checked-lazy","text":"mainThreadLazy that checks property access on main thread, and checkedLazy to make your own variant. Supported platforms: Android . NOTE: Coroutines can replace the need for this split altogether in most cases.","title":"Checked Lazy"},{"location":"modules/checkedlazy/#setup","text":"This dependency is not included in any of the fun-packs , because we don't believe all apps need its content nowadays. Add it with refreshVersions : Splitties.checkedlazy . For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-checkedlazy .","title":"Setup"},{"location":"modules/checkedlazy/#content","text":"This library provides a checkedLazy() method that returns a Lazy delegate, as well as mainThreadLazy() . checkedLazy() takes as first parameter a function where you can implement an access check. The second parameter is the lazy initializer, as in Kotlin stdlib lazy . mainThreadLazy { \u2026 } is a shorthand for checkedLazy(::checkMainThread) { \u2026 } . It's there because main thread checking is a common use case on Android due to its synchronized nature and its omnipresence.","title":"Content"},{"location":"modules/checkedlazy/#example","text":"val noMainThreadChecker = noAccessOn ( mainThread ) class YourClass { val greeting : String by mainThreadLazy { \"Hello Splitties!\" } val expensiveObject by checkedLazy ( noMainThreadChecker ) { doHeavyInstantiation () } }","title":"Example"},{"location":"modules/collections/","text":"Collections \u00b6 forEach for List s without Iterator allocation. Supported platforms: Linux (x64), MingW (x64) , macOS (x64), iOS (arm32, arm64 & x64), JS , JVM (including Android). Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.collections , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-collections . Content \u00b6 The forEachByIndex and forEachWithIndex extension functions for List allows you to iterate on a List without allocating an Iterator . This is useful when you need to iterate on a List in performance critical conditions (e.g. code executed/called from an onDraw method, or code run on the UI thread more generally). You also have the reverse equivalents: forEachReversedByIndex and forEachReversedWithIndex .","title":"Collections"},{"location":"modules/collections/#collections","text":"forEach for List s without Iterator allocation. Supported platforms: Linux (x64), MingW (x64) , macOS (x64), iOS (arm32, arm64 & x64), JS , JVM (including Android).","title":"Collections"},{"location":"modules/collections/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.collections , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-collections .","title":"Setup"},{"location":"modules/collections/#content","text":"The forEachByIndex and forEachWithIndex extension functions for List allows you to iterate on a List without allocating an Iterator . This is useful when you need to iterate on a List in performance critical conditions (e.g. code executed/called from an onDraw method, or code run on the UI thread more generally). You also have the reverse equivalents: forEachReversedByIndex and forEachReversedWithIndex .","title":"Content"},{"location":"modules/coroutines/","text":"Coroutines \u00b6 General purpose extensions to kotlinx.coroutines. Supported platforms: Linux (x64), MingW (x64) , macOS (x64), iOS (arm32, arm64 & x64), JS , JVM (including Android). Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.coroutines , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-coroutines . Offering a value to a SendChannel (including inside callbackFlow ) safely \u00b6 Calling the offer function in SendChannel as it can crash your program if the channel is closed, as can be seen in this issue: https://github.com/Kotlin/kotlinx.coroutines/issues/974 . To be safe from this pitfall, Splitties provides an extension named offerCatching(\u2026) that returns false if offer throws, making you safe in the edge cases where a call is made just after the channel gets closed, as can happen when using callbackFlow { \u2026 } in multi-threaded environments. Cancellable infinite loops \u00b6 The repeatWhileActive { \u2026 } top level function is like a while (true) { \u2026 } loop, except that: - it evaluates to Nothing , allowing you to use it in any lambda, regardless of its return type. - it will check for cancellation before each execution of the passed lambda, protecting from an infinite loop if the code in the lambda doesn't check for cancellation but eventually ends running. It also has an overload that takes a Boolean parameter named ignoreInnerCancellations . This one is made for the cases where you're throwing a CancellationException to signal the cancellation of this loop run/iteration, but want to continue looping again. Can be useful if you are using withTimeout { \u2026 } or want to easily handle user requested cancellation. It will still check that the scope has not been cancelled before each iteration, so it's perfectly safe to use among code that must be cancellable. Example: \u00b6 suspend fun doStuffUntilCancelled ( ui : SomeUi , someObject : SomeType ): Nothing { repeatWhileActive { val command = ui . awaitSomeUserAction () someObject . doSomething ( command . whatever ) ui . awaitAnotherUserAction () val result = someObject . doSomethingElse () ui . showOutcome ( result ) } } Racing coroutines \u00b6 Number of racers fixed at compile time \u00b6 The raceOf(\u2026) function takes a variable number of coroutines, that also have a CoroutineScope as a receiver. The first coroutine to finish (includes that any child coroutines that might have been launched are completed or cancelled too) will cancel the others, and its value will be returned by raceOf . Note that calling raceOf with no racers is forbidden, and any attempt to do so will throw an IllegalArgumentException . There's a deprecated overload of raceOf() taking no parameters to prevent you from making this mistake. For variable number of racing coroutines, use race + launchRacer documented below. Simple example (unit test): \u00b6 suspend fun testCoroutinesRacing () { val result = raceOf ({ delay ( 3 ) \"slow\" }, { delay ( 0 ) \"fast\" }) assertEquals ( expected = \"fast\" , actual = result ) } UI code example \u00b6 suspend fun awaitUserChoice ( ui : SomeUi , choices : List < Stuff > ): Stuff? = raceOf ({ ui . awaitSomeUserAction ( choices ) }, { ui . awaitDismissal () null }, { ui . showSomethingInRealtimeUntilCancelled () // Returns Nothing, will run, but never \"win\". }) Dynamic racers and late racers \u00b6 The raceOf(\u2026) function might not suit your use case if the racing coroutines need to be launched based on some conditions, that might also take some time to be evaluated. These more advanced use-cases are satisfied by the race { \u2026 } function, where you can call launchRacer { \u2026 } in its lambda. If no racing coroutines are ever launched, the race { \u2026 } function will suspend until it is cancelled. Example \u00b6 suspend fun awaitSomeActionTrigger ( config : SomeConfig , deviceCapabilities : HardwareSupportInfo , defaultInput : SomeInput , awaitSpecialInput : suspend () -> Unit ) { race { launchRacer { defaultInput . awaitSomeAction () } if ( deviceCapabilities . supportsSpecialInput ) { launchRacer { awaitSpecialInput () } delay ( config . delayBeforeHintMillis ) // The race lambda can suspend showHintForSpecialInput () } } } Suspending version of lazy \u00b6 These 3 functions provide a SuspendLazy instance: CoroutineScope.suspendLazy { \u2026 } suspendBlockingLazy { \u2026 } (uses Dispatchers.Default by default) suspendBlockingLazyIO { \u2026 } (JVM-only for now, uses Dispatchers.IO ) They can be used almost like Kotlin's lazy , but you need parentheses to get the value. Note that if an Exception or any Throwable is thrown in their initializing lambda, the SuspendLazy instance will not be recoverable, so if retry logic is needed, it must include instantiating a new SuspendLazy . If you want it to allow retries on the same instance, please open an issue and tell about your use case. Example: Initializing a database only once \u00b6 For an app-wide remote database: val db : SomeDatabase = GlobalScope . suspendLazy { createDatabase (). also { it . connect () } // Both functions suspend } fun doStuff ( someData : SomeData ) { db (). runSomeTransaction ( someData ) } For an application-wide local database (e.g. in an Android or desktop JVM app): val db : AppDatabase = suspendBlockingLazyIO { buildDatabase () } fun doStuff ( someData : SomeData ) { db (). runSomeTransaction ( someData ) } Passing a SuspendLazy type can be handy: suspend fun doStuff ( getDb : SuspendLazy < AppDatabase > , someData : SomeData ) { val db = getDb () db . runSomeTransaction ( someData ) } Example: Offloading heavy object instantiation or expensive computation \u00b6 Objects that need a significant amount of memory (example bitmap/images, large arrays/lists, or large/deep data structures such as possibly non trivial trees) will block the current thread while being instantiated, waiting for the CPU to find enough free memory (RAM), which might include moving lots of stuff to have the contiguous space that can be required. To avoid blocking the user interface and altering the perceived performance of the application, you need to not run such code on the main/UI thread, but offload it to another thread such as one from Dispatchers.Default . The suspendBlockingLazy { \u2026 } makes it very easy to do it right: val expensiveThing = suspendBlockingLazy { DoHeavyInstantiation () } fun doStuff ( ui : SomeUi ) { // Can run on main/UI thread. val thing = expensiveThing () // Will suspend until DoHeavyInstantiation() is done. ui . displaySomeDataNicely ( thing ) }","title":"Coroutines"},{"location":"modules/coroutines/#coroutines","text":"General purpose extensions to kotlinx.coroutines. Supported platforms: Linux (x64), MingW (x64) , macOS (x64), iOS (arm32, arm64 & x64), JS , JVM (including Android).","title":"Coroutines"},{"location":"modules/coroutines/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.coroutines , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-coroutines .","title":"Setup"},{"location":"modules/coroutines/#offering-a-value-to-a-sendchannel-including-inside-callbackflow-safely","text":"Calling the offer function in SendChannel as it can crash your program if the channel is closed, as can be seen in this issue: https://github.com/Kotlin/kotlinx.coroutines/issues/974 . To be safe from this pitfall, Splitties provides an extension named offerCatching(\u2026) that returns false if offer throws, making you safe in the edge cases where a call is made just after the channel gets closed, as can happen when using callbackFlow { \u2026 } in multi-threaded environments.","title":"Offering a value to a SendChannel (including inside callbackFlow) safely"},{"location":"modules/coroutines/#cancellable-infinite-loops","text":"The repeatWhileActive { \u2026 } top level function is like a while (true) { \u2026 } loop, except that: - it evaluates to Nothing , allowing you to use it in any lambda, regardless of its return type. - it will check for cancellation before each execution of the passed lambda, protecting from an infinite loop if the code in the lambda doesn't check for cancellation but eventually ends running. It also has an overload that takes a Boolean parameter named ignoreInnerCancellations . This one is made for the cases where you're throwing a CancellationException to signal the cancellation of this loop run/iteration, but want to continue looping again. Can be useful if you are using withTimeout { \u2026 } or want to easily handle user requested cancellation. It will still check that the scope has not been cancelled before each iteration, so it's perfectly safe to use among code that must be cancellable.","title":"Cancellable infinite loops"},{"location":"modules/coroutines/#example","text":"suspend fun doStuffUntilCancelled ( ui : SomeUi , someObject : SomeType ): Nothing { repeatWhileActive { val command = ui . awaitSomeUserAction () someObject . doSomething ( command . whatever ) ui . awaitAnotherUserAction () val result = someObject . doSomethingElse () ui . showOutcome ( result ) } }","title":"Example:"},{"location":"modules/coroutines/#racing-coroutines","text":"","title":"Racing coroutines"},{"location":"modules/coroutines/#number-of-racers-fixed-at-compile-time","text":"The raceOf(\u2026) function takes a variable number of coroutines, that also have a CoroutineScope as a receiver. The first coroutine to finish (includes that any child coroutines that might have been launched are completed or cancelled too) will cancel the others, and its value will be returned by raceOf . Note that calling raceOf with no racers is forbidden, and any attempt to do so will throw an IllegalArgumentException . There's a deprecated overload of raceOf() taking no parameters to prevent you from making this mistake. For variable number of racing coroutines, use race + launchRacer documented below.","title":"Number of racers fixed at compile time"},{"location":"modules/coroutines/#simple-example-unit-test","text":"suspend fun testCoroutinesRacing () { val result = raceOf ({ delay ( 3 ) \"slow\" }, { delay ( 0 ) \"fast\" }) assertEquals ( expected = \"fast\" , actual = result ) }","title":"Simple example (unit test):"},{"location":"modules/coroutines/#ui-code-example","text":"suspend fun awaitUserChoice ( ui : SomeUi , choices : List < Stuff > ): Stuff? = raceOf ({ ui . awaitSomeUserAction ( choices ) }, { ui . awaitDismissal () null }, { ui . showSomethingInRealtimeUntilCancelled () // Returns Nothing, will run, but never \"win\". })","title":"UI code example"},{"location":"modules/coroutines/#dynamic-racers-and-late-racers","text":"The raceOf(\u2026) function might not suit your use case if the racing coroutines need to be launched based on some conditions, that might also take some time to be evaluated. These more advanced use-cases are satisfied by the race { \u2026 } function, where you can call launchRacer { \u2026 } in its lambda. If no racing coroutines are ever launched, the race { \u2026 } function will suspend until it is cancelled.","title":"Dynamic racers and late racers"},{"location":"modules/coroutines/#example_1","text":"suspend fun awaitSomeActionTrigger ( config : SomeConfig , deviceCapabilities : HardwareSupportInfo , defaultInput : SomeInput , awaitSpecialInput : suspend () -> Unit ) { race { launchRacer { defaultInput . awaitSomeAction () } if ( deviceCapabilities . supportsSpecialInput ) { launchRacer { awaitSpecialInput () } delay ( config . delayBeforeHintMillis ) // The race lambda can suspend showHintForSpecialInput () } } }","title":"Example"},{"location":"modules/coroutines/#suspending-version-of-lazy","text":"These 3 functions provide a SuspendLazy instance: CoroutineScope.suspendLazy { \u2026 } suspendBlockingLazy { \u2026 } (uses Dispatchers.Default by default) suspendBlockingLazyIO { \u2026 } (JVM-only for now, uses Dispatchers.IO ) They can be used almost like Kotlin's lazy , but you need parentheses to get the value. Note that if an Exception or any Throwable is thrown in their initializing lambda, the SuspendLazy instance will not be recoverable, so if retry logic is needed, it must include instantiating a new SuspendLazy . If you want it to allow retries on the same instance, please open an issue and tell about your use case.","title":"Suspending version of lazy"},{"location":"modules/coroutines/#example-initializing-a-database-only-once","text":"For an app-wide remote database: val db : SomeDatabase = GlobalScope . suspendLazy { createDatabase (). also { it . connect () } // Both functions suspend } fun doStuff ( someData : SomeData ) { db (). runSomeTransaction ( someData ) } For an application-wide local database (e.g. in an Android or desktop JVM app): val db : AppDatabase = suspendBlockingLazyIO { buildDatabase () } fun doStuff ( someData : SomeData ) { db (). runSomeTransaction ( someData ) } Passing a SuspendLazy type can be handy: suspend fun doStuff ( getDb : SuspendLazy < AppDatabase > , someData : SomeData ) { val db = getDb () db . runSomeTransaction ( someData ) }","title":"Example: Initializing a database only once"},{"location":"modules/coroutines/#example-offloading-heavy-object-instantiation-or-expensive-computation","text":"Objects that need a significant amount of memory (example bitmap/images, large arrays/lists, or large/deep data structures such as possibly non trivial trees) will block the current thread while being instantiated, waiting for the CPU to find enough free memory (RAM), which might include moving lots of stuff to have the contiguous space that can be required. To avoid blocking the user interface and altering the perceived performance of the application, you need to not run such code on the main/UI thread, but offload it to another thread such as one from Dispatchers.Default . The suspendBlockingLazy { \u2026 } makes it very easy to do it right: val expensiveThing = suspendBlockingLazy { DoHeavyInstantiation () } fun doStuff ( ui : SomeUi ) { // Can run on main/UI thread. val thing = expensiveThing () // Will suspend until DoHeavyInstantiation() is done. ui . displaySomeDataNicely ( thing ) }","title":"Example: Offloading heavy object instantiation or expensive computation"},{"location":"modules/dimensions/","text":"Dimensions \u00b6 Android dp extensions for View and Context . Particularly handy when using Views DSL . Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.dimensions , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-dimensions . The dp and dip extensions functions for View and Context are exactly the same, use the naming you prefer. They convert a value in Android's dp to pixels for use in code. The overload taking an Int returns an Int , the one taking a Float returns a Float . Examples \u00b6 val minTapTargetSize = dip ( 48 ) val circleDiameter = dp ( 48f )","title":"Dimensions"},{"location":"modules/dimensions/#dimensions","text":"Android dp extensions for View and Context . Particularly handy when using Views DSL . Supported platforms: Android .","title":"Dimensions"},{"location":"modules/dimensions/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.dimensions , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-dimensions . The dp and dip extensions functions for View and Context are exactly the same, use the naming you prefer. They convert a value in Android's dp to pixels for use in code. The overload taking an Int returns an Int , the one taking a Float returns a Float .","title":"Setup"},{"location":"modules/dimensions/#examples","text":"val minTapTargetSize = dip ( 48 ) val circleDiameter = dp ( 48f )","title":"Examples"},{"location":"modules/exceptions/","text":"Exceptions \u00b6 unexpectedValue(\u2026) , unsupportedAction(\u2026) and similar functions that return Nothing . Supported platforms: Android . Setup \u00b6 This dependency is not included in any of the fun-packs , because we don't believe all apps need its content. Add it with refreshVersions : Splitties.exceptions . For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-exceptions . Content \u00b6 Here's the list of the included functions: * unexpectedValue(\u2026) (puts the value in the IllegalStateException message) * illegalArg(\u2026) (shortcut to throw IllegalArgumentException(\u2026) ) * unsupported(\u2026) (shortcut to throw UnsupportedOperationException(\u2026) ) * unsupportedAction(\u2026) (designed for unsupported Intent actions)","title":"Exceptions"},{"location":"modules/exceptions/#exceptions","text":"unexpectedValue(\u2026) , unsupportedAction(\u2026) and similar functions that return Nothing . Supported platforms: Android .","title":"Exceptions"},{"location":"modules/exceptions/#setup","text":"This dependency is not included in any of the fun-packs , because we don't believe all apps need its content. Add it with refreshVersions : Splitties.exceptions . For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-exceptions .","title":"Setup"},{"location":"modules/exceptions/#content","text":"Here's the list of the included functions: * unexpectedValue(\u2026) (puts the value in the IllegalStateException message) * illegalArg(\u2026) (shortcut to throw IllegalArgumentException(\u2026) ) * unsupported(\u2026) (shortcut to throw UnsupportedOperationException(\u2026) ) * unsupportedAction(\u2026) (designed for unsupported Intent actions)","title":"Content"},{"location":"modules/fragmentargs/","text":"Fragment Args \u00b6 Fragment arguments without ceremony thanks to delegated properties. Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.fragmentargs , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-fragmentargs . Example \u00b6 class YourFragment : Fragment () { var someRequiredId : Int by arg () var optionalArg : String? by argOrNull () var nonNullOptionalArg : String by argOrDefault ( \"\" ) var anotherNonNullOptionalArg : String by argOrElse { \"splitties rock!\" . capitalize () } private fun yourMethod () = yourCode () } fun createYourFragment ( someId : Int ): Fragment = YourFragment (). apply { someRequiredId = someId }","title":"Fragment Args"},{"location":"modules/fragmentargs/#fragment-args","text":"Fragment arguments without ceremony thanks to delegated properties. Supported platforms: Android .","title":"Fragment Args"},{"location":"modules/fragmentargs/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.fragmentargs , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-fragmentargs .","title":"Setup"},{"location":"modules/fragmentargs/#example","text":"class YourFragment : Fragment () { var someRequiredId : Int by arg () var optionalArg : String? by argOrNull () var nonNullOptionalArg : String by argOrDefault ( \"\" ) var anotherNonNullOptionalArg : String by argOrElse { \"splitties rock!\" . capitalize () } private fun yourMethod () = yourCode () } fun createYourFragment ( someId : Int ): Fragment = YourFragment (). apply { someRequiredId = someId }","title":"Example"},{"location":"modules/fragments/","text":"Fragments \u00b6 Start activities from fragments and do transactions with minimal boilerplate. Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.fragments , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-fragments . Content \u00b6 Starting Activities \u00b6 The start extension function for Context takes advantage of reified type parameters to allow you to write such code: start<AboutActivity>() . There's an optional lambda where the Intent is the receiver so you can edit it (e.g. adding flags) before the activity is started with it. The startActivity extension function for Context is designed for implicit intents. It expects the Intent action as first parameter, and takes a lambda to edit the intent further, like start . Fragment transactions \u00b6 The fragmentTransaction extension function for FragmentActivity allows to make a fragment transaction without having to write beginTransaction and the commit call repeatedly. It has two optional parameters: * now , that defaults to true so you can get the Fragment immediately after by default. * allowStateLoss that defaults to false . And the lambda is the required body of your transaction where you deal with your Fragments (e.g. adding, replacing\u2026). The addToBackStack() extension function for FragmentTransaction calls addToBackStack(null) . It effectively makes the name parameter optional.","title":"Fragments"},{"location":"modules/fragments/#fragments","text":"Start activities from fragments and do transactions with minimal boilerplate. Supported platforms: Android .","title":"Fragments"},{"location":"modules/fragments/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.fragments , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-fragments .","title":"Setup"},{"location":"modules/fragments/#content","text":"","title":"Content"},{"location":"modules/fragments/#starting-activities","text":"The start extension function for Context takes advantage of reified type parameters to allow you to write such code: start<AboutActivity>() . There's an optional lambda where the Intent is the receiver so you can edit it (e.g. adding flags) before the activity is started with it. The startActivity extension function for Context is designed for implicit intents. It expects the Intent action as first parameter, and takes a lambda to edit the intent further, like start .","title":"Starting Activities"},{"location":"modules/fragments/#fragment-transactions","text":"The fragmentTransaction extension function for FragmentActivity allows to make a fragment transaction without having to write beginTransaction and the commit call repeatedly. It has two optional parameters: * now , that defaults to true so you can get the Fragment immediately after by default. * allowStateLoss that defaults to false . And the lambda is the required body of your transaction where you deal with your Fragments (e.g. adding, replacing\u2026). The addToBackStack() extension function for FragmentTransaction calls addToBackStack(null) . It effectively makes the name parameter optional.","title":"Fragment transactions"},{"location":"modules/intents/","text":"Intents \u00b6 Transform companion object s into powerful typesafe intent specs, and create PendingIntent s the clean and easy way. Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.intents , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-intents . Table of contents \u00b6 Using companion object s as typesafe and key-safe intent specs The problem about intents in Android The solution IntentSpec interfaces IntentSpec implementations providers Using an IntentSpec IntentSpec example Creating PendingIntent s the clean and easy way Using companion object s as typesafe and key-safe intent specs \u00b6 The problem about intents in Android \u00b6 An Android component that can receive an Intent (like an Activity or a BroacastReceiver ) can expect an action, or extras. In case of an action, the string must match exactly in order to work properly. In case of an extra, the type must also match. This makes it not typesafe at all. You need to write some documentation to explain which constants to use, with which types, and you need to be sure to read the doc afterwards, to ensure you do it right. There should be a better way. The solution \u00b6 This split provides a few interfaces that your companion object s can implement using delegation so they become an intent specification, that you can use to build and Intent , start an Activity , start a Service or send a broadcast in a type safe way. IntentSpec interfaces \u00b6 The IntentSpec interface has two properties: * klass which is the class of the component * extrasSpec which is a BundleSpec (defined in the Bundle split). The ActivityIntentSpec , BroadcastReceiverIntentSpec and ServiceIntentSpec interfaces all extend the IntentSpec interface, but add a bound to the type parameter of the class. You should use them when defining the intent spec of an Activity , BroadcastReceiver or Service . IntentSpec implementations providers \u00b6 A few methods provide implementation of the interfaces mentioned above: * activitySpec * activityWithoutExtrasSpec where ExtrasSpec is Nothing * receiverSpec * receiverWithoutExtrasSpec where ExtrasSpec is Nothing * serviceSpec * serviceWithoutExtrasSpec where ExtrasSpec is Nothing They are designed to be used with by . Examples: * companion object : ActivityIntentSpec<ProductDetailsActivity, ExtrasSpec> by activitySpec(ExtrasSpec) * companion object : BroadcastReceiverIntentSpec<NotifDismissReceiver, ExtrasSpec> by receiverSpec(ExtrasSpec) Using an IntentSpec \u00b6 The intent method is an extension for IntentSpec . It takes a lambda where the receiver is the Intent . The first parameter is the companion object itself so you can access any constant or method defined in it easily. The second parameter of the lambda is optional, it is the extrasSpec. The start method is an extension for Context and for Fragment that takes the target ActivityIntentSpec as its first parameter. It then calls the intent extension function mentioned above, and the optional expected lambda has the same parameters as for intent . Finally, it calls startActivity with the created Intent . The sendBroadcast method is an extension for Context that takes the target BroadcastReceiverIntentSpec as its first parameter. It then calls the intent extension function mentioned above, and the optional expected lambda has the same parameters as for intent . Finally, it calls sendBroadcast with the created Intent . IntentSpec example \u00b6 Let's take the example shown in the Bundle README, adding an IntentSpec to it. Notice the new companion object and how we start the DemoActivity with the proper extras from the StartDemoActivity now. class DemoActivity : AppCompatActivity () { companion object : ActivityIntentSpec < DemoActivity , ExtrasSpec > by activitySpec ( ExtrasSpec ) { const val someText = \"Splitties is great!\" } object ExtrasSpec : BundleSpec () { var showGreetingToast : Boolean by bundle () // Required extra var optionalExtra : String? by bundleOrNull () // Optional extra } override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) withExtras ( ExtrasSpec ) { // Populates ExtrasSpec with actual extras if ( showGreetingToast ) toast ( android . R . string . ok ) optionalExtras ?. let { longToast ( it ) } } restOfYourCode () } } class StartDemoActivity : AppCompatActivity () { private fun someFunction ( isUserPolite : Boolean = false ) { start ( DemoActivity ) { intentSpec , extrasSpec -> // Magic happens here! extrasSpec . showGreetingToast = isUserPolite extrasSpec . optionalExtra = intentSpec . someText } } } Creating PendingIntent s the clean and easy way \u00b6 It's fair to say that the PendingIntent Android API is not designed for Kotlin, and for a reason, it has been there since API level 1, the first Android version. As a result, code using this API is not always the most readable part of a Kotlin codebase. This split provides several extension functions for Intent that return a PendingIntent : * toPendingActivity() * toPendingService() * toPendingForegroundService() , which also works before API 26 * toPendingBroadcast() and an extension for Array<Intent> : toPendingActivities() . All these functions have two optional parameters that default to zero: reqCode and flags . The toPendingActivity() and toPendingActivities() functions also have an options: Bundle? parameter that defaults to null (and is ignored below API 16).","title":"Intents"},{"location":"modules/intents/#intents","text":"Transform companion object s into powerful typesafe intent specs, and create PendingIntent s the clean and easy way. Supported platforms: Android .","title":"Intents"},{"location":"modules/intents/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.intents , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-intents .","title":"Setup"},{"location":"modules/intents/#table-of-contents","text":"Using companion object s as typesafe and key-safe intent specs The problem about intents in Android The solution IntentSpec interfaces IntentSpec implementations providers Using an IntentSpec IntentSpec example Creating PendingIntent s the clean and easy way","title":"Table of contents"},{"location":"modules/intents/#using-companion-objects-as-typesafe-and-key-safe-intent-specs","text":"","title":"Using companion objects as typesafe and key-safe intent specs"},{"location":"modules/intents/#the-problem-about-intents-in-android","text":"An Android component that can receive an Intent (like an Activity or a BroacastReceiver ) can expect an action, or extras. In case of an action, the string must match exactly in order to work properly. In case of an extra, the type must also match. This makes it not typesafe at all. You need to write some documentation to explain which constants to use, with which types, and you need to be sure to read the doc afterwards, to ensure you do it right. There should be a better way.","title":"The problem about intents in Android"},{"location":"modules/intents/#the-solution","text":"This split provides a few interfaces that your companion object s can implement using delegation so they become an intent specification, that you can use to build and Intent , start an Activity , start a Service or send a broadcast in a type safe way.","title":"The solution"},{"location":"modules/intents/#intentspec-interfaces","text":"The IntentSpec interface has two properties: * klass which is the class of the component * extrasSpec which is a BundleSpec (defined in the Bundle split). The ActivityIntentSpec , BroadcastReceiverIntentSpec and ServiceIntentSpec interfaces all extend the IntentSpec interface, but add a bound to the type parameter of the class. You should use them when defining the intent spec of an Activity , BroadcastReceiver or Service .","title":"IntentSpec interfaces"},{"location":"modules/intents/#intentspec-implementations-providers","text":"A few methods provide implementation of the interfaces mentioned above: * activitySpec * activityWithoutExtrasSpec where ExtrasSpec is Nothing * receiverSpec * receiverWithoutExtrasSpec where ExtrasSpec is Nothing * serviceSpec * serviceWithoutExtrasSpec where ExtrasSpec is Nothing They are designed to be used with by . Examples: * companion object : ActivityIntentSpec<ProductDetailsActivity, ExtrasSpec> by activitySpec(ExtrasSpec) * companion object : BroadcastReceiverIntentSpec<NotifDismissReceiver, ExtrasSpec> by receiverSpec(ExtrasSpec)","title":"IntentSpec implementations providers"},{"location":"modules/intents/#using-an-intentspec","text":"The intent method is an extension for IntentSpec . It takes a lambda where the receiver is the Intent . The first parameter is the companion object itself so you can access any constant or method defined in it easily. The second parameter of the lambda is optional, it is the extrasSpec. The start method is an extension for Context and for Fragment that takes the target ActivityIntentSpec as its first parameter. It then calls the intent extension function mentioned above, and the optional expected lambda has the same parameters as for intent . Finally, it calls startActivity with the created Intent . The sendBroadcast method is an extension for Context that takes the target BroadcastReceiverIntentSpec as its first parameter. It then calls the intent extension function mentioned above, and the optional expected lambda has the same parameters as for intent . Finally, it calls sendBroadcast with the created Intent .","title":"Using an IntentSpec"},{"location":"modules/intents/#intentspec-example","text":"Let's take the example shown in the Bundle README, adding an IntentSpec to it. Notice the new companion object and how we start the DemoActivity with the proper extras from the StartDemoActivity now. class DemoActivity : AppCompatActivity () { companion object : ActivityIntentSpec < DemoActivity , ExtrasSpec > by activitySpec ( ExtrasSpec ) { const val someText = \"Splitties is great!\" } object ExtrasSpec : BundleSpec () { var showGreetingToast : Boolean by bundle () // Required extra var optionalExtra : String? by bundleOrNull () // Optional extra } override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) withExtras ( ExtrasSpec ) { // Populates ExtrasSpec with actual extras if ( showGreetingToast ) toast ( android . R . string . ok ) optionalExtras ?. let { longToast ( it ) } } restOfYourCode () } } class StartDemoActivity : AppCompatActivity () { private fun someFunction ( isUserPolite : Boolean = false ) { start ( DemoActivity ) { intentSpec , extrasSpec -> // Magic happens here! extrasSpec . showGreetingToast = isUserPolite extrasSpec . optionalExtra = intentSpec . someText } } }","title":"IntentSpec example"},{"location":"modules/intents/#creating-pendingintents-the-clean-and-easy-way","text":"It's fair to say that the PendingIntent Android API is not designed for Kotlin, and for a reason, it has been there since API level 1, the first Android version. As a result, code using this API is not always the most readable part of a Kotlin codebase. This split provides several extension functions for Intent that return a PendingIntent : * toPendingActivity() * toPendingService() * toPendingForegroundService() , which also works before API 26 * toPendingBroadcast() and an extension for Array<Intent> : toPendingActivities() . All these functions have two optional parameters that default to zero: reqCode and flags . The toPendingActivity() and toPendingActivities() functions also have an options: Bundle? parameter that defaults to null (and is ignored below API 16).","title":"Creating PendingIntents the clean and easy way"},{"location":"modules/lifecycle-coroutines/","text":"Lifecycle Coroutines \u00b6 Coroutines integration with Lifecycle s. Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.lifecycleCoroutines , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-lifecycle-coroutines . Note: This split exposes its dependency on AndroidX Lifecycle runtime KTX , which notably brings lifecycleScope for LifecycleOwner ( Activity , Fragment , LifecycleService \u2026) and coroutineScope for Lifecycle . See the documentation of Android Lifecycle here . Extension functions: Name Description Lifecycle.awaitResumed A suspending function that returns/resumes as soon as the state of the Lifecycle is resumed. Lifecycle.awaitStarted A suspending function that returns/resumes as soon as the state of the Lifecycle is at least started. Lifecycle.awaitCreated A suspending function that returns/resumes as soon as the state of the Lifecycle is at least created. Lifecycle.awaitState A suspending function that returns/resumes as soon as the state of the Lifecycle is at least the passed state. Lifecycle.isStartedFlow Returns a Flow whose value is true while the lifecycle is started. An experimental overload takes a timeout. Lifecycle.isResumedFlow Returns a Flow whose value is true while the lifecycle is resumed. An experimental overload takes a timeout. Flow.whileStarted Returns a Flow that emits the values from the receiver only while the passed Lifecycle is in the started state. Lifecycle.stateFlow Returns a Flow whose value reflects the current Lifecycle.STATE . Lifecycle.createJob A job that is active while the state is at least the passed one. Lifecycle.createScope A scope that dispatches on Android Main thread and is active while the state is at least the passed one. Example \u00b6 class MainActivity : AppCompatActivity () { override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) lifecycleScope . launch { someSuspendFunction () lifecycle . awaitResumed () showSomethingWithAnimation () } lifecycleScope . launch { someValuesToDisplayWhileVisible (). whileStarted ( lifecycle ). collectLatest { ui . displayLatestValue ( it ) } } isStartedFlow ( 5. seconds ). transformLatest { isStarted -> if ( isStarted ) { emitAll ( someDataUpdates ()) } }. onEach { dataSnapshot -> ui . updateLatestData ( dataSnapshot ) }. launchIn ( lifecycleScope ) lifecycleScope . launch { isResumedFlow (). collectLatest { isResumed -> if ( isResumed ) { stats . usageTracker . countTimeSpentUntilCancelled () } } } } override fun onStart () { super . onStart () val startedScope = lifecycle . createScope ( activeWhile = Lifecycle . State . STARTED ) startedScope . launch { aCancellableSuspendFunction () yetAnotherCancellableSuspendFunction () } startedScope . aMethodThatWillLaunchSomeCoroutines () } }","title":"Lifecycle Coroutines"},{"location":"modules/lifecycle-coroutines/#lifecycle-coroutines","text":"Coroutines integration with Lifecycle s. Supported platforms: Android .","title":"Lifecycle Coroutines"},{"location":"modules/lifecycle-coroutines/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.lifecycleCoroutines , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-lifecycle-coroutines . Note: This split exposes its dependency on AndroidX Lifecycle runtime KTX , which notably brings lifecycleScope for LifecycleOwner ( Activity , Fragment , LifecycleService \u2026) and coroutineScope for Lifecycle . See the documentation of Android Lifecycle here . Extension functions: Name Description Lifecycle.awaitResumed A suspending function that returns/resumes as soon as the state of the Lifecycle is resumed. Lifecycle.awaitStarted A suspending function that returns/resumes as soon as the state of the Lifecycle is at least started. Lifecycle.awaitCreated A suspending function that returns/resumes as soon as the state of the Lifecycle is at least created. Lifecycle.awaitState A suspending function that returns/resumes as soon as the state of the Lifecycle is at least the passed state. Lifecycle.isStartedFlow Returns a Flow whose value is true while the lifecycle is started. An experimental overload takes a timeout. Lifecycle.isResumedFlow Returns a Flow whose value is true while the lifecycle is resumed. An experimental overload takes a timeout. Flow.whileStarted Returns a Flow that emits the values from the receiver only while the passed Lifecycle is in the started state. Lifecycle.stateFlow Returns a Flow whose value reflects the current Lifecycle.STATE . Lifecycle.createJob A job that is active while the state is at least the passed one. Lifecycle.createScope A scope that dispatches on Android Main thread and is active while the state is at least the passed one.","title":"Setup"},{"location":"modules/lifecycle-coroutines/#example","text":"class MainActivity : AppCompatActivity () { override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) lifecycleScope . launch { someSuspendFunction () lifecycle . awaitResumed () showSomethingWithAnimation () } lifecycleScope . launch { someValuesToDisplayWhileVisible (). whileStarted ( lifecycle ). collectLatest { ui . displayLatestValue ( it ) } } isStartedFlow ( 5. seconds ). transformLatest { isStarted -> if ( isStarted ) { emitAll ( someDataUpdates ()) } }. onEach { dataSnapshot -> ui . updateLatestData ( dataSnapshot ) }. launchIn ( lifecycleScope ) lifecycleScope . launch { isResumedFlow (). collectLatest { isResumed -> if ( isResumed ) { stats . usageTracker . countTimeSpentUntilCancelled () } } } } override fun onStart () { super . onStart () val startedScope = lifecycle . createScope ( activeWhile = Lifecycle . State . STARTED ) startedScope . launch { aCancellableSuspendFunction () yetAnotherCancellableSuspendFunction () } startedScope . aMethodThatWillLaunchSomeCoroutines () } }","title":"Example"},{"location":"modules/mainhandler/","text":"Main Handler \u00b6 Top-level mainHandler property to stop allocating multiple Handler s for main Looper . Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.mainhandler , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-mainhandler . Content \u00b6 Some Android APIs require you to pass a Handler instance. For the cases where you want to pass one that dispatches onto the main thread, instead of creating another instance, you can reuse mainHandler , saving allocations, and characters to type. Note that mainHandler is async, which means there's no vSync delays. If you need a sync Handler , you can simply use mainHandlerSync , also provided in this split.","title":"Main Handler"},{"location":"modules/mainhandler/#main-handler","text":"Top-level mainHandler property to stop allocating multiple Handler s for main Looper . Supported platforms: Android .","title":"Main Handler"},{"location":"modules/mainhandler/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.mainhandler , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-mainhandler .","title":"Setup"},{"location":"modules/mainhandler/#content","text":"Some Android APIs require you to pass a Handler instance. For the cases where you want to pass one that dispatches onto the main thread, instead of creating another instance, you can reuse mainHandler , saving allocations, and characters to type. Note that mainHandler is async, which means there's no vSync delays. If you need a sync Handler , you can simply use mainHandlerSync , also provided in this split.","title":"Content"},{"location":"modules/mainthread/","text":"Main Thread \u00b6 Properties and precondition checkers related to Android, iOS and macOS main thread. Supported platforms: macOS (x64), iOS (arm32, arm64 & x64), Android , JS . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.mainthread , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-mainthread . Content \u00b6 This split provides several properties related to main Thread and 2 precondition checkers. Here's the list: mainLooper : Shortcut to Looper.getMainLooper()!! with caching (Android only). mainThread : Shortcut to Looper.getMainLooper()!!.thread with caching (Android only). isMainThread : Boolean property that is true if the current Thread is the main Thread (always true in JS). checkMainThread() : Throws an IllegalStateException if not run on the main Thread. checkNotMainThread() : Throws an IllegalStateException if run on the main Thread (always throws in JS).","title":"Main Thread"},{"location":"modules/mainthread/#main-thread","text":"Properties and precondition checkers related to Android, iOS and macOS main thread. Supported platforms: macOS (x64), iOS (arm32, arm64 & x64), Android , JS .","title":"Main Thread"},{"location":"modules/mainthread/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.mainthread , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-mainthread .","title":"Setup"},{"location":"modules/mainthread/#content","text":"This split provides several properties related to main Thread and 2 precondition checkers. Here's the list: mainLooper : Shortcut to Looper.getMainLooper()!! with caching (Android only). mainThread : Shortcut to Looper.getMainLooper()!!.thread with caching (Android only). isMainThread : Boolean property that is true if the current Thread is the main Thread (always true in JS). checkMainThread() : Throws an IllegalStateException if not run on the main Thread. checkNotMainThread() : Throws an IllegalStateException if run on the main Thread (always throws in JS).","title":"Content"},{"location":"modules/material-colors/","text":"Material Colors \u00b6 2014 Material Design color palettes as color resources. Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.materialColors , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-material-colors . Content \u00b6 This split contains color resources for all the colors referenced in the Material Design guidelines before 2018 change (which added a material palette generator). Examples: \u00b6 Red 500: R.color.red_500 / @color/red_500 Cyan accent 400: R.color.cyan_a400 / @color/cyan_a400","title":"Material Colors"},{"location":"modules/material-colors/#material-colors","text":"2014 Material Design color palettes as color resources. Supported platforms: Android .","title":"Material Colors"},{"location":"modules/material-colors/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.materialColors , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-material-colors .","title":"Setup"},{"location":"modules/material-colors/#content","text":"This split contains color resources for all the colors referenced in the Material Design guidelines before 2018 change (which added a material palette generator).","title":"Content"},{"location":"modules/material-colors/#examples","text":"Red 500: R.color.red_500 / @color/red_500 Cyan accent 400: R.color.cyan_a400 / @color/cyan_a400","title":"Examples:"},{"location":"modules/material-lists/","text":"Material Lists \u00b6 List item Views implementing Material Design guidelines (perfect for usage in a RecyclerView ). Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.materialLists , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-material-lists . Content \u00b6 This split provides Android View s that are the implementation for most of the lists components and the lists controls from Material Design guidelines. Here's the list of the list item View implementations currently included in this module: * IconOneLineListItem * IconTwoLinesListItem * IconTwoLinesSwitchListItem * IconTwoLinesCheckBoxListItem * SwitchTwoLinesIconListItem Feel free to open an issue if you need the implementation of a list item that is not in this library yet, or feel one can be improved. If so, pull requests are welcome as long as the code style is kept intact (you can debate about it in an issue if you feel there's room for improvement). See an example in the sample module .","title":"Material Lists"},{"location":"modules/material-lists/#material-lists","text":"List item Views implementing Material Design guidelines (perfect for usage in a RecyclerView ). Supported platforms: Android .","title":"Material Lists"},{"location":"modules/material-lists/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.materialLists , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-material-lists .","title":"Setup"},{"location":"modules/material-lists/#content","text":"This split provides Android View s that are the implementation for most of the lists components and the lists controls from Material Design guidelines. Here's the list of the list item View implementations currently included in this module: * IconOneLineListItem * IconTwoLinesListItem * IconTwoLinesSwitchListItem * IconTwoLinesCheckBoxListItem * SwitchTwoLinesIconListItem Feel free to open an issue if you need the implementation of a list item that is not in this library yet, or feel one can be improved. If so, pull requests are welcome as long as the code style is kept intact (you can debate about it in an issue if you feel there's room for improvement). See an example in the sample module .","title":"Content"},{"location":"modules/permissions/","text":"Permissions \u00b6 Request runtime permissions without polluting your codebase. Supported platforms: Android . The most straightforward way to request runtime permissions on Android is not\u2026 straightforward, and that's why there are so many libraries that attempt to make it easier. If you don't use any library, you end up breaking control flow with all permissions request results coming in a method you must override from your Activity or Fragment as a couple of two arrays. That means a lot of code to write, and a lot of ways to mess up. Splitties Permissions leverages suspending functions, and DialogFragment s under the hood, to make requesting a permission and handling all the result cases a single function call . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.permissions , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-permissions . Included functions \u00b6 Top-level functions: Name Description hasPermission Returns true if the passed runtime permission is granted to the current app. requestPermission Requests the passed permission if needed and returns the result. ensurePermission Requests the passed permission, taking the user to app details in settings if needed and returns only once granted. ensureAllPermissions Requests the passed permissions, taking the user to app details in settings if needed and returns only once all are granted. Extension functions: Name Description Fragment.requestPermission Requests the passed permission if needed and returns the result. FragmentActivity.requestPermission Requests the passed permission if needed and returns the result. Fragment.ensurePermission Requests the passed permission, taking the user to app details in settings if needed and returns only once granted. Fragment.ensureAllPermissions Requests the passed permissions, taking the user to app details in settings if needed and returns only once all are granted. FragmentActivity.ensurePermission Requests the passed permission, taking the user to app details in settings if needed and returns only once granted. FragmentActivity.ensureAllPermissions Requests the passed permissions, taking the user to app details in settings if needed and returns only once all are granted. Usage \u00b6 The requestPermission is straightforward to use, you just have to write a when expression for its result, but it doesn't help you handling the 2 following cases: - You need to ask again after showing the rationale - You need to take the user to your app details in the settings because they checked the do not ask again checkbox. That's where the ensurePermission comes handy. It takes several parameters to handle showing the rationale, and will automatically open the settings pointing to your app details if the user checked the do not ask again checkbox. You can see how to easily implement a higher-level overload that suits the UX you want to provide for permissions requests with that example , and you can see how it is used in PermissionsExampleActivity .","title":"Permissions"},{"location":"modules/permissions/#permissions","text":"Request runtime permissions without polluting your codebase. Supported platforms: Android . The most straightforward way to request runtime permissions on Android is not\u2026 straightforward, and that's why there are so many libraries that attempt to make it easier. If you don't use any library, you end up breaking control flow with all permissions request results coming in a method you must override from your Activity or Fragment as a couple of two arrays. That means a lot of code to write, and a lot of ways to mess up. Splitties Permissions leverages suspending functions, and DialogFragment s under the hood, to make requesting a permission and handling all the result cases a single function call .","title":"Permissions"},{"location":"modules/permissions/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.permissions , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-permissions .","title":"Setup"},{"location":"modules/permissions/#included-functions","text":"Top-level functions: Name Description hasPermission Returns true if the passed runtime permission is granted to the current app. requestPermission Requests the passed permission if needed and returns the result. ensurePermission Requests the passed permission, taking the user to app details in settings if needed and returns only once granted. ensureAllPermissions Requests the passed permissions, taking the user to app details in settings if needed and returns only once all are granted. Extension functions: Name Description Fragment.requestPermission Requests the passed permission if needed and returns the result. FragmentActivity.requestPermission Requests the passed permission if needed and returns the result. Fragment.ensurePermission Requests the passed permission, taking the user to app details in settings if needed and returns only once granted. Fragment.ensureAllPermissions Requests the passed permissions, taking the user to app details in settings if needed and returns only once all are granted. FragmentActivity.ensurePermission Requests the passed permission, taking the user to app details in settings if needed and returns only once granted. FragmentActivity.ensureAllPermissions Requests the passed permissions, taking the user to app details in settings if needed and returns only once all are granted.","title":"Included functions"},{"location":"modules/permissions/#usage","text":"The requestPermission is straightforward to use, you just have to write a when expression for its result, but it doesn't help you handling the 2 following cases: - You need to ask again after showing the rationale - You need to take the user to your app details in the settings because they checked the do not ask again checkbox. That's where the ensurePermission comes handy. It takes several parameters to handle showing the rationale, and will automatically open the settings pointing to your app details if the user checked the do not ask again checkbox. You can see how to easily implement a higher-level overload that suits the UX you want to provide for permissions requests with that example , and you can see how it is used in PermissionsExampleActivity .","title":"Usage"},{"location":"modules/preferences/","text":"Preferences \u00b6 Property syntax for Android's SharedPreferences / DataStore or iOS/macOS NSUserDefaults . Supported platforms: macOS (x64), iOS (arm32, arm64 & x64), Android . This library uses Kotlin's property delegation to make using SharedPreferences and DataStore<Preferences> as easy as accessing a property on an object, and provides an NSUserDefaults backed implementation for macOS and iOS. On Android, it relies on the appCtx module of this library to allow usage in object , and can support storage on device encrypted storage for devices supporting Direct Boot. See the source code for more information. Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.preferences , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-preferences . Table of contents \u00b6 Defining the preferences properties in an object Why object and not class ? Loading the preferences without blocking the main thread Using AndroidX DataStore instead of SharedPreferences under the hood Defining the preferences properties in an object \u00b6 Define your preferences in an object that extends splitties.preferences.Preferences , like in the example below: import splitties.preferences.Preferences object GamePreferences : Preferences ( \"gameState\" ) { var magicNumber by intPref ( \"magicNumber\" , defaultValue = 0 ) var currentLevel by intPref ( \"currentLevel\" , 1 ) var bossesFought by intPref ( \"bossBattleVictories\" , 0 ) var lastTimePlayed by longPref ( \"lastSessionTime\" , 0L ) val pseudoFlow : Flow < String > var pseudo by stringPref ( \"playerPseudo\" , \"Player 1\" ). also { pseudoFlow = it . valueFlow () } val favoriteCharacterFlow : Flow < String? > var favoriteCharacter by stringOrNullPref ( \"favoriteCharacter\" ). also { favoriteCharacterFlow = it . valueFlow () } } Then just use the properties: fun setResponseOfTheUltimateQuestionOfLifeTheUniverseAndEverything () { GamePreferences . magicNumber = 42 } fun doSomeMagic () { toast ( \"Magic: ${ GamePreferences . magicNumber } !\" ) } fun resetProgress () { GamePreferences . edit { // Batch edit currentLevel = 1 bossesFought = 0 } } The supported types are: * Boolean * Int * Float * Long * String * String? * Set<String> * Set<String>? For default SharedPreferences , make an object that extends DefaultPreferences instead of Preferences . Note that for better encapsulation, you might want to keep the mutable delegated properties private in some cases, and expose functions and flows instead. Why object and not class ? \u00b6 Unless you use coroutines (read more about this in next section just below), a class instead of an object is not recommended because it would mean you can instantiate it multiple times, while the underlying preferences xml file is cached for the rest of your app's process lifetime once loaded, so in a class you'd be allocating the delegates more times than needed, leading to an additional, unneeded, small pressure on the garbage collector. However, you may make an abstract subclass of Preferences for specific use cases where adding logic to base Preferences or sharing some properties may be desirable. (If you do, please open an issue to tell us about this use case. It may become an example shown here.) Loading the preferences without blocking the main thread \u00b6 Note that this feature is currently only supported on Android. Feel free to open an issue if you want it on other platforms. The object approach described above has several advantages, one of the most significant being ease of use anywhere in your app, but that also means you can easily access it from the main thread, and the first time you access the object, the underlying xml file where the preferences are stored is loaded, which may block the main thread for longer that you would want, possibly dropping a few frames. With coroutines, it's easy to offload something on another thread, and this split embraces this capability. Let's see a modified version of the GamePreferences described above, before passing in review each change. import splitties.preferences.SuspendPrefsAccessor import splitties.preferences.Preferences class GamePreferences private constructor () : Preferences ( \"gameState\" ) { companion object : SuspendPrefsAccessor < GamePreferences > ( :: GamePreferences ) var magicNumber by intPref ( \"magicNumber\" , defaultValue = 0 ) var currentLevel by intPref ( \"currentLevel\" , 1 ) var bossesFought by intPref ( \"bossBattleVictories\" , 0 ) var lastTimePlayed by longPref ( \"lastSessionTime\" , 0L ) val pseudoFlow : Flow < String > var pseudo by stringPref ( \"playerPseudo\" , \"Player 1\" ). also { pseudoFlow = it . valueFlow () } val favoriteCharacterFlow : Flow < String? > var favoriteCharacter by stringOrNullPref ( \"favoriteCharacter\" ). also { favoriteCharacterFlow = it . valueFlow () } } Here are all the changes: 1. We moved from object to class . 2. We added a private constructor() . 3. We added a companion object that extends the SuspendPrefsAccessor abstract class and calls its constructor with a reference to the constructor. With this change, we can no longer access the GamePreferences singleton directly from anywhere\u2026 unless we are in a coroutine! From any suspend function, you just have to call GamePreferences() like you were calling a constructor, but in reality, it is a function call that suspends while loading the preferences for the first time in process life in Dispatchers.IO . If the preferences have already been loaded, it immediately returns the now instantiated singleton. If you have non suspending functions that would need to access the preferences, you have two options: pass your Preferences subclass as a parameter, or make it a suspend function. Using AndroidX DataStore instead of SharedPreferences under the hood \u00b6 Android's SharedPreferences has one performance drawback: it can perform disk I/O on the main thread on its own when the onStop callback of an Activity is called. The only way to ensure your app will not be affected by the potential ANRs (Application Not Responding) it can cause is to replace it with something else. The AndroidX team made DataStore just for that, but its API is not compatible, which would require significant code changes in host projects. If you use this (Splitties Preferences) however, all the hard work has been done for you. There are just 3 quick steps to perform to use DataStore instead of SharedPreferences: Make sure you use SuspendPrefsAccessor , as described in the section above (not doing so will crash on first access). Extend DataStorePreferences instead of Preferences . Opt-in by adding @OptIn(DataStorePreferencesPreview::class) to your class. Once you're done, test your app to make sure it still works fine. Data migration is automatically done if you're moving from SharedPreferences and keep the same name. If you were using DefaultPreferences , you can pass null to name . Be sure that there's only one class that uses the same name, or DataStore will throw. Finally, note that direct boot (aka. deviceProtectedStorage) is not supported yet, but is being considered. Add a \ud83d\udc4d on this issue to raise the priority.","title":"Preferences"},{"location":"modules/preferences/#preferences","text":"Property syntax for Android's SharedPreferences / DataStore or iOS/macOS NSUserDefaults . Supported platforms: macOS (x64), iOS (arm32, arm64 & x64), Android . This library uses Kotlin's property delegation to make using SharedPreferences and DataStore<Preferences> as easy as accessing a property on an object, and provides an NSUserDefaults backed implementation for macOS and iOS. On Android, it relies on the appCtx module of this library to allow usage in object , and can support storage on device encrypted storage for devices supporting Direct Boot. See the source code for more information.","title":"Preferences"},{"location":"modules/preferences/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.preferences , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-preferences .","title":"Setup"},{"location":"modules/preferences/#table-of-contents","text":"Defining the preferences properties in an object Why object and not class ? Loading the preferences without blocking the main thread Using AndroidX DataStore instead of SharedPreferences under the hood","title":"Table of contents"},{"location":"modules/preferences/#defining-the-preferences-properties-in-an-object","text":"Define your preferences in an object that extends splitties.preferences.Preferences , like in the example below: import splitties.preferences.Preferences object GamePreferences : Preferences ( \"gameState\" ) { var magicNumber by intPref ( \"magicNumber\" , defaultValue = 0 ) var currentLevel by intPref ( \"currentLevel\" , 1 ) var bossesFought by intPref ( \"bossBattleVictories\" , 0 ) var lastTimePlayed by longPref ( \"lastSessionTime\" , 0L ) val pseudoFlow : Flow < String > var pseudo by stringPref ( \"playerPseudo\" , \"Player 1\" ). also { pseudoFlow = it . valueFlow () } val favoriteCharacterFlow : Flow < String? > var favoriteCharacter by stringOrNullPref ( \"favoriteCharacter\" ). also { favoriteCharacterFlow = it . valueFlow () } } Then just use the properties: fun setResponseOfTheUltimateQuestionOfLifeTheUniverseAndEverything () { GamePreferences . magicNumber = 42 } fun doSomeMagic () { toast ( \"Magic: ${ GamePreferences . magicNumber } !\" ) } fun resetProgress () { GamePreferences . edit { // Batch edit currentLevel = 1 bossesFought = 0 } } The supported types are: * Boolean * Int * Float * Long * String * String? * Set<String> * Set<String>? For default SharedPreferences , make an object that extends DefaultPreferences instead of Preferences . Note that for better encapsulation, you might want to keep the mutable delegated properties private in some cases, and expose functions and flows instead.","title":"Defining the preferences properties in an object"},{"location":"modules/preferences/#why-object-and-not-class","text":"Unless you use coroutines (read more about this in next section just below), a class instead of an object is not recommended because it would mean you can instantiate it multiple times, while the underlying preferences xml file is cached for the rest of your app's process lifetime once loaded, so in a class you'd be allocating the delegates more times than needed, leading to an additional, unneeded, small pressure on the garbage collector. However, you may make an abstract subclass of Preferences for specific use cases where adding logic to base Preferences or sharing some properties may be desirable. (If you do, please open an issue to tell us about this use case. It may become an example shown here.)","title":"Why object and not class?"},{"location":"modules/preferences/#loading-the-preferences-without-blocking-the-main-thread","text":"Note that this feature is currently only supported on Android. Feel free to open an issue if you want it on other platforms. The object approach described above has several advantages, one of the most significant being ease of use anywhere in your app, but that also means you can easily access it from the main thread, and the first time you access the object, the underlying xml file where the preferences are stored is loaded, which may block the main thread for longer that you would want, possibly dropping a few frames. With coroutines, it's easy to offload something on another thread, and this split embraces this capability. Let's see a modified version of the GamePreferences described above, before passing in review each change. import splitties.preferences.SuspendPrefsAccessor import splitties.preferences.Preferences class GamePreferences private constructor () : Preferences ( \"gameState\" ) { companion object : SuspendPrefsAccessor < GamePreferences > ( :: GamePreferences ) var magicNumber by intPref ( \"magicNumber\" , defaultValue = 0 ) var currentLevel by intPref ( \"currentLevel\" , 1 ) var bossesFought by intPref ( \"bossBattleVictories\" , 0 ) var lastTimePlayed by longPref ( \"lastSessionTime\" , 0L ) val pseudoFlow : Flow < String > var pseudo by stringPref ( \"playerPseudo\" , \"Player 1\" ). also { pseudoFlow = it . valueFlow () } val favoriteCharacterFlow : Flow < String? > var favoriteCharacter by stringOrNullPref ( \"favoriteCharacter\" ). also { favoriteCharacterFlow = it . valueFlow () } } Here are all the changes: 1. We moved from object to class . 2. We added a private constructor() . 3. We added a companion object that extends the SuspendPrefsAccessor abstract class and calls its constructor with a reference to the constructor. With this change, we can no longer access the GamePreferences singleton directly from anywhere\u2026 unless we are in a coroutine! From any suspend function, you just have to call GamePreferences() like you were calling a constructor, but in reality, it is a function call that suspends while loading the preferences for the first time in process life in Dispatchers.IO . If the preferences have already been loaded, it immediately returns the now instantiated singleton. If you have non suspending functions that would need to access the preferences, you have two options: pass your Preferences subclass as a parameter, or make it a suspend function.","title":"Loading the preferences without blocking the main thread"},{"location":"modules/preferences/#using-androidx-datastore-instead-of-sharedpreferences-under-the-hood","text":"Android's SharedPreferences has one performance drawback: it can perform disk I/O on the main thread on its own when the onStop callback of an Activity is called. The only way to ensure your app will not be affected by the potential ANRs (Application Not Responding) it can cause is to replace it with something else. The AndroidX team made DataStore just for that, but its API is not compatible, which would require significant code changes in host projects. If you use this (Splitties Preferences) however, all the hard work has been done for you. There are just 3 quick steps to perform to use DataStore instead of SharedPreferences: Make sure you use SuspendPrefsAccessor , as described in the section above (not doing so will crash on first access). Extend DataStorePreferences instead of Preferences . Opt-in by adding @OptIn(DataStorePreferencesPreview::class) to your class. Once you're done, test your app to make sure it still works fine. Data migration is automatically done if you're moving from SharedPreferences and keep the same name. If you were using DefaultPreferences , you can pass null to name . Be sure that there's only one class that uses the same name, or DataStore will throw. Finally, note that direct boot (aka. deviceProtectedStorage) is not supported yet, but is being considered. Add a \ud83d\udc4d on this issue to raise the priority.","title":"Using AndroidX DataStore instead of SharedPreferences under the hood"},{"location":"modules/resources/","text":"Resources \u00b6 Extensions to get resources like strings, colors or drawables easily, with support for themed attributes. Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.resources , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-resources . Content \u00b6 All the extensions of this module are currently available on Context , Fragment and View types. Each one also has an app prefixed version (e.g. appColor(\u2026) ) that is available everywhere but only returns the resources using the application Context, which means they will not use the theme of the current Activity. Colors \u00b6 color(\u2026) takes a color resource id and returns a color Int colorSL(\u2026) takes a color resource id and returns a ColorStateList styledColor(\u2026) takes a color theme attribute and returns a Int styledColorSL(\u2026) takes a color theme attribute and returns a ColorStateList Example \u00b6 val brandPrimaryColor = color ( R . color . brand_primary ) val accentColor = styledColor ( R . attr . colorAccent ) Dimensions \u00b6 dimen(\u2026) takes a dimension resource id and returns its Float value dimenPxSize(\u2026) takes a dimension resource id and returns its rounded Int value dimenPxOffset(\u2026) takes a dimension resource id and returns its truncated Int value Like for colors , there are styled prefixed versions that take a theme attribute. Drawables \u00b6 drawable(\u2026) takes a drawable resource id and returns a Drawable? styledDrawable(\u2026) takes a drawable theme attribute and returns a Drawable? Primitives \u00b6 bool(\u2026) takes a boolean resource id and returns its Boolean value int(\u2026) takes an integer resource id and returns its Int value intArray(\u2026) takes an integer array resource id and returns an IntArray There are styledBool and styledInt that take a theme attribute. Text \u00b6 txt(\u2026) takes a string resource id and returns a CharSequence str(\u2026) takes a string resource id and returns a String . There's also optional format arguments. qtyTxt(\u2026) (for plurals) returns a CharSequence qtyStr(\u2026) (for plurals) returns a String . There's also optional format arguments. txtArray(\u2026) takes an array resource id and returns an Array<out CharSequence> strArray(\u2026) takes an array resource id and returns an Array<String> styledTxt(\u2026) takes a string theme attribute and returns a CharSequence? styledStr(\u2026) takes a string theme attribute and returns a String? There's also optional format arguments. styledTxtArray(\u2026) takes an array theme attribute and returns an Array<out CharSequence>? Any resource type \u00b6 The resolveThemeAttribute extension function for Context takes a resource id of type R.attr and returns its corresponding resource id as resolved from the current theme in the Context . That means it won't work with theme attributes whose corresponding values in the given theme are declared inline (and unlike the styledXxx functions which support this case).","title":"Resources"},{"location":"modules/resources/#resources","text":"Extensions to get resources like strings, colors or drawables easily, with support for themed attributes. Supported platforms: Android .","title":"Resources"},{"location":"modules/resources/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.resources , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-resources .","title":"Setup"},{"location":"modules/resources/#content","text":"All the extensions of this module are currently available on Context , Fragment and View types. Each one also has an app prefixed version (e.g. appColor(\u2026) ) that is available everywhere but only returns the resources using the application Context, which means they will not use the theme of the current Activity.","title":"Content"},{"location":"modules/resources/#colors","text":"color(\u2026) takes a color resource id and returns a color Int colorSL(\u2026) takes a color resource id and returns a ColorStateList styledColor(\u2026) takes a color theme attribute and returns a Int styledColorSL(\u2026) takes a color theme attribute and returns a ColorStateList","title":"Colors"},{"location":"modules/resources/#example","text":"val brandPrimaryColor = color ( R . color . brand_primary ) val accentColor = styledColor ( R . attr . colorAccent )","title":"Example"},{"location":"modules/resources/#dimensions","text":"dimen(\u2026) takes a dimension resource id and returns its Float value dimenPxSize(\u2026) takes a dimension resource id and returns its rounded Int value dimenPxOffset(\u2026) takes a dimension resource id and returns its truncated Int value Like for colors , there are styled prefixed versions that take a theme attribute.","title":"Dimensions"},{"location":"modules/resources/#drawables","text":"drawable(\u2026) takes a drawable resource id and returns a Drawable? styledDrawable(\u2026) takes a drawable theme attribute and returns a Drawable?","title":"Drawables"},{"location":"modules/resources/#primitives","text":"bool(\u2026) takes a boolean resource id and returns its Boolean value int(\u2026) takes an integer resource id and returns its Int value intArray(\u2026) takes an integer array resource id and returns an IntArray There are styledBool and styledInt that take a theme attribute.","title":"Primitives"},{"location":"modules/resources/#text","text":"txt(\u2026) takes a string resource id and returns a CharSequence str(\u2026) takes a string resource id and returns a String . There's also optional format arguments. qtyTxt(\u2026) (for plurals) returns a CharSequence qtyStr(\u2026) (for plurals) returns a String . There's also optional format arguments. txtArray(\u2026) takes an array resource id and returns an Array<out CharSequence> strArray(\u2026) takes an array resource id and returns an Array<String> styledTxt(\u2026) takes a string theme attribute and returns a CharSequence? styledStr(\u2026) takes a string theme attribute and returns a String? There's also optional format arguments. styledTxtArray(\u2026) takes an array theme attribute and returns an Array<out CharSequence>?","title":"Text"},{"location":"modules/resources/#any-resource-type","text":"The resolveThemeAttribute extension function for Context takes a resource id of type R.attr and returns its corresponding resource id as resolved from the current theme in the Context . That means it won't work with theme attributes whose corresponding values in the given theme are declared inline (and unlike the styledXxx functions which support this case).","title":"Any resource type"},{"location":"modules/snackbar/","text":"Snackbar \u00b6 Grab a snack without ceremony with snack(\u2026) and longSnack(\u2026) Supported platforms: Android . This split provides extensions to show a Snackbar , boilerplate free. It also has a small extension functions based DSL to add an action and execute action on dismiss. Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.snackbar , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-snackbar . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.mainhandler , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-mainhandler . Usage \u00b6 On a CoordinatorLayout or any other View , call snack(\u2026) , longSnack(\u2026) (if you're really hungry, for example), or snackForever(\u2026) for an indefinite duration, with a string resource id, or a CharSequence . You can add optional braces to access the Snackbar instance before it is shown, so you can add an action (using action(\u2026) { \u2026 } ) and add callback for dismissal (using onDismiss(\u2026) ). Note that snackbar(\u2026) , longSnack(\u2026) and snackForever(\u2026) return the created Snackbar instance. That means you can as well add onDismiss(\u2026) on the result of the call instead of inside the optional inline lambda.","title":"Snackbar"},{"location":"modules/snackbar/#snackbar","text":"Grab a snack without ceremony with snack(\u2026) and longSnack(\u2026) Supported platforms: Android . This split provides extensions to show a Snackbar , boilerplate free. It also has a small extension functions based DSL to add an action and execute action on dismiss.","title":"Snackbar"},{"location":"modules/snackbar/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.snackbar , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-snackbar .","title":"Setup"},{"location":"modules/snackbar/#setup_1","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.mainhandler , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-mainhandler .","title":"Setup"},{"location":"modules/snackbar/#usage","text":"On a CoordinatorLayout or any other View , call snack(\u2026) , longSnack(\u2026) (if you're really hungry, for example), or snackForever(\u2026) for an indefinite duration, with a string resource id, or a CharSequence . You can add optional braces to access the Snackbar instance before it is shown, so you can add an action (using action(\u2026) { \u2026 } ) and add callback for dismissal (using onDismiss(\u2026) ). Note that snackbar(\u2026) , longSnack(\u2026) and snackForever(\u2026) return the created Snackbar instance. That means you can as well add onDismiss(\u2026) on the result of the call instead of inside the optional inline lambda.","title":"Usage"},{"location":"modules/stetho-init/","text":"Stetho Init \u00b6 Have Stetho for your debug builds, without writing any code! Supported platforms: Android . This library automatically initializes Stetho (it's relying on AndroidX App Startup). You just have to include the dependency on your debug build and voil\u00e0! Setup \u00b6 Add the dependency to your debug build like in the example below. Provided you have refreshVersions added to the project: debugImplementation(Splitties.stethoInit) Or with full maven coordinates: debugImplementation ( \"com.louiscad.splitties:splitties-stetho-init:$splitties_version\" ) Usage \u00b6 Assuming your Android device is visible from adb on your computer, you can now navigate to chrome://inspect to see your updated debug app in Chrome Dev Tools, no further configuration required.","title":"Stetho init"},{"location":"modules/stetho-init/#stetho-init","text":"Have Stetho for your debug builds, without writing any code! Supported platforms: Android . This library automatically initializes Stetho (it's relying on AndroidX App Startup). You just have to include the dependency on your debug build and voil\u00e0!","title":"Stetho Init"},{"location":"modules/stetho-init/#setup","text":"Add the dependency to your debug build like in the example below. Provided you have refreshVersions added to the project: debugImplementation(Splitties.stethoInit) Or with full maven coordinates: debugImplementation ( \"com.louiscad.splitties:splitties-stetho-init:$splitties_version\" )","title":"Setup"},{"location":"modules/stetho-init/#usage","text":"Assuming your Android device is visible from adb on your computer, you can now navigate to chrome://inspect to see your updated debug app in Chrome Dev Tools, no further configuration required.","title":"Usage"},{"location":"modules/systemservices/","text":"System Services \u00b6 No more context.getSystemService(NAME_OF_SERVICE) as NameOfManager . Supported platforms: Android . This library contains all the Android System Services as of API 29. It allows accessing them with a simple property. Most System Services use the application Context and are available anywhere in the code of your app, but some that can vary depending on the Context (like LayoutInflater or WindowManager ) are extensions on Context , View or AccessibilityService . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.systemservices , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-systemservices . Example \u00b6 Before: fun performSomeVibration ( vibe : VibrationEffect ) { val vibrator = context . getSystemService ( VIBRATOR_SERVICE ) as Vibrator vibrator . vibrate ( vibe ) } After: fun performSomeVibration ( vibe : VibrationEffect ) { vibrator . vibrate ( vibe ) }","title":"System Services"},{"location":"modules/systemservices/#system-services","text":"No more context.getSystemService(NAME_OF_SERVICE) as NameOfManager . Supported platforms: Android . This library contains all the Android System Services as of API 29. It allows accessing them with a simple property. Most System Services use the application Context and are available anywhere in the code of your app, but some that can vary depending on the Context (like LayoutInflater or WindowManager ) are extensions on Context , View or AccessibilityService .","title":"System Services"},{"location":"modules/systemservices/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.systemservices , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-systemservices .","title":"Setup"},{"location":"modules/systemservices/#example","text":"Before: fun performSomeVibration ( vibe : VibrationEffect ) { val vibrator = context . getSystemService ( VIBRATOR_SERVICE ) as Vibrator vibrator . vibrate ( vibe ) } After: fun performSomeVibration ( vibe : VibrationEffect ) { vibrator . vibrate ( vibe ) }","title":"Example"},{"location":"modules/toast/","text":"Toast \u00b6 Show a toast by just calling toast(yourText) , and dodge API 25 BadTokenException . Supported platforms: Android . To create and show a Toast , just call toast(\u2026) (for breakfast) or longToast(\u2026) (if you're very hungry) with either a string resource id or a CharSequence . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.toast , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-toast .","title":"Toast"},{"location":"modules/toast/#toast","text":"Show a toast by just calling toast(yourText) , and dodge API 25 BadTokenException . Supported platforms: Android . To create and show a Toast , just call toast(\u2026) (for breakfast) or longToast(\u2026) (if you're very hungry) with either a string resource id or a CharSequence .","title":"Toast"},{"location":"modules/toast/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.toast , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-toast .","title":"Setup"},{"location":"modules/typesaferecyclerview/","text":"Typesafe RecyclerView \u00b6 Typesafe ViewHolder and ItemViewHolder for easy basic usage of RecyclerView . Supported platforms: Android . This module consists of two ViewHolder subclasses that make it typesafe, and easier to use for the common use case which is to bind a ViewHolder to a POJO (plain-old Java Object ) or a POKA (plain-old Kotlin Any ). See the sample to understand how it works. Setup \u00b6 This dependency is not included in any of the fun-packs , because we don't believe all apps need its content. Add it with refreshVersions : Splitties.typesaferecyclerview . For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-typesaferecyclerview . Usage \u00b6 When using ViewHolder , use the one from Splitties to get the typesafe one. See it in action in the sample: DemoAdapter .","title":"Typesafe RecyclerView"},{"location":"modules/typesaferecyclerview/#typesafe-recyclerview","text":"Typesafe ViewHolder and ItemViewHolder for easy basic usage of RecyclerView . Supported platforms: Android . This module consists of two ViewHolder subclasses that make it typesafe, and easier to use for the common use case which is to bind a ViewHolder to a POJO (plain-old Java Object ) or a POKA (plain-old Kotlin Any ). See the sample to understand how it works.","title":"Typesafe RecyclerView"},{"location":"modules/typesaferecyclerview/#setup","text":"This dependency is not included in any of the fun-packs , because we don't believe all apps need its content. Add it with refreshVersions : Splitties.typesaferecyclerview . For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-typesaferecyclerview .","title":"Setup"},{"location":"modules/typesaferecyclerview/#usage","text":"When using ViewHolder , use the one from Splitties to get the typesafe one. See it in action in the sample: DemoAdapter .","title":"Usage"},{"location":"modules/views/","text":"Views \u00b6 Extensions function and properties on View s. Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.views , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views . Content \u00b6 This split includes extensions on view related classes. They are helpful when dealing with views programmatically. Depends on AndroidX core KTX \u00b6 Android core KTX already bundles its share of useful extensions for Views. For example, it includes View visibility extension properties like isVisible . To avoid duplication, Splitties deprecated symbols made redundant by Android core KTX, and included the dependency transitively instead. View background properties \u00b6 bg is an alias to the background property for View, but works below API 16, using setBackgroundDrawable(\u2026)`. backgroundColor allows to set the background color of a View using property syntax. ImageView properties \u00b6 imageResource allows to set the image of an ImageView from a resource id using property syntax. imageDrawable allows to get, set or clear the image of an ImageView with a Drawable? using property syntax. imageBitmap allows to set the image of an ImageView from a BitMap using property syntax. Layout direction properties \u00b6 isLtr extension property for View is true on API 16 and lower, or when the layout direction is left to right (like in English). isRtl is !isLtr . Would be true on an API 17+ device setup in Arabic or another RTL language, or when the device is forced to RTL in developer options. View padding properties \u00b6 The following extension properties allow to set the padding of a View using property syntax: padding horizontalPadding verticalPadding topPadding bottomPadding You can also use the setPaddingDp extension function that offers default parameter values. EditText extensions \u00b6 type allows to set the input type in a typesafe and more readable way using the InputType inline class (lots of \"type\" occurrences in this sentence). TextView extensions \u00b6 textResource allows to set the text of a TextView from a string resource id using property syntax. textColorResource allows to set the color of the text of a TextView from a color resource id using property syntax. textAppearance allows to set the text appearance of a TextView from a text appearance style resource id using property syntax, even below API 23. lines allows to set the exact number of lines of a TextView using property syntax. centerText() sets gravity to center and center aligns the text. alignTextToStart() sets gravity to start and start aligns the text. alignTextToEnd() sets gravity to end and end aligns the text. setCompoundDrawables(\u2026) takes Drawable? parameters for start , top , end and bottom which all default to null , plus an intrinsicBounds parameter that defaults to false . setCompoundDrawables(\u2026) has an overload which takes drawable resource ids that default to 0 (no drawable) but no intrinsicBounds parameter (as it is implicitly true). clearCompoundDrawables() clears all compound drawables the TextView has. Click \u00b6 onClick { \u2026 } extension method for View avoids it shadowing if you have other lambdas, while also being more expressive than setOnClickListener { \u2026 } . onLongClick { \u2026 } is similar to onClick { \u2026 } , but also removes the need to have an extra line in the lambda to return true or false . LayoutInflater \u00b6 LayoutInflater , Context and ViewGroup have an inflate extension function that make inflating xml easy thanks to type parameter. There's also an inflateAndAttach extension function for ViewGroup . Gravity flags aliases \u00b6 Using Gravity constants on Android is a bit verbose. To alleviate this small issue, this split provides extension properties for View which start with gravity . They cover most use cases and play well with autocomplete. Example: Without Splitties : Gravity.START or Gravity.CENTER_VERTICAL With Splitties : gravityStartCenter List of supported Gravity flags: gravityCenter gravityCenterVertical gravityCenterHorizontal gravityVerticalCenter gravityHorizontalCenter gravityStart gravityTop gravityEnd gravityBottom gravityStartBottom gravityStartTop gravityEndBottom gravityEndTop gravityBottomStart (alias to gravityStartBottom) gravityTopStart (alias to gravityStartTop) gravityBottomEnd (alias to gravityEndBottom) gravityTopEnd (alias to gravityEndTop) gravityStartCenter gravityEndCenter gravityTopCenter gravityBottomCenter Other \u00b6 The generateViewId() top level function is a backwards compatible and more efficient version of View.generateViewId() that was introduced in Android API 17. The assignAndGetGeneratedId() extension function for View calls generateViewId() assigns it to the view and returns new generated id. The existingOrNewId extension property for View calls assignAndGetGeneratedId() if the view has no id ( 0 / View.NO_ID ), and returns the id of the View, existing or just generated.","title":"Views"},{"location":"modules/views/#views","text":"Extensions function and properties on View s. Supported platforms: Android .","title":"Views"},{"location":"modules/views/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.views , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views .","title":"Setup"},{"location":"modules/views/#content","text":"This split includes extensions on view related classes. They are helpful when dealing with views programmatically.","title":"Content"},{"location":"modules/views/#depends-on-androidx-core-ktx","text":"Android core KTX already bundles its share of useful extensions for Views. For example, it includes View visibility extension properties like isVisible . To avoid duplication, Splitties deprecated symbols made redundant by Android core KTX, and included the dependency transitively instead.","title":"Depends on AndroidX core KTX"},{"location":"modules/views/#view-background-properties","text":"bg is an alias to the background property for View, but works below API 16, using setBackgroundDrawable(\u2026)`. backgroundColor allows to set the background color of a View using property syntax.","title":"View background properties"},{"location":"modules/views/#imageview-properties","text":"imageResource allows to set the image of an ImageView from a resource id using property syntax. imageDrawable allows to get, set or clear the image of an ImageView with a Drawable? using property syntax. imageBitmap allows to set the image of an ImageView from a BitMap using property syntax.","title":"ImageView properties"},{"location":"modules/views/#layout-direction-properties","text":"isLtr extension property for View is true on API 16 and lower, or when the layout direction is left to right (like in English). isRtl is !isLtr . Would be true on an API 17+ device setup in Arabic or another RTL language, or when the device is forced to RTL in developer options.","title":"Layout direction properties"},{"location":"modules/views/#view-padding-properties","text":"The following extension properties allow to set the padding of a View using property syntax: padding horizontalPadding verticalPadding topPadding bottomPadding You can also use the setPaddingDp extension function that offers default parameter values.","title":"View padding properties"},{"location":"modules/views/#edittext-extensions","text":"type allows to set the input type in a typesafe and more readable way using the InputType inline class (lots of \"type\" occurrences in this sentence).","title":"EditText extensions"},{"location":"modules/views/#textview-extensions","text":"textResource allows to set the text of a TextView from a string resource id using property syntax. textColorResource allows to set the color of the text of a TextView from a color resource id using property syntax. textAppearance allows to set the text appearance of a TextView from a text appearance style resource id using property syntax, even below API 23. lines allows to set the exact number of lines of a TextView using property syntax. centerText() sets gravity to center and center aligns the text. alignTextToStart() sets gravity to start and start aligns the text. alignTextToEnd() sets gravity to end and end aligns the text. setCompoundDrawables(\u2026) takes Drawable? parameters for start , top , end and bottom which all default to null , plus an intrinsicBounds parameter that defaults to false . setCompoundDrawables(\u2026) has an overload which takes drawable resource ids that default to 0 (no drawable) but no intrinsicBounds parameter (as it is implicitly true). clearCompoundDrawables() clears all compound drawables the TextView has.","title":"TextView extensions"},{"location":"modules/views/#click","text":"onClick { \u2026 } extension method for View avoids it shadowing if you have other lambdas, while also being more expressive than setOnClickListener { \u2026 } . onLongClick { \u2026 } is similar to onClick { \u2026 } , but also removes the need to have an extra line in the lambda to return true or false .","title":"Click"},{"location":"modules/views/#layoutinflater","text":"LayoutInflater , Context and ViewGroup have an inflate extension function that make inflating xml easy thanks to type parameter. There's also an inflateAndAttach extension function for ViewGroup .","title":"LayoutInflater"},{"location":"modules/views/#gravity-flags-aliases","text":"Using Gravity constants on Android is a bit verbose. To alleviate this small issue, this split provides extension properties for View which start with gravity . They cover most use cases and play well with autocomplete. Example: Without Splitties : Gravity.START or Gravity.CENTER_VERTICAL With Splitties : gravityStartCenter List of supported Gravity flags: gravityCenter gravityCenterVertical gravityCenterHorizontal gravityVerticalCenter gravityHorizontalCenter gravityStart gravityTop gravityEnd gravityBottom gravityStartBottom gravityStartTop gravityEndBottom gravityEndTop gravityBottomStart (alias to gravityStartBottom) gravityTopStart (alias to gravityStartTop) gravityBottomEnd (alias to gravityEndBottom) gravityTopEnd (alias to gravityEndTop) gravityStartCenter gravityEndCenter gravityTopCenter gravityBottomCenter","title":"Gravity flags aliases"},{"location":"modules/views/#other","text":"The generateViewId() top level function is a backwards compatible and more efficient version of View.generateViewId() that was introduced in Android API 17. The assignAndGetGeneratedId() extension function for View calls generateViewId() assigns it to the view and returns new generated id. The existingOrNewId extension property for View calls assignAndGetGeneratedId() if the view has no id ( 0 / View.NO_ID ), and returns the id of the View, existing or just generated.","title":"Other"},{"location":"modules/views-appcompat/","text":"Views AppCompat \u00b6 AppCompat extension of Views Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsAppcompat , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-appcompat . Content \u00b6 Tooltip helpers \u00b6 tooltipTxt allows to set a tooltip text on any View using property syntax even on pre-O devices (using AndroidX's TooltipCompat in these cases). The contentDescAsTooltip() extension function for View takes the content description of your view (used for accessibility) and sets it as the tooltip text so users can long press or hover on the view and see what it is. ImageView tinting \u00b6 The imgTintList and imgTintMode extension properties for ImageView are the same as imageTintList and imageTintMode \u2026 except they work before API 21 because they delegate to AndroidX's ImageViewCompat . ActionBar extensions \u00b6 The configActionBar { \u2026 } extension function for AppCompatActivity allows to easily set up the supportActionBar . If it is null, the passed lambda is ignored, and an AssertionError is logged. The showTitle , showHome , homeAsUp , useLogo and showCustomView boolean extension properties are meant to be used on an Actionbar (usually inside the configActionBar { \u2026 } lambda). They are more readable than the setDisplayHomeAsUpEnabled and alike methods. Config changes handling Toolbar \u00b6 AppCompat Toolbar from AndroidX has different dimensions and text sizes for portrait and landscape modes, but they are not updated when the configuration changes. splitties.views.appcompat.Toolbar extends it and updates it when configuration changes, so you can avoid restarting your Activity when the device rotates, goes into multi-window mode, or undergoes any other window size related config change if the rest of your content handles this without needing to be recreated.","title":"Views AppCompat"},{"location":"modules/views-appcompat/#views-appcompat","text":"AppCompat extension of Views Supported platforms: Android .","title":"Views AppCompat"},{"location":"modules/views-appcompat/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsAppcompat , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-appcompat .","title":"Setup"},{"location":"modules/views-appcompat/#content","text":"","title":"Content"},{"location":"modules/views-appcompat/#tooltip-helpers","text":"tooltipTxt allows to set a tooltip text on any View using property syntax even on pre-O devices (using AndroidX's TooltipCompat in these cases). The contentDescAsTooltip() extension function for View takes the content description of your view (used for accessibility) and sets it as the tooltip text so users can long press or hover on the view and see what it is.","title":"Tooltip helpers"},{"location":"modules/views-appcompat/#imageview-tinting","text":"The imgTintList and imgTintMode extension properties for ImageView are the same as imageTintList and imageTintMode \u2026 except they work before API 21 because they delegate to AndroidX's ImageViewCompat .","title":"ImageView tinting"},{"location":"modules/views-appcompat/#actionbar-extensions","text":"The configActionBar { \u2026 } extension function for AppCompatActivity allows to easily set up the supportActionBar . If it is null, the passed lambda is ignored, and an AssertionError is logged. The showTitle , showHome , homeAsUp , useLogo and showCustomView boolean extension properties are meant to be used on an Actionbar (usually inside the configActionBar { \u2026 } lambda). They are more readable than the setDisplayHomeAsUpEnabled and alike methods.","title":"ActionBar extensions"},{"location":"modules/views-appcompat/#config-changes-handling-toolbar","text":"AppCompat Toolbar from AndroidX has different dimensions and text sizes for portrait and landscape modes, but they are not updated when the configuration changes. splitties.views.appcompat.Toolbar extends it and updates it when configuration changes, so you can avoid restarting your Activity when the device rotates, goes into multi-window mode, or undergoes any other window size related config change if the rest of your content handles this without needing to be recreated.","title":"Config changes handling Toolbar"},{"location":"modules/views-cardview/","text":"Views CardView \u00b6 CardView extension of Views Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsCardview , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-cardview . Content \u00b6 contentPadding allows to set the padding of the content of a CardView using property syntax. This is all this split provides at the moment.","title":"Views CardView"},{"location":"modules/views-cardview/#views-cardview","text":"CardView extension of Views Supported platforms: Android .","title":"Views CardView"},{"location":"modules/views-cardview/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsCardview , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-cardview .","title":"Setup"},{"location":"modules/views-cardview/#content","text":"contentPadding allows to set the padding of the content of a CardView using property syntax. This is all this split provides at the moment.","title":"Content"},{"location":"modules/views-coroutines/","text":"Views Coroutines \u00b6 Android Views + Kotlin coroutines. Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsCoroutines , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-coroutines . Content \u00b6 Extension functions: Name Description View.awaitOneClick Suspends until the view is clicked. Cancellable. View.awaitOneLongClick Suspends until the view is long clicked. Cancellable. View.visibleUntilClicked Makes the view visible until it is clicked and the passed lambda is executed. Cancellable. View.visibleUntilLongClicked Makes the view visible until it is long clicked and the passed lambda is executed. Cancellable. View.visibleInScope Makes the view visible while the passed lambda is executing. View.goneInScope Makes the view gone while the passed lambda is executing. View.invisibleInScope Makes the view invisible while the passed lambda is executing.","title":"Views Coroutines"},{"location":"modules/views-coroutines/#views-coroutines","text":"Android Views + Kotlin coroutines. Supported platforms: Android .","title":"Views Coroutines"},{"location":"modules/views-coroutines/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsCoroutines , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-coroutines .","title":"Setup"},{"location":"modules/views-coroutines/#content","text":"Extension functions: Name Description View.awaitOneClick Suspends until the view is clicked. Cancellable. View.awaitOneLongClick Suspends until the view is long clicked. Cancellable. View.visibleUntilClicked Makes the view visible until it is clicked and the passed lambda is executed. Cancellable. View.visibleUntilLongClicked Makes the view visible until it is long clicked and the passed lambda is executed. Cancellable. View.visibleInScope Makes the view visible while the passed lambda is executing. View.goneInScope Makes the view gone while the passed lambda is executing. View.invisibleInScope Makes the view invisible while the passed lambda is executing.","title":"Content"},{"location":"modules/views-coroutines-material/","text":"Views Coroutines Material \u00b6 Material Components + Kotlin coroutines. Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsCoroutinesMaterial , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-coroutines-material . Content \u00b6 Extension functions: Name Description FloatingActionButton.showAndAwaitOneClickThenHide Calls show() , suspends until the FAB is clicked and finally calls hide() . Cancellable.","title":"Views Coroutines Material"},{"location":"modules/views-coroutines-material/#views-coroutines-material","text":"Material Components + Kotlin coroutines. Supported platforms: Android .","title":"Views Coroutines Material"},{"location":"modules/views-coroutines-material/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsCoroutinesMaterial , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-coroutines-material .","title":"Setup"},{"location":"modules/views-coroutines-material/#content","text":"Extension functions: Name Description FloatingActionButton.showAndAwaitOneClickThenHide Calls show() , suspends until the FAB is clicked and finally calls hide() . Cancellable.","title":"Content"},{"location":"modules/views-dsl/","text":"Views DSL \u00b6 Create UIs with readable Kotlin code. Supported platforms: Android . There's a whole document about Views DSL vs xml layouts if you are not convinced yet. TL;DR: Kotlin code is more concise than xml, and a small library like this one is the proof of what is already possible with this great language. Splitties Views DSL has been designed to be: * Simple * Concise * Expressive * Explicit * Efficient * Reliable * Flexible That's 7 key considerations, which we believe are all necessary to make a great library. Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsDsl , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-dsl . What about Jetpack Compose? \u00b6 We think that Jetpack Compose is really great and is definitely the future of UI development. Regarding the present though, as of September of the year 2020, APIs based on android.view.View are still the foundation that powers nearly all Android apps, and that API is already stable, unlike Jetpack Compose that is currently in alpha. Splitties Views DSL is as stable as its foundation, its API hasn't changed since 2018 and there's no plan on breaking changes. Splitties Views DSL has a seamless interoperability with existing Views and xml layout, maybe more seamless than Jetpack Compose. To sum it up, Splitties is a great way to use Kotlin in your UI code with an API you already know, plus extensions provided by Splitties Views DSL to cut down on boilerplate while Jetpack Compose stabilizes (which should complete sometime in 2021). If you have any further questions on this topic, feel free to ask it in the #splitties channel of the Kotlin's Slack or in the issues here on GitHub. Introduction \u00b6 As said above, Splitties Views DSL has been designed to be simple . Consequently, you'll find no class in this split (API-wise, as strictly speaking, all functions and properties, even top-level ones and extensions belong to a class in the bytecode). That means you won't have to learn a whole new API to use Splitties Views DSL. You'll just have to discover the extension functions and properties as you need them to craft your Android user interfaces with Kotlin code. It turns out that you just need a few extension functions and properties to make UI-related code at least as readable as xml counterparts. Note that while putting all of your UI code directly in an Activity or a Fragment is possible with Splitties Views DSL (and can surely help for throwaway prototyping), we will be recommending a cleaner, yet simple approach (spoiler: a custom class). Before we dive into the details of the API, let's take a look at a simple example: val launchDemoBtn = button { textResource = R . string . go_to_the_demo } This example was meaningless , because no one ever publishes an app with only one button. Also, the snippet above just creates a button. If you want it into a ViewGroup , or as the content of an Activity or a Fragment , you need to do so explicitly. There are real examples in the sample . You can start by taking a look at MainUi . You can also see a simple example that uses ConstraintLayout in AboutUi . Opening the project in your IDE and navigating the sample UI code while reading this documentation may certainly help you have a hands-on experience and be comfortable more quickly writing UIs with Kotlin, a programming language that is probably already familiar to you. Table of contents \u00b6 The extensions Creating and configuring views The most generic way: view Using styles defined in xml Using Android styles Using AppCompat styles Using any other xml style The most simple and readable way: plain functions View extensions Inflating existing xml layouts Laying out the views ViewGroup.add(\u2026) , an alias to ViewGroup.addView(\u2026) ViewGroups extension functions to instantiate LayoutParams WARNING regarding lParams and defaultLParams usage Other extensions for ViewGroup The interface for user interfaces, named Ui Why this interface What it is made of Implementing the interface Using Ui implementations Simple examples Possibilities brought by the Ui interface IDE Preview IDE Preview Example Important info regarding xml based IDE Preview Interfaces parameters Known issues and their workaround Finding a suitable constructor to instantiate your UI Finding the class Modular user interface contracts Easier multi form factors support Multiplatform user interface contracts Testing Redesign A/B Testing Additional modules The extensions \u00b6 Splitties is primarily made of extension functions and properties, to create views with minimal code but maximum flexibility. Just calling the constructor, then calling needed methods in an apply { ... } block could be enough to use Kotlin instead of xml for your user interfaces, but Splitties Views DSL allows something more readable , more concise, and with a few features, like themes, styles, and seamless AppCompat support, without the boilerplate . Creating and configuring views \u00b6 The most generic way: view \u00b6 The view extension functions are a primitive of Splitties Views DSL. They are generic, so they allow you to instantiate a View of any type. There are 6 functions named view , because there's 2 overload types , and they are made available for 3 receiver types: Ui , View and Context . One of this overload type is an internal API (more info below). With respect to efficiency, they are all inline . That means no unnecessary allocation that would slightly decrease performance otherwise. Both overloads allow the following 3 optional parameters: * @IdRes id: Int , the id of the View. Example argument: R.id.input_name , given you declared it in xml, as done in the sample * @StyleRes theme: Int , resource of a theme overlay that will be applied to the View. Example argument: R.style.AppTheme_AppBarOverlay * initView: V.() -> Unit , a lambda that is like apply for the created View. The first overload of view takes a required first parameter that is a function taking a Context , and returning a View . Since constructors are also methods in Kotlin, you can directly use a method reference like so: view(::View) . The same goes for any other View subclass (e.g. view(::FrameLayout) ). You can also use a lambda instead: view({ FrameLayout(it) }) . In fact, that's how you should do it while autocomplete for method references is not optimal, then use the IDE quick action ( alt / \u2325 option + \u23ce enter ) to convert it to method reference. You can of course use any custom method reference that is not a reference to a constructor as long as that method takes a Context parameter and returns a View or any subclass of it. Here's a simple but typical example: val myView : MyCustomView = view ( :: MyCustomView , R . id . my_view ) { backgroundColor = Color . BLACK } The second overload of view , which is an internal API takes no required parameter, but relies on explicit (reified) type parameter to work properly. Just view<TextView>() is enough to instantiate a TextView . However, this version relies on a \"view factory\" that can automatically provide subclasses of the requested type as necessary. If you use the Views DSL AppCompat, you'll automatically receive instances of AppCompatButton with view<Button> thanks to the underlying View factory. Here's a simple example of this second overload: val submitBtn = view < Button > ( R . id . btn_submit ) { // You should use `button { \u2026 }` instead though. textResource = R . string . submit } The most simple and readable way: plain functions \u00b6 Instead of using view<Button> { \u2026 } or view(::Button) { \u2026 } to create a Button instance (which uses an internal API), you can use button(\u2026) { \u2026 } . The parameters are exactly the same as the view function. Such methods exist for most View s and ViewGroup s included in Android, and there's more in the additional modules . You can see implementations for Android's Views and ViewGroups . These methods are a bit more natural to read and to write, but they are really just inline aliases, purely syntactic sugar. You can define your own if you want. Just make sure to write it first for Context and add two overloads for View and Ui that delegate to the one for Context . Also, remember to make them inline to avoid lambda allocation. Using styles defined in xml \u00b6 There are some times when you need to use an XML defined style, such as when using a style defined in AppCompat like Widget_AppCompat_Button_Colored . Splitties makes it really easy to use xml styles defined in Android, AppCompat and Material Components. It also gives you the ability to do the same for custom or third-party styles defined in xml. Using Android styles \u00b6 Let's say you want to create a horizontal ProgressBar instance. First, cache an instance of AndroidStyles : private val androidStyles = AndroidStyles ( ctx ) Then, use the function defined on the progressBar property: val progressbar = androidStyles . progressBar . horizontal () Other styles defined in the Android platform are provided in AndroidStyles . Just let auto-completion guide you. Note that you have exactly the same optional parameters as view , including the optional lambda. Using Material Components styles \u00b6 Since Material Components styles are not included by default inside the theme, you need to load them first. This is simply done with the following code: private val materialStyles = MaterialComponentsStyles ( ctx ) You can then use styles using the MaterialComponentsStyles instance. Here's an example: val bePoliteBtn = materialStyles . button . outlined { textResource = R . string . be_polite } Using AppCompat styles \u00b6 Since AppCompat styles are not included by default inside the theme, you need to load them first. This is simply done with the following code: private val appCompatStyles = AppCompatStyles ( ctx ) You can then use styles using the AppCompatStyles instance. Here's an example: val bePoliteBtn = appCompatStyles . button . colored { textResource = R . string . be_rude } Using any other xml style \u00b6 The colored , horizontal and other properties you can find in the AndroidStyles and the AppCompatStyles have the XmlStyle type. It is easy to instantiate it and support any xml style after the style is loaded into the current theme, but before we see how it's done, let's see what is this type. The XmlStyle inline class has: * A type parameter, for the target View type. * A single Int value, a theme attribute ( @AttrRes , not @StyleRes ). As you can see, its constructor doesn't expect a style resource (e.g. R.style.Widget_AppCompat_ActionButton ), but a theme attribute resource (e.g. R.attr.Widget_AppCompat_ActionButton ). This is because of a limitation in Android where you can programmatically only use xml styles that are inside a theme. That doesn't mean that you will have to pollute all the themes you're using with styles definitions though. Android allows you to combine multiple themes with the applyStyle(\u2026) method that you can call on any theme , which any Context has. That way, you can apply a theme that already includes references the xml styles you need with only one line of code. This is what the AppCompatStyles(ctx) function mentioned does under the hood. Here's a short example: ctx . theme . applyStyle ( R . style . ThirdPartyStyles , false ) val clapButton = XmlStyle < Button > ( R . attr . Widget_ThirdParty_FancyButton )( ctx ) { imageResource = R . drawable . ic_clap_white_24dp } The first line makes sure the theme associated to the Context named ctx can resolve all the style attributes defined into R.style.ThirdPartyStyles , such as R.attr.Widget_ThirdParty_FancyButton . To make this work, you have to do the following: 1. Declare ThirdPartyStyles in xml (usually in a file named styles.xml ) 2. Declare the Widget_ThirdParty_FancyButton attribute (usually in a file named attrs.xml ) 3. Declare Widget_ThirdParty_FancyButton into ThirdPartyStyles and make sure it references the style target resource (named Widget_ThirdParty_FancyButton too). Using the same name for the target style and the attribute is a recommendation (for clarity), but not a requirement. After this is done, you can make a class to group related styles, as done in the Views DSL AppCompat split , so you get type inference, and a nicer syntax. View extensions \u00b6 For even more expressive UI code, Splitties Views DSL has a transitive dependency on the Views split that provides a useful set of Kotlin-friendly extension functions and properties dedicated to View s and some of their subclasses. Inflating existing xml layouts \u00b6 Splitties Views DSL works well with xml layouts too! The inflate extension functions is a variant to the view function mentioned earlier in this guide which has an additional first parameter: the layout resource id you want to inflate. Also, if the xml layout defines an id for the root view, it will be kept, unless you specified an explicit id (including View.NO_ID ). Just like view , inflate is defined for Context , View and Ui . Here's a short example: val mySecretFancyView = inflate ( R . layout . my_fancy_layout ) { isVisible = false } Laying out the views \u00b6 ViewGroup.add(\u2026) , an alias to ViewGroup.addView(\u2026) \u00b6 To add a View to a ViewGroup in code, you can use View.addView(\u2026) . However, this can become quite redundant to have View repeated over and over when it's already obvious that you are in a UI centric class that passes a parameter that is clearly a View . That's why this split has an inline alias to it named just add(\u2026) for ViewGroup . It has the extra benefit of returning the passed View , which can be handy in some situations. The ViewGroup.add(\u2026) function requires an instance of ViewGroup.LayoutParams . See in the next section how Splitties helps instantiate it with minimal, yet explicit code. The add function also has 2 overloads that take either a beforeChild or an afterChild argument, handy when the order of Views matters or when adding views dynamically. ViewGroups extension functions to instantiate LayoutParams \u00b6 Splitties provides several methods named lParams(\u2026) { \u2026 } for the 2 Android's built-in ViewGroup s: LinearLayout and FrameLayout . You can find support for additional ViewGroup s in the additional modules . These methods make it easy to instantiate LayoutParams with typesafe and readable code (unlike xml). Here's the contract that every lParams or alike function must respect: 1. The receiver is the type of the target ViewGroup subclass. 2. The function returns the LayoutParams for the target ViewGroup . 3. The first parameter is width and defaults to wrapContent , unless otherwise noted. 4. The second parameter is height and defaults to the same value as width , unless otherwise noted. 5. The width or height parameters may be missing in case they shall always have the same value for this target ViewGroup or for this function. 5. There may be additional parameters, with default values if possible. 6. The last parameter is a lambda with LayoutParams as a receiver and is executed exactly once, last (i.e. after any logic that the lParams implementation may have). 7. If the lParams function targets a ViewGroup that has a superclass that also has its own LayoutParams , and its own lParams function, it should be named defaultLParams instead to prevent any overload resolution ambiguity. A great example is AppBarLayout that is a child class of LinearLayout and has such extension functions for LayoutParams . 8. In case the function is specialized for non default use case (e.g. adding an AppBarLayout into a CoordinatorLayout ), it can have a custom name, but should always end with LParams (e.g. appBarLParams ). WARNING regarding lParams and defaultLParams usage: \u00b6 lParams and similar functions are resolved based on the type of their receiver. However, unless you prepend lParams or defaultLParams call with this. , the received is picked implicitly, and can be indirect, possibly causing the wrong lParams method to be used. Here's a short, example : You're in a FrameLayout (because you're writing a subclass of it, or because of a lambda receiver, like inside frameLayout { \u2026 } ). You call constraintLayout { \u2026 } and start adding views inside it, but when you call lParams , you may use the implementation for FrameLayout , and wonder why the ConstraintLayout.LayoutParams properties and extensions are not available. To highlight such errors, you can prepend this. to your suspicious lParams calls, and if they are in red, then you used the wrong one for the ViewGroup you're in. The IDE should quickly fix it, adding the proper import at this point. After this is done, you can then safely remove the this. prefix. To avoid this issue, you can be alert when you're typing/auto-completing lParams and defaultLParams and make sure that you're selecting the extension for the type of the ViewGroup you're in (direct parent of the child View you are adding). Other extensions for ViewGroup \u00b6 wrapContent and matchParent inline extensions properties on ViewGroup are convenience aliases to ViewGroup.LayoutParams.WRAP_CONTENT and ViewGroup.LayoutParams.MATCH_PARENT . horizontalMargin , verticalMargin and margin for convenient margins definition in layout parameters ( ViewGroup.MarginLayoutParams which is the base of nearly all LayoutParams). startMargin and endMargin which are compatible below API 17 (using LTR) and fix the inconsistent name ordering ( leftMargin , but marginStart ?). The interface for user interfaces, named Ui \u00b6 This section doesn't just write so many words about how the Ui interface has only 2 properties . It explains why it is useful , how to use it the right way , and the possibilities it offers. FYI, the declaration of this interface looks like this: interface Ui { val ctx : Context val root : View } Why this interface \u00b6 As said above, you can put your UI code directly in an Activity or a Fragment , but the fact that you can, doesn't mean that you should. Mixing UI code with business logic, data storage code, network calls and miscellaneous boilerplate in the same \"god\" class will quickly make further work (like feature additions and maintenance) very hard, because you're likely not a god programmer, and even if you are, your coworkers, or successors, are likely not. Xml layouts alleviate this issue by forcing you to put most of your UI code into a separate xml file, but you often need complementary code (e.g. to handle transitions, dynamic visibility), and this is often put into a Fragment or an Activity , which makes things worse, as you now have your UI code spread over at least two places that are tightly coupled. What it is made of \u00b6 With Splitties Views DSL, there's an optional interface named Ui , whose implementations are meant to contain your UI code. It has a ctx property because in Android, a Context is needed to create a View . It has a root property because you need a View to display in the end. Since you're using Kotlin code, you can put all the UI related logic in it too, in a single place this time. Also, since Ui is an interface, you can get creative by creating sub-interfaces or sub-classes to have different implementations of the same UI, which is nice for A/B testing, user preferences (different styles that the user can pick), configuration (like screen orientation), and more. Implementing the Ui interface \u00b6 When writing a Ui implementation, override the ctx property as the first constructor parameter (e.g. class MainUi(override val ctx: Context) : Ui { ), and override the root parameter as a property with a backing field by assigning it a View (e.g. override val root = coordinatorLayout { ... } ). Then create your views (usually putting them as final properties, like root ), and add them to the ViewGroup s they belong to, so they are direct, or indirect children of root (in the likely case where you have multiple views in your UI and root is therefore a ViewGroup ). Using Ui implementations \u00b6 To use a Ui implementation from an Activity subclass, just call setContentView(ui) . To use it from any other place, just get the root property. In a Fragment subclass, that will mean returning it from onCreateView(\u2026) . You can also use any function or property you've declared in your sub-interface or implementation. Here are two examples: * Using a public property of type Button to set it an OnClickListener in the place where the Ui is used (like an Activity or a Fragment that connects your UI to a ViewModel and any other components). * Call a method called animateGoalReached() . Simple examples \u00b6 See concrete examples in MainUi and DemoUi with their respective Activities MainActivity and DemoActivity . Possibilities brought by the Ui interface \u00b6 IDE Preview \u00b6 With the UiPreView class, you can preview your Ui implementations right from the IDE, (requires Android Studio 4.0 or newer). You can do it in code and have access to it contextually by selecting the \"Split\" or \"Design\" view in the top right corner of the editor, or you can do it in xml and benefit from options not yet available in View subclasses preview such as configuration switching (night mode, locale, etc.). While the real app might show actual data, you'll likely want to show sample data in the IDE preview. To support this use case in the best way possible such as there's no impact on the production code, Splitties brings the isInPreview inline extension property for Ui and View . When your app is compiled in release mode, it evaluates to false as a constant value (unlike View.isInEditmode ), which means that any code path under this condition will be removed by the compiler (kotlinc), and R8 or proguard will then remove any extra code that was only used in the IDE preview. IDE Preview Example \u00b6 Below is a preview example in Kotlin that the IDE can display. //region IDE preview @Deprecated ( \"For IDE preview only\" , level = DeprecationLevel . HIDDEN ) private class MainUiImplPreview ( context : Context , attrs : AttributeSet? = null , defStyleAttr : Int = 0 ) : UiPreView ( context = context . withTheme ( R . style . AppTheme ), attrs = attrs , defStyleAttr = defStyleAttr , createUi = { MainUiImpl ( it ) } ) //endregion It is surrounded by a \"region\" so it can be collapsed by the IDE as you can see in the screenshot just below. Below is a preview xml layout example that the IDE can display. It assumes there's a class implementing Ui named MainUi in the main subpackage (relative to the app/library package name). Beware that for the xml approach, any refactoring changes will not be reflected in the xml file, so if you change the package or the name of your Ui implementation class, you'll have to remember to edit the xml preview too to keep it working. <splitties.views.dsl.idepreview.UiPreView xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:app= \"http://schemas.android.com/apk/res-auto\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" app:splitties_class_package_name_relative= \"main.MainUi\" /> Here's a screenshot of how it looks like with DemoUi from the sample after the mergeDebugJavaResource gradle task has been run: Important info regarding xml based IDE Preview \u00b6 Interfaces parameters \u00b6 In order for the xml preview to work, your Ui subclass need to have its first parameter of type Context . For the subsequent parameters (if applicable), any interface is supported, but its methods need to not be called when this view is created and drawn, or an exception will be thrown. A special support has been added for CoroutineContext and CoroutineScope , so there's no exception thrown if you use an actor or other code relying on coroutines at init or drawing time. Known issues and their workaround \u00b6 If preview doesn't work or doesn't reflect the latest changes, it's likely because you didn't execute the mergeDebugJavaResource gradle task on your project (module actually). IDE preview currently only works with compiled classes and xml layouts. Running the mergeDebugJavaResource gradle task will save you time as it doesn't involve all the subsequent tasks that package a full apk. Finding a suitable constructor to instantiate your UI \u00b6 UiPreView is compatible with Ui implementations with two kind of constructors: * Constructors with a single Context parameter. * Constructors whose first parameter is a Context and other parameters are interfaces. Note that the interface methods need to not be called during preview, or an UnsupportedOperationException will be raised because UiPreView can only create stub implementations. You can use View.isInEditMode to skip code for preview if really needed. Finding the class \u00b6 When using the splitties_class_package_name_relative attribute, the UiPreView class will take the packageName returned from the Context and append a dot plus the value of the attribute to get the class name of your Ui implementation. However, you may have configured your build so your debug buildType has an applicationId suffix that is usually .debug like show in the example below: buildTypes { debug { applicationIdSuffix \".debug\" // This changes the packageName returned from a Context versionNameSuffix \"-DEBUG\" } release { // Config of your release build } } That's why by default, the UiPreView class will drop any .debug suffix found in the package name before trying to instantiate the class. If you use another suffix, or have other suffixes for other debuggable buildTypes, or use productFlavors, you're in luck! The package name suffix to drop is configurable from your resources. Just copy and paste the string resource below in your project in a value resource file named something like config.xml or do_not_translate.xml , and edit it to the suffix you use: <string name= \"splitties_views_dsl_ide_preview_package_name_suffix\" translatable= \"false\" > .debug </string> This will override the default value from the library. You can also override the splitties_ui_preview_base_package_names string array resource and add all the base package names where you have implementations of the Ui interface you want to preview. You can see such an example in the sample here . This can be handy if you change the applicationId , or if you have a modularized codebase. Alternatively, you can use the splitties_class_fully_qualified_name attribute instead and specify the full class name with its package. Modular user interface contracts \u00b6 While having a dedicated class for user interface, that is agnostic from where it will be used (Activity, Fragment, IDE Preview\u2026), is a great first step to a modular user interface code, you can go further. Instead of exposing your Ui implementation directly to the Activity or Fragment, you can decide to write several interfaces that define a contract that your Activity, Fragment, ViewModel (beware of leaks), or whatever will need, and implement all of these with one or more classes. For example, let's say you are developing an email app. You write two interfaces: InboxUi and ComposeUi that both extend the Ui interface. You add to the interfaces all the functions (including any suspend fun ), properties and other symbols you may need to expose to the Activity, Fragment, ViewModel or whatever. Then you implement these two interfaces, with either one class or two, depending on whether you want to display them separately or not. Easier multi form factors support \u00b6 Modular UI contracts open the door to a great benefit: an easier way to support multiple form factors (smartphones, smartwatches, tablets, laptops, cars\u2026). In the previous example, we highlighted the fact that you could have multiple interfaces that expose the needed symbols, and then decide to implement these interfaces in one, or multiple classes. This can help you support different form factors with zero, or only a few changes in non-UI code as it is no longer relies on a specific implementation. It is planned to add such examples in the samples of this repository. If you want to have them faster, please open an issue so the examples can be discussed. Also, maybe you, or someone you know, can contribute. Multiplatform user interface contracts \u00b6 Here's an example of how you may write multiplatform user interface contracts: In Kotlin common code, you would write an interface that is platform-agnostic but declares the needed symbols that all platforms can share: Continuing our email app example, you would write these two interfaces: interface InboxUiContract { // Whatever you need } interface ComposeUiContract { // Whatever you need } Then write to sub-interfaces for each platform you want to support, Android and iOS in this example: interface AndroidInboxUi : InboxUiContract , Ui interface IOSInboxUi : InboxUiContract { val root : UIView } And you may finally implement them for each platform, still supporting multiple form-factors and platform variants if needed. The two common interfaces ( InboxUiContract and ComposeUiContract ) could be replaced by abstract classes in case you need to have backing fields, final declarations or final implementations, as long as they don't reference Splitties Ui interface and no platform specific code. Testing \u00b6 Having your user interface as an interface can make it easy to mock it, and simulate user interactions for testing purposes. Redesign \u00b6 If you expect an interface for the user interface, then it becomes easy to replace an implementation by another one in case you're redesigning your app. You can also split your UI contracts (the interface s) into smaller subsets before starting a redesign if needed, this can be helpful if you want to move some UI controls to another area of the application, or just organize things differently. A/B Testing \u00b6 When you have multiple UI interface s implementations, you can then swap them at runtime for A/B testing, allowing you to test which UI works the best for what you determined. Additional modules \u00b6 There are additional splits for extended support. Views DSL\u2026 * AppCompat provides proper styling to Button , TextView , EditText and other widgets. views like coloredFlatButton . * ConstraintLayout provides support for ConstraintLayout.LayoutParams . ViewGroup s and bottom sheets. * IDE preview provides the ability to preview your user interfaces right from the IDE. * Material provides extensions for Material Components * RecyclerView provides extensions to have scrollbars and proper itemView layout parameters.","title":"Views DSL"},{"location":"modules/views-dsl/#views-dsl","text":"Create UIs with readable Kotlin code. Supported platforms: Android . There's a whole document about Views DSL vs xml layouts if you are not convinced yet. TL;DR: Kotlin code is more concise than xml, and a small library like this one is the proof of what is already possible with this great language. Splitties Views DSL has been designed to be: * Simple * Concise * Expressive * Explicit * Efficient * Reliable * Flexible That's 7 key considerations, which we believe are all necessary to make a great library.","title":"Views DSL"},{"location":"modules/views-dsl/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsDsl , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-dsl .","title":"Setup"},{"location":"modules/views-dsl/#what-about-jetpack-compose","text":"We think that Jetpack Compose is really great and is definitely the future of UI development. Regarding the present though, as of September of the year 2020, APIs based on android.view.View are still the foundation that powers nearly all Android apps, and that API is already stable, unlike Jetpack Compose that is currently in alpha. Splitties Views DSL is as stable as its foundation, its API hasn't changed since 2018 and there's no plan on breaking changes. Splitties Views DSL has a seamless interoperability with existing Views and xml layout, maybe more seamless than Jetpack Compose. To sum it up, Splitties is a great way to use Kotlin in your UI code with an API you already know, plus extensions provided by Splitties Views DSL to cut down on boilerplate while Jetpack Compose stabilizes (which should complete sometime in 2021). If you have any further questions on this topic, feel free to ask it in the #splitties channel of the Kotlin's Slack or in the issues here on GitHub.","title":"What about Jetpack Compose?"},{"location":"modules/views-dsl/#introduction","text":"As said above, Splitties Views DSL has been designed to be simple . Consequently, you'll find no class in this split (API-wise, as strictly speaking, all functions and properties, even top-level ones and extensions belong to a class in the bytecode). That means you won't have to learn a whole new API to use Splitties Views DSL. You'll just have to discover the extension functions and properties as you need them to craft your Android user interfaces with Kotlin code. It turns out that you just need a few extension functions and properties to make UI-related code at least as readable as xml counterparts. Note that while putting all of your UI code directly in an Activity or a Fragment is possible with Splitties Views DSL (and can surely help for throwaway prototyping), we will be recommending a cleaner, yet simple approach (spoiler: a custom class). Before we dive into the details of the API, let's take a look at a simple example: val launchDemoBtn = button { textResource = R . string . go_to_the_demo } This example was meaningless , because no one ever publishes an app with only one button. Also, the snippet above just creates a button. If you want it into a ViewGroup , or as the content of an Activity or a Fragment , you need to do so explicitly. There are real examples in the sample . You can start by taking a look at MainUi . You can also see a simple example that uses ConstraintLayout in AboutUi . Opening the project in your IDE and navigating the sample UI code while reading this documentation may certainly help you have a hands-on experience and be comfortable more quickly writing UIs with Kotlin, a programming language that is probably already familiar to you.","title":"Introduction"},{"location":"modules/views-dsl/#table-of-contents","text":"The extensions Creating and configuring views The most generic way: view Using styles defined in xml Using Android styles Using AppCompat styles Using any other xml style The most simple and readable way: plain functions View extensions Inflating existing xml layouts Laying out the views ViewGroup.add(\u2026) , an alias to ViewGroup.addView(\u2026) ViewGroups extension functions to instantiate LayoutParams WARNING regarding lParams and defaultLParams usage Other extensions for ViewGroup The interface for user interfaces, named Ui Why this interface What it is made of Implementing the interface Using Ui implementations Simple examples Possibilities brought by the Ui interface IDE Preview IDE Preview Example Important info regarding xml based IDE Preview Interfaces parameters Known issues and their workaround Finding a suitable constructor to instantiate your UI Finding the class Modular user interface contracts Easier multi form factors support Multiplatform user interface contracts Testing Redesign A/B Testing Additional modules","title":"Table of contents"},{"location":"modules/views-dsl/#the-extensions","text":"Splitties is primarily made of extension functions and properties, to create views with minimal code but maximum flexibility. Just calling the constructor, then calling needed methods in an apply { ... } block could be enough to use Kotlin instead of xml for your user interfaces, but Splitties Views DSL allows something more readable , more concise, and with a few features, like themes, styles, and seamless AppCompat support, without the boilerplate .","title":"The extensions"},{"location":"modules/views-dsl/#creating-and-configuring-views","text":"","title":"Creating and configuring views"},{"location":"modules/views-dsl/#the-most-generic-way-view","text":"The view extension functions are a primitive of Splitties Views DSL. They are generic, so they allow you to instantiate a View of any type. There are 6 functions named view , because there's 2 overload types , and they are made available for 3 receiver types: Ui , View and Context . One of this overload type is an internal API (more info below). With respect to efficiency, they are all inline . That means no unnecessary allocation that would slightly decrease performance otherwise. Both overloads allow the following 3 optional parameters: * @IdRes id: Int , the id of the View. Example argument: R.id.input_name , given you declared it in xml, as done in the sample * @StyleRes theme: Int , resource of a theme overlay that will be applied to the View. Example argument: R.style.AppTheme_AppBarOverlay * initView: V.() -> Unit , a lambda that is like apply for the created View. The first overload of view takes a required first parameter that is a function taking a Context , and returning a View . Since constructors are also methods in Kotlin, you can directly use a method reference like so: view(::View) . The same goes for any other View subclass (e.g. view(::FrameLayout) ). You can also use a lambda instead: view({ FrameLayout(it) }) . In fact, that's how you should do it while autocomplete for method references is not optimal, then use the IDE quick action ( alt / \u2325 option + \u23ce enter ) to convert it to method reference. You can of course use any custom method reference that is not a reference to a constructor as long as that method takes a Context parameter and returns a View or any subclass of it. Here's a simple but typical example: val myView : MyCustomView = view ( :: MyCustomView , R . id . my_view ) { backgroundColor = Color . BLACK } The second overload of view , which is an internal API takes no required parameter, but relies on explicit (reified) type parameter to work properly. Just view<TextView>() is enough to instantiate a TextView . However, this version relies on a \"view factory\" that can automatically provide subclasses of the requested type as necessary. If you use the Views DSL AppCompat, you'll automatically receive instances of AppCompatButton with view<Button> thanks to the underlying View factory. Here's a simple example of this second overload: val submitBtn = view < Button > ( R . id . btn_submit ) { // You should use `button { \u2026 }` instead though. textResource = R . string . submit }","title":"The most generic way: view"},{"location":"modules/views-dsl/#the-most-simple-and-readable-way-plain-functions","text":"Instead of using view<Button> { \u2026 } or view(::Button) { \u2026 } to create a Button instance (which uses an internal API), you can use button(\u2026) { \u2026 } . The parameters are exactly the same as the view function. Such methods exist for most View s and ViewGroup s included in Android, and there's more in the additional modules . You can see implementations for Android's Views and ViewGroups . These methods are a bit more natural to read and to write, but they are really just inline aliases, purely syntactic sugar. You can define your own if you want. Just make sure to write it first for Context and add two overloads for View and Ui that delegate to the one for Context . Also, remember to make them inline to avoid lambda allocation.","title":"The most simple and readable way: plain functions"},{"location":"modules/views-dsl/#using-styles-defined-in-xml","text":"There are some times when you need to use an XML defined style, such as when using a style defined in AppCompat like Widget_AppCompat_Button_Colored . Splitties makes it really easy to use xml styles defined in Android, AppCompat and Material Components. It also gives you the ability to do the same for custom or third-party styles defined in xml.","title":"Using styles defined in xml"},{"location":"modules/views-dsl/#using-android-styles","text":"Let's say you want to create a horizontal ProgressBar instance. First, cache an instance of AndroidStyles : private val androidStyles = AndroidStyles ( ctx ) Then, use the function defined on the progressBar property: val progressbar = androidStyles . progressBar . horizontal () Other styles defined in the Android platform are provided in AndroidStyles . Just let auto-completion guide you. Note that you have exactly the same optional parameters as view , including the optional lambda.","title":"Using Android styles"},{"location":"modules/views-dsl/#using-material-components-styles","text":"Since Material Components styles are not included by default inside the theme, you need to load them first. This is simply done with the following code: private val materialStyles = MaterialComponentsStyles ( ctx ) You can then use styles using the MaterialComponentsStyles instance. Here's an example: val bePoliteBtn = materialStyles . button . outlined { textResource = R . string . be_polite }","title":"Using Material Components styles"},{"location":"modules/views-dsl/#using-appcompat-styles","text":"Since AppCompat styles are not included by default inside the theme, you need to load them first. This is simply done with the following code: private val appCompatStyles = AppCompatStyles ( ctx ) You can then use styles using the AppCompatStyles instance. Here's an example: val bePoliteBtn = appCompatStyles . button . colored { textResource = R . string . be_rude }","title":"Using AppCompat styles"},{"location":"modules/views-dsl/#using-any-other-xml-style","text":"The colored , horizontal and other properties you can find in the AndroidStyles and the AppCompatStyles have the XmlStyle type. It is easy to instantiate it and support any xml style after the style is loaded into the current theme, but before we see how it's done, let's see what is this type. The XmlStyle inline class has: * A type parameter, for the target View type. * A single Int value, a theme attribute ( @AttrRes , not @StyleRes ). As you can see, its constructor doesn't expect a style resource (e.g. R.style.Widget_AppCompat_ActionButton ), but a theme attribute resource (e.g. R.attr.Widget_AppCompat_ActionButton ). This is because of a limitation in Android where you can programmatically only use xml styles that are inside a theme. That doesn't mean that you will have to pollute all the themes you're using with styles definitions though. Android allows you to combine multiple themes with the applyStyle(\u2026) method that you can call on any theme , which any Context has. That way, you can apply a theme that already includes references the xml styles you need with only one line of code. This is what the AppCompatStyles(ctx) function mentioned does under the hood. Here's a short example: ctx . theme . applyStyle ( R . style . ThirdPartyStyles , false ) val clapButton = XmlStyle < Button > ( R . attr . Widget_ThirdParty_FancyButton )( ctx ) { imageResource = R . drawable . ic_clap_white_24dp } The first line makes sure the theme associated to the Context named ctx can resolve all the style attributes defined into R.style.ThirdPartyStyles , such as R.attr.Widget_ThirdParty_FancyButton . To make this work, you have to do the following: 1. Declare ThirdPartyStyles in xml (usually in a file named styles.xml ) 2. Declare the Widget_ThirdParty_FancyButton attribute (usually in a file named attrs.xml ) 3. Declare Widget_ThirdParty_FancyButton into ThirdPartyStyles and make sure it references the style target resource (named Widget_ThirdParty_FancyButton too). Using the same name for the target style and the attribute is a recommendation (for clarity), but not a requirement. After this is done, you can make a class to group related styles, as done in the Views DSL AppCompat split , so you get type inference, and a nicer syntax.","title":"Using any other xml style"},{"location":"modules/views-dsl/#view-extensions","text":"For even more expressive UI code, Splitties Views DSL has a transitive dependency on the Views split that provides a useful set of Kotlin-friendly extension functions and properties dedicated to View s and some of their subclasses.","title":"View extensions"},{"location":"modules/views-dsl/#inflating-existing-xml-layouts","text":"Splitties Views DSL works well with xml layouts too! The inflate extension functions is a variant to the view function mentioned earlier in this guide which has an additional first parameter: the layout resource id you want to inflate. Also, if the xml layout defines an id for the root view, it will be kept, unless you specified an explicit id (including View.NO_ID ). Just like view , inflate is defined for Context , View and Ui . Here's a short example: val mySecretFancyView = inflate ( R . layout . my_fancy_layout ) { isVisible = false }","title":"Inflating existing xml layouts"},{"location":"modules/views-dsl/#laying-out-the-views","text":"","title":"Laying out the views"},{"location":"modules/views-dsl/#viewgroupadd-an-alias-to-viewgroupaddview","text":"To add a View to a ViewGroup in code, you can use View.addView(\u2026) . However, this can become quite redundant to have View repeated over and over when it's already obvious that you are in a UI centric class that passes a parameter that is clearly a View . That's why this split has an inline alias to it named just add(\u2026) for ViewGroup . It has the extra benefit of returning the passed View , which can be handy in some situations. The ViewGroup.add(\u2026) function requires an instance of ViewGroup.LayoutParams . See in the next section how Splitties helps instantiate it with minimal, yet explicit code. The add function also has 2 overloads that take either a beforeChild or an afterChild argument, handy when the order of Views matters or when adding views dynamically.","title":"ViewGroup.add(\u2026), an alias to ViewGroup.addView(\u2026)"},{"location":"modules/views-dsl/#viewgroups-extension-functions-to-instantiate-layoutparams","text":"Splitties provides several methods named lParams(\u2026) { \u2026 } for the 2 Android's built-in ViewGroup s: LinearLayout and FrameLayout . You can find support for additional ViewGroup s in the additional modules . These methods make it easy to instantiate LayoutParams with typesafe and readable code (unlike xml). Here's the contract that every lParams or alike function must respect: 1. The receiver is the type of the target ViewGroup subclass. 2. The function returns the LayoutParams for the target ViewGroup . 3. The first parameter is width and defaults to wrapContent , unless otherwise noted. 4. The second parameter is height and defaults to the same value as width , unless otherwise noted. 5. The width or height parameters may be missing in case they shall always have the same value for this target ViewGroup or for this function. 5. There may be additional parameters, with default values if possible. 6. The last parameter is a lambda with LayoutParams as a receiver and is executed exactly once, last (i.e. after any logic that the lParams implementation may have). 7. If the lParams function targets a ViewGroup that has a superclass that also has its own LayoutParams , and its own lParams function, it should be named defaultLParams instead to prevent any overload resolution ambiguity. A great example is AppBarLayout that is a child class of LinearLayout and has such extension functions for LayoutParams . 8. In case the function is specialized for non default use case (e.g. adding an AppBarLayout into a CoordinatorLayout ), it can have a custom name, but should always end with LParams (e.g. appBarLParams ).","title":"ViewGroups extension functions to instantiate LayoutParams"},{"location":"modules/views-dsl/#warning-regarding-lparams-and-defaultlparams-usage","text":"lParams and similar functions are resolved based on the type of their receiver. However, unless you prepend lParams or defaultLParams call with this. , the received is picked implicitly, and can be indirect, possibly causing the wrong lParams method to be used. Here's a short, example : You're in a FrameLayout (because you're writing a subclass of it, or because of a lambda receiver, like inside frameLayout { \u2026 } ). You call constraintLayout { \u2026 } and start adding views inside it, but when you call lParams , you may use the implementation for FrameLayout , and wonder why the ConstraintLayout.LayoutParams properties and extensions are not available. To highlight such errors, you can prepend this. to your suspicious lParams calls, and if they are in red, then you used the wrong one for the ViewGroup you're in. The IDE should quickly fix it, adding the proper import at this point. After this is done, you can then safely remove the this. prefix. To avoid this issue, you can be alert when you're typing/auto-completing lParams and defaultLParams and make sure that you're selecting the extension for the type of the ViewGroup you're in (direct parent of the child View you are adding).","title":"WARNING regarding lParams and defaultLParams usage:"},{"location":"modules/views-dsl/#other-extensions-for-viewgroup","text":"wrapContent and matchParent inline extensions properties on ViewGroup are convenience aliases to ViewGroup.LayoutParams.WRAP_CONTENT and ViewGroup.LayoutParams.MATCH_PARENT . horizontalMargin , verticalMargin and margin for convenient margins definition in layout parameters ( ViewGroup.MarginLayoutParams which is the base of nearly all LayoutParams). startMargin and endMargin which are compatible below API 17 (using LTR) and fix the inconsistent name ordering ( leftMargin , but marginStart ?).","title":"Other extensions for ViewGroup"},{"location":"modules/views-dsl/#the-interface-for-user-interfaces-named-ui","text":"This section doesn't just write so many words about how the Ui interface has only 2 properties . It explains why it is useful , how to use it the right way , and the possibilities it offers. FYI, the declaration of this interface looks like this: interface Ui { val ctx : Context val root : View }","title":"The interface for user interfaces, named Ui"},{"location":"modules/views-dsl/#why-this-interface","text":"As said above, you can put your UI code directly in an Activity or a Fragment , but the fact that you can, doesn't mean that you should. Mixing UI code with business logic, data storage code, network calls and miscellaneous boilerplate in the same \"god\" class will quickly make further work (like feature additions and maintenance) very hard, because you're likely not a god programmer, and even if you are, your coworkers, or successors, are likely not. Xml layouts alleviate this issue by forcing you to put most of your UI code into a separate xml file, but you often need complementary code (e.g. to handle transitions, dynamic visibility), and this is often put into a Fragment or an Activity , which makes things worse, as you now have your UI code spread over at least two places that are tightly coupled.","title":"Why this interface"},{"location":"modules/views-dsl/#what-it-is-made-of","text":"With Splitties Views DSL, there's an optional interface named Ui , whose implementations are meant to contain your UI code. It has a ctx property because in Android, a Context is needed to create a View . It has a root property because you need a View to display in the end. Since you're using Kotlin code, you can put all the UI related logic in it too, in a single place this time. Also, since Ui is an interface, you can get creative by creating sub-interfaces or sub-classes to have different implementations of the same UI, which is nice for A/B testing, user preferences (different styles that the user can pick), configuration (like screen orientation), and more.","title":"What it is made of"},{"location":"modules/views-dsl/#implementing-the-ui-interface","text":"When writing a Ui implementation, override the ctx property as the first constructor parameter (e.g. class MainUi(override val ctx: Context) : Ui { ), and override the root parameter as a property with a backing field by assigning it a View (e.g. override val root = coordinatorLayout { ... } ). Then create your views (usually putting them as final properties, like root ), and add them to the ViewGroup s they belong to, so they are direct, or indirect children of root (in the likely case where you have multiple views in your UI and root is therefore a ViewGroup ).","title":"Implementing the Ui interface"},{"location":"modules/views-dsl/#using-ui-implementations","text":"To use a Ui implementation from an Activity subclass, just call setContentView(ui) . To use it from any other place, just get the root property. In a Fragment subclass, that will mean returning it from onCreateView(\u2026) . You can also use any function or property you've declared in your sub-interface or implementation. Here are two examples: * Using a public property of type Button to set it an OnClickListener in the place where the Ui is used (like an Activity or a Fragment that connects your UI to a ViewModel and any other components). * Call a method called animateGoalReached() .","title":"Using Ui implementations"},{"location":"modules/views-dsl/#simple-examples","text":"See concrete examples in MainUi and DemoUi with their respective Activities MainActivity and DemoActivity .","title":"Simple examples"},{"location":"modules/views-dsl/#possibilities-brought-by-the-ui-interface","text":"","title":"Possibilities brought by the Ui interface"},{"location":"modules/views-dsl/#ide-preview","text":"With the UiPreView class, you can preview your Ui implementations right from the IDE, (requires Android Studio 4.0 or newer). You can do it in code and have access to it contextually by selecting the \"Split\" or \"Design\" view in the top right corner of the editor, or you can do it in xml and benefit from options not yet available in View subclasses preview such as configuration switching (night mode, locale, etc.). While the real app might show actual data, you'll likely want to show sample data in the IDE preview. To support this use case in the best way possible such as there's no impact on the production code, Splitties brings the isInPreview inline extension property for Ui and View . When your app is compiled in release mode, it evaluates to false as a constant value (unlike View.isInEditmode ), which means that any code path under this condition will be removed by the compiler (kotlinc), and R8 or proguard will then remove any extra code that was only used in the IDE preview.","title":"IDE Preview"},{"location":"modules/views-dsl/#ide-preview-example","text":"Below is a preview example in Kotlin that the IDE can display. //region IDE preview @Deprecated ( \"For IDE preview only\" , level = DeprecationLevel . HIDDEN ) private class MainUiImplPreview ( context : Context , attrs : AttributeSet? = null , defStyleAttr : Int = 0 ) : UiPreView ( context = context . withTheme ( R . style . AppTheme ), attrs = attrs , defStyleAttr = defStyleAttr , createUi = { MainUiImpl ( it ) } ) //endregion It is surrounded by a \"region\" so it can be collapsed by the IDE as you can see in the screenshot just below. Below is a preview xml layout example that the IDE can display. It assumes there's a class implementing Ui named MainUi in the main subpackage (relative to the app/library package name). Beware that for the xml approach, any refactoring changes will not be reflected in the xml file, so if you change the package or the name of your Ui implementation class, you'll have to remember to edit the xml preview too to keep it working. <splitties.views.dsl.idepreview.UiPreView xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:app= \"http://schemas.android.com/apk/res-auto\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" app:splitties_class_package_name_relative= \"main.MainUi\" /> Here's a screenshot of how it looks like with DemoUi from the sample after the mergeDebugJavaResource gradle task has been run:","title":"IDE Preview Example"},{"location":"modules/views-dsl/#important-info-regarding-xml-based-ide-preview","text":"","title":"Important info regarding xml based IDE Preview"},{"location":"modules/views-dsl/#interfaces-parameters","text":"In order for the xml preview to work, your Ui subclass need to have its first parameter of type Context . For the subsequent parameters (if applicable), any interface is supported, but its methods need to not be called when this view is created and drawn, or an exception will be thrown. A special support has been added for CoroutineContext and CoroutineScope , so there's no exception thrown if you use an actor or other code relying on coroutines at init or drawing time.","title":"Interfaces parameters"},{"location":"modules/views-dsl/#known-issues-and-their-workaround","text":"If preview doesn't work or doesn't reflect the latest changes, it's likely because you didn't execute the mergeDebugJavaResource gradle task on your project (module actually). IDE preview currently only works with compiled classes and xml layouts. Running the mergeDebugJavaResource gradle task will save you time as it doesn't involve all the subsequent tasks that package a full apk.","title":"Known issues and their workaround"},{"location":"modules/views-dsl/#finding-a-suitable-constructor-to-instantiate-your-ui","text":"UiPreView is compatible with Ui implementations with two kind of constructors: * Constructors with a single Context parameter. * Constructors whose first parameter is a Context and other parameters are interfaces. Note that the interface methods need to not be called during preview, or an UnsupportedOperationException will be raised because UiPreView can only create stub implementations. You can use View.isInEditMode to skip code for preview if really needed.","title":"Finding a suitable constructor to instantiate your UI"},{"location":"modules/views-dsl/#finding-the-class","text":"When using the splitties_class_package_name_relative attribute, the UiPreView class will take the packageName returned from the Context and append a dot plus the value of the attribute to get the class name of your Ui implementation. However, you may have configured your build so your debug buildType has an applicationId suffix that is usually .debug like show in the example below: buildTypes { debug { applicationIdSuffix \".debug\" // This changes the packageName returned from a Context versionNameSuffix \"-DEBUG\" } release { // Config of your release build } } That's why by default, the UiPreView class will drop any .debug suffix found in the package name before trying to instantiate the class. If you use another suffix, or have other suffixes for other debuggable buildTypes, or use productFlavors, you're in luck! The package name suffix to drop is configurable from your resources. Just copy and paste the string resource below in your project in a value resource file named something like config.xml or do_not_translate.xml , and edit it to the suffix you use: <string name= \"splitties_views_dsl_ide_preview_package_name_suffix\" translatable= \"false\" > .debug </string> This will override the default value from the library. You can also override the splitties_ui_preview_base_package_names string array resource and add all the base package names where you have implementations of the Ui interface you want to preview. You can see such an example in the sample here . This can be handy if you change the applicationId , or if you have a modularized codebase. Alternatively, you can use the splitties_class_fully_qualified_name attribute instead and specify the full class name with its package.","title":"Finding the class"},{"location":"modules/views-dsl/#modular-user-interface-contracts","text":"While having a dedicated class for user interface, that is agnostic from where it will be used (Activity, Fragment, IDE Preview\u2026), is a great first step to a modular user interface code, you can go further. Instead of exposing your Ui implementation directly to the Activity or Fragment, you can decide to write several interfaces that define a contract that your Activity, Fragment, ViewModel (beware of leaks), or whatever will need, and implement all of these with one or more classes. For example, let's say you are developing an email app. You write two interfaces: InboxUi and ComposeUi that both extend the Ui interface. You add to the interfaces all the functions (including any suspend fun ), properties and other symbols you may need to expose to the Activity, Fragment, ViewModel or whatever. Then you implement these two interfaces, with either one class or two, depending on whether you want to display them separately or not.","title":"Modular user interface contracts"},{"location":"modules/views-dsl/#easier-multi-form-factors-support","text":"Modular UI contracts open the door to a great benefit: an easier way to support multiple form factors (smartphones, smartwatches, tablets, laptops, cars\u2026). In the previous example, we highlighted the fact that you could have multiple interfaces that expose the needed symbols, and then decide to implement these interfaces in one, or multiple classes. This can help you support different form factors with zero, or only a few changes in non-UI code as it is no longer relies on a specific implementation. It is planned to add such examples in the samples of this repository. If you want to have them faster, please open an issue so the examples can be discussed. Also, maybe you, or someone you know, can contribute.","title":"Easier multi form factors support"},{"location":"modules/views-dsl/#multiplatform-user-interface-contracts","text":"Here's an example of how you may write multiplatform user interface contracts: In Kotlin common code, you would write an interface that is platform-agnostic but declares the needed symbols that all platforms can share: Continuing our email app example, you would write these two interfaces: interface InboxUiContract { // Whatever you need } interface ComposeUiContract { // Whatever you need } Then write to sub-interfaces for each platform you want to support, Android and iOS in this example: interface AndroidInboxUi : InboxUiContract , Ui interface IOSInboxUi : InboxUiContract { val root : UIView } And you may finally implement them for each platform, still supporting multiple form-factors and platform variants if needed. The two common interfaces ( InboxUiContract and ComposeUiContract ) could be replaced by abstract classes in case you need to have backing fields, final declarations or final implementations, as long as they don't reference Splitties Ui interface and no platform specific code.","title":"Multiplatform user interface contracts"},{"location":"modules/views-dsl/#testing","text":"Having your user interface as an interface can make it easy to mock it, and simulate user interactions for testing purposes.","title":"Testing"},{"location":"modules/views-dsl/#redesign","text":"If you expect an interface for the user interface, then it becomes easy to replace an implementation by another one in case you're redesigning your app. You can also split your UI contracts (the interface s) into smaller subsets before starting a redesign if needed, this can be helpful if you want to move some UI controls to another area of the application, or just organize things differently.","title":"Redesign"},{"location":"modules/views-dsl/#ab-testing","text":"When you have multiple UI interface s implementations, you can then swap them at runtime for A/B testing, allowing you to test which UI works the best for what you determined.","title":"A/B Testing"},{"location":"modules/views-dsl/#additional-modules","text":"There are additional splits for extended support. Views DSL\u2026 * AppCompat provides proper styling to Button , TextView , EditText and other widgets. views like coloredFlatButton . * ConstraintLayout provides support for ConstraintLayout.LayoutParams . ViewGroup s and bottom sheets. * IDE preview provides the ability to preview your user interfaces right from the IDE. * Material provides extensions for Material Components * RecyclerView provides extensions to have scrollbars and proper itemView layout parameters.","title":"Additional modules"},{"location":"modules/views-dsl/Kotlin-UIs-vs-xml-layouts/","text":"Why a Kotlin Views DSL over xml layouts? \u00b6 There are reasons Splitties Views DSL, an alternative to xml layouts has been built for Android. This document is a simple pros and cons of each approach so you can judge by yourself. Facts \u00b6 If we don't count imports and copyright headers, the xml version of MainUi (from the sample) was more than 100% lengthier (50 lines with Kotlin, 102 lines in xml, across the activity_main.xml and content_main.xml files.). Pros and cons \u00b6 Pros of xml layouts \u00b6 You can almost instantly preview a layout file from the IDE (despite the increased RAM and CPU usage). You can declare a new compile time constant id resource on the fly with @+id/some_new_id You kind of have a WYSIWYG (what you see is what you get) experience in the IDE. Kind of because it includes only xml layouts and compiled custom views. Logic in code can't be previewed in the IDE with xml layouts, unless it is in a custom view. Cons of xml layouts \u00b6 You repeat android and app over and over, cluttering the code, resulting in hardly readable code . Layout parameters and view attributes are mixed together and are not so well ordered in some cases such as when using ConstraintLayout . Some things that affect your Views can only be done from code, leading to 2 problems: You can't preview them, and your UI code is split over at least 2 files . xml layout inflation involves reflection , which can slow down UI creating, on large layouts and/or lower end devices. Some attributes that could make layout files easier to read like horitontalMargin and verticalMargin are only available on API 26+ in xml . If you support API 16 and lower, LTR support is subpar . When specifying start/end margins, you still need to specify left and right values for API 16 or older (while start could default to left when RTL is not supported\u2026). You also need to keep them in sync manually when you change the values. You can't take advantage of Kotlin extensions and other Kotlin features. If you want to make your UI dynamic, you need to use code, and xml is not really code, so you need to split your UI logic, being more error-prone in the long run. Reusing parts of UI is hard and verbose, because you can only include other files, but there's no things like functions for example. Pros of Splitties Views DSL \u00b6 It is concise (most layouts converted from xml end up shorter, sometimes even when counting the import lines). Is is more expressive and you can make it even better by defining extension function or properties on the Views, LayoutParams, etc, so you can hide a set of operations behind a simple function call. There are no restrictions on the language features you can use in your UI code, you're not just limited to xml available attributes and resources. You can reuse UI code in much more and easier ways than you can do with xml layouts + code. Your Ui can implement an interface so you can easily swap implementations. This can be handy for A/B testing, allowing more user preferences to tweak or completely change the UI, and more. Layout direction defaults to LTR before API 17 and you can keep using start/end without added boilerplate. You can preview layouts in Android Studio , with any included logic being taken into account. Layout parameters are not mixed with View config. No reflection involved. No need for findViewById(\u2026) and the implied lookup costs. Cons of Splitties Views DSL \u00b6 Preview requires a running the compileDebugKotlin gradle task (no need to perform a full build, also, you're less likely to need preview thanks to additional type safety and more readable UI code). You can't create a compile time constant View id on the fly (but you can have ids generated automatically at runtime, declare an id resource easily or reuse one declared on-the-fly from an existing xml layout).","title":"Why a Kotlin Views DSL over xml layouts?"},{"location":"modules/views-dsl/Kotlin-UIs-vs-xml-layouts/#why-a-kotlin-views-dsl-over-xml-layouts","text":"There are reasons Splitties Views DSL, an alternative to xml layouts has been built for Android. This document is a simple pros and cons of each approach so you can judge by yourself.","title":"Why a Kotlin Views DSL over xml layouts?"},{"location":"modules/views-dsl/Kotlin-UIs-vs-xml-layouts/#facts","text":"If we don't count imports and copyright headers, the xml version of MainUi (from the sample) was more than 100% lengthier (50 lines with Kotlin, 102 lines in xml, across the activity_main.xml and content_main.xml files.).","title":"Facts"},{"location":"modules/views-dsl/Kotlin-UIs-vs-xml-layouts/#pros-and-cons","text":"","title":"Pros and cons"},{"location":"modules/views-dsl/Kotlin-UIs-vs-xml-layouts/#pros-of-xml-layouts","text":"You can almost instantly preview a layout file from the IDE (despite the increased RAM and CPU usage). You can declare a new compile time constant id resource on the fly with @+id/some_new_id You kind of have a WYSIWYG (what you see is what you get) experience in the IDE. Kind of because it includes only xml layouts and compiled custom views. Logic in code can't be previewed in the IDE with xml layouts, unless it is in a custom view.","title":"Pros of xml layouts"},{"location":"modules/views-dsl/Kotlin-UIs-vs-xml-layouts/#cons-of-xml-layouts","text":"You repeat android and app over and over, cluttering the code, resulting in hardly readable code . Layout parameters and view attributes are mixed together and are not so well ordered in some cases such as when using ConstraintLayout . Some things that affect your Views can only be done from code, leading to 2 problems: You can't preview them, and your UI code is split over at least 2 files . xml layout inflation involves reflection , which can slow down UI creating, on large layouts and/or lower end devices. Some attributes that could make layout files easier to read like horitontalMargin and verticalMargin are only available on API 26+ in xml . If you support API 16 and lower, LTR support is subpar . When specifying start/end margins, you still need to specify left and right values for API 16 or older (while start could default to left when RTL is not supported\u2026). You also need to keep them in sync manually when you change the values. You can't take advantage of Kotlin extensions and other Kotlin features. If you want to make your UI dynamic, you need to use code, and xml is not really code, so you need to split your UI logic, being more error-prone in the long run. Reusing parts of UI is hard and verbose, because you can only include other files, but there's no things like functions for example.","title":"Cons of xml layouts"},{"location":"modules/views-dsl/Kotlin-UIs-vs-xml-layouts/#pros-of-splitties-views-dsl","text":"It is concise (most layouts converted from xml end up shorter, sometimes even when counting the import lines). Is is more expressive and you can make it even better by defining extension function or properties on the Views, LayoutParams, etc, so you can hide a set of operations behind a simple function call. There are no restrictions on the language features you can use in your UI code, you're not just limited to xml available attributes and resources. You can reuse UI code in much more and easier ways than you can do with xml layouts + code. Your Ui can implement an interface so you can easily swap implementations. This can be handy for A/B testing, allowing more user preferences to tweak or completely change the UI, and more. Layout direction defaults to LTR before API 17 and you can keep using start/end without added boilerplate. You can preview layouts in Android Studio , with any included logic being taken into account. Layout parameters are not mixed with View config. No reflection involved. No need for findViewById(\u2026) and the implied lookup costs.","title":"Pros of Splitties Views DSL"},{"location":"modules/views-dsl/Kotlin-UIs-vs-xml-layouts/#cons-of-splitties-views-dsl","text":"Preview requires a running the compileDebugKotlin gradle task (no need to perform a full build, also, you're less likely to need preview thanks to additional type safety and more readable UI code). You can't create a compile time constant View id on the fly (but you can have ids generated automatically at runtime, declare an id resource easily or reuse one declared on-the-fly from an existing xml layout).","title":"Cons of Splitties Views DSL"},{"location":"modules/views-dsl-appcompat/","text":"Views DSL AppCompat \u00b6 AppCompat extension of Views DSL Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsDslAppcompat , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-dsl-appcompat . How AppCompat works with xml \u00b6 When using an AppCompat theme, the LayoutInflater replaces the platform widgets like TextView and Button found in your xml layouts by a compatibility version (i.e. AppCompatButton , AppCompatTextView , etc.). If you're curious to see how it works, look for the method createView in the AppCompatViewInflater class from the androidx.appcompat.app package. How AppCompat works with Splitties Views DSL \u00b6 Since the LayoutInflater only works on xml, if you use view(::TextView) with Views DSL, you get a TextView instance, not an AppCompatTextView instance. This means it will not have AppCompat features and styling (e.g. auto size for TextView ). However, if you use textView() it will automatically delegate to this split if in the dependencies, returning an AppCompatTextView instance. This works for all AppCompat widgets. If you want to use a style defined in appcompat (like Widget_AppCompat_Button_Colored ), just cache locally an AppCompatStyles instance and use its properties and functions. Supported widgets \u00b6 All AppCompat widgets are supported. Here's the full list: * TextView * ImageView * Button * EditText * Spinner * ImageButton * CheckBox * RadioButton * CheckedTextView * AutoCompleteTextView * MultiAutoCompleteTextView * RatingBar * SeekBar Just call the related method that is the camelCase version of the PascalCase constructor. For example, you can call seekBar(\u2026) { \u2026 } and you'll receive an AppCompatSeekBar instance. Note that automatically doesn't mean magically. In fact, no reflection is involved (contrary to xml inflation). You can also see the source of the function that maps to AppCompat widgets versions , and the Initializer that makes it zero initialization on your side . There's also support for Toolbar with the toolbar function, and SwitchCompat with the switch function. Note that the returned Toolbar handles config changes. Multi-process apps \u00b6 If your app needs to use AppCompat themed widgets in the non default process, you'll need to manually setup ViewFactory, so it uses AppCompat. Here's how you need to do it: 1. Copy and paste this Initializer into a package of an android library/app module of your project 2. Create an internal subclass of androidx.startup.InitializationProvider 4. Declare that subclass in the AndroidManifest.xml of the module exactly like it is done here . To do so, copy and paste it, then fix the package of the class under the android:name xml attribute of the provider tag, specify the android:process value to the one of your non default process, and finally changed the android:name xml attribute of the meta-data tag to the initializer you copied in the first step. Be sure to test it to make sure you have set it up properly.","title":"Views DSL AppCompat"},{"location":"modules/views-dsl-appcompat/#views-dsl-appcompat","text":"AppCompat extension of Views DSL Supported platforms: Android .","title":"Views DSL AppCompat"},{"location":"modules/views-dsl-appcompat/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsDslAppcompat , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-dsl-appcompat .","title":"Setup"},{"location":"modules/views-dsl-appcompat/#how-appcompat-works-with-xml","text":"When using an AppCompat theme, the LayoutInflater replaces the platform widgets like TextView and Button found in your xml layouts by a compatibility version (i.e. AppCompatButton , AppCompatTextView , etc.). If you're curious to see how it works, look for the method createView in the AppCompatViewInflater class from the androidx.appcompat.app package.","title":"How AppCompat works with xml"},{"location":"modules/views-dsl-appcompat/#how-appcompat-works-with-splitties-views-dsl","text":"Since the LayoutInflater only works on xml, if you use view(::TextView) with Views DSL, you get a TextView instance, not an AppCompatTextView instance. This means it will not have AppCompat features and styling (e.g. auto size for TextView ). However, if you use textView() it will automatically delegate to this split if in the dependencies, returning an AppCompatTextView instance. This works for all AppCompat widgets. If you want to use a style defined in appcompat (like Widget_AppCompat_Button_Colored ), just cache locally an AppCompatStyles instance and use its properties and functions.","title":"How AppCompat works with Splitties Views DSL"},{"location":"modules/views-dsl-appcompat/#supported-widgets","text":"All AppCompat widgets are supported. Here's the full list: * TextView * ImageView * Button * EditText * Spinner * ImageButton * CheckBox * RadioButton * CheckedTextView * AutoCompleteTextView * MultiAutoCompleteTextView * RatingBar * SeekBar Just call the related method that is the camelCase version of the PascalCase constructor. For example, you can call seekBar(\u2026) { \u2026 } and you'll receive an AppCompatSeekBar instance. Note that automatically doesn't mean magically. In fact, no reflection is involved (contrary to xml inflation). You can also see the source of the function that maps to AppCompat widgets versions , and the Initializer that makes it zero initialization on your side . There's also support for Toolbar with the toolbar function, and SwitchCompat with the switch function. Note that the returned Toolbar handles config changes.","title":"Supported widgets"},{"location":"modules/views-dsl-appcompat/#multi-process-apps","text":"If your app needs to use AppCompat themed widgets in the non default process, you'll need to manually setup ViewFactory, so it uses AppCompat. Here's how you need to do it: 1. Copy and paste this Initializer into a package of an android library/app module of your project 2. Create an internal subclass of androidx.startup.InitializationProvider 4. Declare that subclass in the AndroidManifest.xml of the module exactly like it is done here . To do so, copy and paste it, then fix the package of the class under the android:name xml attribute of the provider tag, specify the android:process value to the one of your non default process, and finally changed the android:name xml attribute of the meta-data tag to the initializer you copied in the first step. Be sure to test it to make sure you have set it up properly.","title":"Multi-process apps"},{"location":"modules/views-dsl-constraintlayout/","text":"Views DSL ConstraintLayout \u00b6 ConstraintLayout extension of Views DSL . Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsDslConstraintlayout , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-dsl-constraintlayout . Table of contents \u00b6 ConstraintLayout tailored lParams extension ConstraintLayout.LayoutParams extensions for safe and readable usage ConstraintLayout tailored lParams extension \u00b6 The lParams() extension function on ConstraintLayout looks to be similar to the similarly named extensions on LinearLayout and FrameLayout , but there are two key differences: * Since ConstraintLayout children are meant to have constraints, their default width and height are matchConstraints , not wrapContent . That means that you'll often have to specify height = wrapContent for things like TextView s and Button s. * In xml, match_parent is not supported for ConstraintLayout and can decrease performance (the alternative being adding 0dp + 2 parent relative constraints). This is not the case here as matchParent is rewritten as matchConstraints with the appropriate parent relative constraints . The result is a more readable UI code, without performance compromises. ConstraintLayout.LayoutParams extensions for safe and readable usage \u00b6 With this split also comes a set of extension functions to use in lParams(\u2026) { \u2026 } . Almost all of them have optional margin and goneMargin parameters. Center relatively to parent: * centerHorizontally(\u2026) * centerVertically(\u2026) * centerInParent(\u2026) Parent relative constraints: * topOfParent(\u2026) * bottomOfParent(\u2026) * startOfParent(\u2026) * endOfParent(\u2026) * leftOfParent(\u2026) * rightOfParent(\u2026) Center relatively to another View : * alignVerticallyOn(\u2026) * alignHorizontallyOn(\u2026) * centerOn(\u2026) View relative constraints: * above(\u2026) (alias to bottomToTopOf(\u2026) ) * below(\u2026) (alias to topToBottomOf(\u2026) ) * before(\u2026) (alias to endToStartOf(\u2026) ) * after(\u2026) (alias to startToEndOf(\u2026) ) * topToTopOf(\u2026) * topToBottomOf(\u2026) * bottomToTopOf(\u2026) * bottomToBottomOf(\u2026) * baselineToBaselineOf(\u2026) * startToStartOf(\u2026) * startToEndOf(\u2026) * endToStartOf(\u2026) * endToEndOf(\u2026) * leftToLeftOf(\u2026) * leftToRightOf(\u2026) * rightToRightOf(\u2026) * rightToLeftOf(\u2026) Chains: * horizontalChain(\u2026) { \u2026 } and its companion horizontalMargin extension for List<View> . * verticalChain(\u2026) { \u2026 } and its companion verticalMargin extension for List<View> . Barriers: * barrier(\u2026) which takes a BarrierType (inline class) and a list or vararg of View s. * startBarrier(\u2026) , leftBarrier(\u2026) , topBarrier(\u2026) , endBarrier(\u2026) , rightBarrier(\u2026) and bottomBarrier(\u2026) Guidelines: * verticalGuideline(\u2026) and horizontalGuideline(\u2026) which take a begin offset (pixels), an end offset, or a ratio (between 0 and 1). Groups: * group(\u2026) which takes the views to group. These methods come with a great bonus feature: If a View involved in a constraint has no valid id , then a generated one is automatically assigned to it! These generated ids can't clash with aapt/xml ids, so it's safe to put xml defined ids on some views that need to have their state saved (e.g. a RecyclerView , an EditText or a CheckBox ) in the same layout. Note that View ids are crucial to ConstraintLayout machinery.","title":"Views DSL ConstraintLayout"},{"location":"modules/views-dsl-constraintlayout/#views-dsl-constraintlayout","text":"ConstraintLayout extension of Views DSL . Supported platforms: Android .","title":"Views DSL ConstraintLayout"},{"location":"modules/views-dsl-constraintlayout/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsDslConstraintlayout , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-dsl-constraintlayout .","title":"Setup"},{"location":"modules/views-dsl-constraintlayout/#table-of-contents","text":"ConstraintLayout tailored lParams extension ConstraintLayout.LayoutParams extensions for safe and readable usage","title":"Table of contents"},{"location":"modules/views-dsl-constraintlayout/#constraintlayout-tailored-lparams-extension","text":"The lParams() extension function on ConstraintLayout looks to be similar to the similarly named extensions on LinearLayout and FrameLayout , but there are two key differences: * Since ConstraintLayout children are meant to have constraints, their default width and height are matchConstraints , not wrapContent . That means that you'll often have to specify height = wrapContent for things like TextView s and Button s. * In xml, match_parent is not supported for ConstraintLayout and can decrease performance (the alternative being adding 0dp + 2 parent relative constraints). This is not the case here as matchParent is rewritten as matchConstraints with the appropriate parent relative constraints . The result is a more readable UI code, without performance compromises.","title":"ConstraintLayout tailored lParams extension"},{"location":"modules/views-dsl-constraintlayout/#constraintlayoutlayoutparams-extensions-for-safe-and-readable-usage","text":"With this split also comes a set of extension functions to use in lParams(\u2026) { \u2026 } . Almost all of them have optional margin and goneMargin parameters. Center relatively to parent: * centerHorizontally(\u2026) * centerVertically(\u2026) * centerInParent(\u2026) Parent relative constraints: * topOfParent(\u2026) * bottomOfParent(\u2026) * startOfParent(\u2026) * endOfParent(\u2026) * leftOfParent(\u2026) * rightOfParent(\u2026) Center relatively to another View : * alignVerticallyOn(\u2026) * alignHorizontallyOn(\u2026) * centerOn(\u2026) View relative constraints: * above(\u2026) (alias to bottomToTopOf(\u2026) ) * below(\u2026) (alias to topToBottomOf(\u2026) ) * before(\u2026) (alias to endToStartOf(\u2026) ) * after(\u2026) (alias to startToEndOf(\u2026) ) * topToTopOf(\u2026) * topToBottomOf(\u2026) * bottomToTopOf(\u2026) * bottomToBottomOf(\u2026) * baselineToBaselineOf(\u2026) * startToStartOf(\u2026) * startToEndOf(\u2026) * endToStartOf(\u2026) * endToEndOf(\u2026) * leftToLeftOf(\u2026) * leftToRightOf(\u2026) * rightToRightOf(\u2026) * rightToLeftOf(\u2026) Chains: * horizontalChain(\u2026) { \u2026 } and its companion horizontalMargin extension for List<View> . * verticalChain(\u2026) { \u2026 } and its companion verticalMargin extension for List<View> . Barriers: * barrier(\u2026) which takes a BarrierType (inline class) and a list or vararg of View s. * startBarrier(\u2026) , leftBarrier(\u2026) , topBarrier(\u2026) , endBarrier(\u2026) , rightBarrier(\u2026) and bottomBarrier(\u2026) Guidelines: * verticalGuideline(\u2026) and horizontalGuideline(\u2026) which take a begin offset (pixels), an end offset, or a ratio (between 0 and 1). Groups: * group(\u2026) which takes the views to group. These methods come with a great bonus feature: If a View involved in a constraint has no valid id , then a generated one is automatically assigned to it! These generated ids can't clash with aapt/xml ids, so it's safe to put xml defined ids on some views that need to have their state saved (e.g. a RecyclerView , an EditText or a CheckBox ) in the same layout. Note that View ids are crucial to ConstraintLayout machinery.","title":"ConstraintLayout.LayoutParams extensions for safe and readable usage"},{"location":"modules/views-dsl-coordinatorlayout/","text":"Views DSL CoordinatorLayout \u00b6 CoordinatorLayout extension of Views DSL . Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsDslCoordinatorlayout , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-dsl-coordinatorlayout . Table of contents \u00b6 Functions to instantiate a CoordinatorLayout CoordinatorLayout extensions * defaultLParams * appBarLParams CoordinatorLayout.LayoutParams extensions * anchorTo Functions to instantiate a CoordinatorLayout \u00b6 Instead of using view(::CoordinatorLayout, \u2026) { \u2026 } , you can use coordinatorLayout(\u2026) { \u2026 } . CoordinatorLayout extensions \u00b6 defaultLParams \u00b6 This extension has default width and height set to wrapContent and an optional gravity parameter. appBarLParams \u00b6 Has a matchParent width. Use it when adding an AppBarLayout or a similar View that takes the app bar role. CoordinatorLayout.LayoutParams extensions \u00b6 anchorTo \u00b6 Anchors the passed View with the specified gravity, setting a generated id if it had none.","title":"Views DSL CoordinatorLayout"},{"location":"modules/views-dsl-coordinatorlayout/#views-dsl-coordinatorlayout","text":"CoordinatorLayout extension of Views DSL . Supported platforms: Android .","title":"Views DSL CoordinatorLayout"},{"location":"modules/views-dsl-coordinatorlayout/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsDslCoordinatorlayout , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-dsl-coordinatorlayout .","title":"Setup"},{"location":"modules/views-dsl-coordinatorlayout/#table-of-contents","text":"Functions to instantiate a CoordinatorLayout CoordinatorLayout extensions * defaultLParams * appBarLParams CoordinatorLayout.LayoutParams extensions * anchorTo","title":"Table of contents"},{"location":"modules/views-dsl-coordinatorlayout/#functions-to-instantiate-a-coordinatorlayout","text":"Instead of using view(::CoordinatorLayout, \u2026) { \u2026 } , you can use coordinatorLayout(\u2026) { \u2026 } .","title":"Functions to instantiate a CoordinatorLayout"},{"location":"modules/views-dsl-coordinatorlayout/#coordinatorlayout-extensions","text":"","title":"CoordinatorLayout extensions"},{"location":"modules/views-dsl-coordinatorlayout/#defaultlparams","text":"This extension has default width and height set to wrapContent and an optional gravity parameter.","title":"defaultLParams"},{"location":"modules/views-dsl-coordinatorlayout/#appbarlparams","text":"Has a matchParent width. Use it when adding an AppBarLayout or a similar View that takes the app bar role.","title":"appBarLParams"},{"location":"modules/views-dsl-coordinatorlayout/#coordinatorlayoutlayoutparams-extensions","text":"","title":"CoordinatorLayout.LayoutParams extensions"},{"location":"modules/views-dsl-coordinatorlayout/#anchorto","text":"Anchors the passed View with the specified gravity, setting a generated id if it had none.","title":"anchorTo"},{"location":"modules/views-dsl-ide-preview/","text":"Views DSL IDE preview [DEPRECATED] \u00b6 Preview UIs made with Splitties Views DSL. This split has been deprecated and is now included directly into the debug variant of the Views DSL split. The package name has been left unchanged. Dependency (for reference) \u00b6 debugImplementation ( \"com.louiscad.splitties:splitties-views-dsl-ide-preview:$splitties_version\" )","title":"Views DSL IDE preview \\[DEPRECATED\\]"},{"location":"modules/views-dsl-ide-preview/#views-dsl-ide-preview-deprecated","text":"Preview UIs made with Splitties Views DSL. This split has been deprecated and is now included directly into the debug variant of the Views DSL split. The package name has been left unchanged.","title":"Views DSL IDE preview [DEPRECATED]"},{"location":"modules/views-dsl-ide-preview/#dependency-for-reference","text":"debugImplementation ( \"com.louiscad.splitties:splitties-views-dsl-ide-preview:$splitties_version\" )","title":"Dependency (for reference)"},{"location":"modules/views-dsl-material/","text":"Views DSL Material \u00b6 Material Components extension of Views DSL Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsDslMaterial , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-dsl-material . Table of contents \u00b6 Functions to instantiate Views and ViewGroups from Material Components Multi-process apps Use Material Components xml styles in a typesafe way Extensions on ViewGroups from Material Components AppBarLayout extensions defaultLParams Values for scrollFlags CollapsingToolbarLayout extensions defaultLParams actionBarLParams Values for collapseMode CoordinatorLayout extensions More in Views DSL CoordinatorLayout contentScrollingWithAppBarLParams() Bottom sheet behavior extensions bottomSheetBehavior Bottom sheet state extensions TextInputLayout helper Functions to instantiate Views and ViewGroups from Material Components \u00b6 Instead of using view(::AppBarLayout) { \u2026 } and similar, you can use appBarLayout(\u2026) { \u2026 } . All widgets from Material Components are supported. To see the list, check the implementations for Views and ViewGroups . Note that there two bonuses in this split: * When calling appBarLayout(\u2026) { \u2026 } , you get an implementation that fixes a scrolling bug from Material Components where first click is ignored. * When calling collapsingToolbarLayout(\u2026) { \u2026 } , you get an implementation that handles config changes. Multi-process apps \u00b6 If your app needs to use Material themed widgets in the non default process, you'll need to manually setup ViewFactory, so it uses Material Components. Here's how you need to do it: 1. Copy and paste this Initializer into a package of an android library/app module of your project 2. Create an internal subclass of androidx.startup.InitializationProvider 4. Declare that subclass in the AndroidManifest.xml of the module exactly like it is done here . To do so, copy and paste it, then fix the package of the class under the android:name xml attribute of the provider tag, specify the android:process value to the one of your non default process, and finally changed the android:name xml attribute of the meta-data tag to the initializer you copied in the first step. Be sure to test it to make sure you have set it up properly. Use Material Components xml styles in a typesafe way \u00b6 Since Material Components styles are not included by default inside the theme, you need to load them first. This is simply done with the following code: private val materialStyles = MaterialComponentsStyles ( ctx ) You can then use styles using the MaterialComponentsStyles instance. Here's an example: val bePoliteBtn = materialStyles . button . outlined { textResource = R . string . be_polite } Styles are supported for BottomAppBar , BottomNavigationView , MaterialButton , Chip , TabLayout and TextInputLayout . Extensions on ViewGroups from Material Components \u00b6 AppBarLayout extensions \u00b6 defaultLParams \u00b6 This extension function has a default width of matchParent and a default height of wrapContent so you don't have to specify them in most of the cases. It also has a scrollFlags parameter which defaults to ENTER_ALWAYS , same as when inflated from an xml layout. Use it when you add a View to an AppBarLayout . Values for scrollFlags \u00b6 SCROLL , EXIT_UNTIL_COLLAPSED , ENTER_ALWAYS , ENTER_ALWAYS_COLLAPSED and SNAP are extension properties on AppBarLayout that are meant to be used as flags (using or if you use multiple ones) with the scrollFlags parameter of the defaultLParams function mentioned above. They are provided for your convenience so they appear in autocomplete when relevant. CollapsingToolbarLayout extensions \u00b6 defaultLParams \u00b6 As for AppBarLayout , this extension function has a default width of matchParent and a default height of wrapContent so you don't have to specify them in most of the cases. It also has two optional parameters: - collapseMode , which defaults to COLLAPSE_MODE_OFF - parallaxMultiplier , which defaults to 0.5f (default value as of 27.1.1) Use it when you add a View to a CollapsingToolbarLayout . actionBarLParams \u00b6 Similar to defaultLParams , but the height is R.attr.actionBarSize instead of wrapContent . Use it when adding a Toolbar . Values for collapseMode \u00b6 PIN and PARALLAX are extension properties on CollapsingToolbarLayout that are meant to be used for the collapseMode parameter of the defaultLParams and actionBarLParams functions mentioned above. They are provided for your convenience so they appear in autocomplete when relevant. CoordinatorLayout extensions \u00b6 More in Views DSL CoordinatorLayout \u00b6 This split has a transitive dependency on Views DSL CoordinatorLayout which includes coordinatorLayout instantiating function, as well as layout params functions like defaultLParams , appBarLParams , and anchorTo . contentScrollingWithAppBarLParams() \u00b6 If your CoordinatorLayout has an AppbarLayout and scrolling content (e.g. a RecyclerView ), use this method to add the scrolling content View. It sets an AppBarLayout.ScrollingViewBehavior under the hood. This function accepts an optional config lambda. Bottom sheet behavior extensions \u00b6 bottomSheetBehavior \u00b6 This extension function on Ui that takes an optional initialization lambda creates a BottomSheetBehavior to use on CoordinatorLayout.LayoutParams . Bottom sheet state extensions \u00b6 This split also includes extensions on BottomSheetBehavior : * hidden and expanded : read-write extension properties. * hide() and expand() : extension functions. They make playing with your bottom sheets programmatically a breeze. See their KDoc to see their exact behavior. TextInputLayout helper \u00b6 The addInput extension function on TextInputLayout takes a required id used for the TextInputEditText that it creates and adds to the layout. The id is required so the content of the user input is saved in instance state even if the host Activity is killed by the system.","title":"Views DSL Material"},{"location":"modules/views-dsl-material/#views-dsl-material","text":"Material Components extension of Views DSL Supported platforms: Android .","title":"Views DSL Material"},{"location":"modules/views-dsl-material/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsDslMaterial , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-dsl-material .","title":"Setup"},{"location":"modules/views-dsl-material/#table-of-contents","text":"Functions to instantiate Views and ViewGroups from Material Components Multi-process apps Use Material Components xml styles in a typesafe way Extensions on ViewGroups from Material Components AppBarLayout extensions defaultLParams Values for scrollFlags CollapsingToolbarLayout extensions defaultLParams actionBarLParams Values for collapseMode CoordinatorLayout extensions More in Views DSL CoordinatorLayout contentScrollingWithAppBarLParams() Bottom sheet behavior extensions bottomSheetBehavior Bottom sheet state extensions TextInputLayout helper","title":"Table of contents"},{"location":"modules/views-dsl-material/#functions-to-instantiate-views-and-viewgroups-from-material-components","text":"Instead of using view(::AppBarLayout) { \u2026 } and similar, you can use appBarLayout(\u2026) { \u2026 } . All widgets from Material Components are supported. To see the list, check the implementations for Views and ViewGroups . Note that there two bonuses in this split: * When calling appBarLayout(\u2026) { \u2026 } , you get an implementation that fixes a scrolling bug from Material Components where first click is ignored. * When calling collapsingToolbarLayout(\u2026) { \u2026 } , you get an implementation that handles config changes.","title":"Functions to instantiate Views and ViewGroups from Material Components"},{"location":"modules/views-dsl-material/#multi-process-apps","text":"If your app needs to use Material themed widgets in the non default process, you'll need to manually setup ViewFactory, so it uses Material Components. Here's how you need to do it: 1. Copy and paste this Initializer into a package of an android library/app module of your project 2. Create an internal subclass of androidx.startup.InitializationProvider 4. Declare that subclass in the AndroidManifest.xml of the module exactly like it is done here . To do so, copy and paste it, then fix the package of the class under the android:name xml attribute of the provider tag, specify the android:process value to the one of your non default process, and finally changed the android:name xml attribute of the meta-data tag to the initializer you copied in the first step. Be sure to test it to make sure you have set it up properly.","title":"Multi-process apps"},{"location":"modules/views-dsl-material/#use-material-components-xml-styles-in-a-typesafe-way","text":"Since Material Components styles are not included by default inside the theme, you need to load them first. This is simply done with the following code: private val materialStyles = MaterialComponentsStyles ( ctx ) You can then use styles using the MaterialComponentsStyles instance. Here's an example: val bePoliteBtn = materialStyles . button . outlined { textResource = R . string . be_polite } Styles are supported for BottomAppBar , BottomNavigationView , MaterialButton , Chip , TabLayout and TextInputLayout .","title":"Use Material Components xml styles in a typesafe way"},{"location":"modules/views-dsl-material/#extensions-on-viewgroups-from-material-components","text":"","title":"Extensions on ViewGroups from Material Components"},{"location":"modules/views-dsl-material/#appbarlayout-extensions","text":"","title":"AppBarLayout extensions"},{"location":"modules/views-dsl-material/#defaultlparams","text":"This extension function has a default width of matchParent and a default height of wrapContent so you don't have to specify them in most of the cases. It also has a scrollFlags parameter which defaults to ENTER_ALWAYS , same as when inflated from an xml layout. Use it when you add a View to an AppBarLayout .","title":"defaultLParams"},{"location":"modules/views-dsl-material/#values-for-scrollflags","text":"SCROLL , EXIT_UNTIL_COLLAPSED , ENTER_ALWAYS , ENTER_ALWAYS_COLLAPSED and SNAP are extension properties on AppBarLayout that are meant to be used as flags (using or if you use multiple ones) with the scrollFlags parameter of the defaultLParams function mentioned above. They are provided for your convenience so they appear in autocomplete when relevant.","title":"Values for scrollFlags"},{"location":"modules/views-dsl-material/#collapsingtoolbarlayout-extensions","text":"","title":"CollapsingToolbarLayout extensions"},{"location":"modules/views-dsl-material/#defaultlparams_1","text":"As for AppBarLayout , this extension function has a default width of matchParent and a default height of wrapContent so you don't have to specify them in most of the cases. It also has two optional parameters: - collapseMode , which defaults to COLLAPSE_MODE_OFF - parallaxMultiplier , which defaults to 0.5f (default value as of 27.1.1) Use it when you add a View to a CollapsingToolbarLayout .","title":"defaultLParams"},{"location":"modules/views-dsl-material/#actionbarlparams","text":"Similar to defaultLParams , but the height is R.attr.actionBarSize instead of wrapContent . Use it when adding a Toolbar .","title":"actionBarLParams"},{"location":"modules/views-dsl-material/#values-for-collapsemode","text":"PIN and PARALLAX are extension properties on CollapsingToolbarLayout that are meant to be used for the collapseMode parameter of the defaultLParams and actionBarLParams functions mentioned above. They are provided for your convenience so they appear in autocomplete when relevant.","title":"Values for collapseMode"},{"location":"modules/views-dsl-material/#coordinatorlayout-extensions","text":"","title":"CoordinatorLayout extensions"},{"location":"modules/views-dsl-material/#more-in-views-dsl-coordinatorlayout","text":"This split has a transitive dependency on Views DSL CoordinatorLayout which includes coordinatorLayout instantiating function, as well as layout params functions like defaultLParams , appBarLParams , and anchorTo .","title":"More in Views DSL CoordinatorLayout"},{"location":"modules/views-dsl-material/#contentscrollingwithappbarlparams","text":"If your CoordinatorLayout has an AppbarLayout and scrolling content (e.g. a RecyclerView ), use this method to add the scrolling content View. It sets an AppBarLayout.ScrollingViewBehavior under the hood. This function accepts an optional config lambda.","title":"contentScrollingWithAppBarLParams()"},{"location":"modules/views-dsl-material/#bottom-sheet-behavior-extensions","text":"","title":"Bottom sheet behavior extensions"},{"location":"modules/views-dsl-material/#bottomsheetbehavior","text":"This extension function on Ui that takes an optional initialization lambda creates a BottomSheetBehavior to use on CoordinatorLayout.LayoutParams .","title":"bottomSheetBehavior"},{"location":"modules/views-dsl-material/#bottom-sheet-state-extensions","text":"This split also includes extensions on BottomSheetBehavior : * hidden and expanded : read-write extension properties. * hide() and expand() : extension functions. They make playing with your bottom sheets programmatically a breeze. See their KDoc to see their exact behavior.","title":"Bottom sheet state extensions"},{"location":"modules/views-dsl-material/#textinputlayout-helper","text":"The addInput extension function on TextInputLayout takes a required id used for the TextInputEditText that it creates and adds to the layout. The id is required so the content of the user input is saved in instance state even if the host Activity is killed by the system.","title":"TextInputLayout helper"},{"location":"modules/views-dsl-recyclerview/","text":"Views DSL RecyclerView \u00b6 RecyclerView extension of Views DSL Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsDslRecyclerview , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-dsl-recyclerview . Table of contents \u00b6 RecyclerView with scrollbars Make any view scrollable RecyclerView item layout parameters RecyclerView with scrollbars \u00b6 To get scrollbars on a View in Android, you need to enable it in the android:scrollbars xml attribute first. Only then you can disable and re-enable them back using the isHorizontalScrollBarEnabled and isVerticalScrollBarEnabled properties. To overcome this problem, this split provides a recyclerView function . This function inflates a RecyclerView with both horizontal and vertical scrollbars enabled in xml, but the scrollbars will only ever appear if your content can scroll in that direction, so you likely just have to use it. Make any view scrollable \u00b6 Let's say you have a LinearLayout , or a TextView that is just a bit too long to fit into all screen sizes. In xml, you'd likely use NestedScrollView , or good old ScrollView . Unfortunately, NestedScrollView has bugs that may cut off the content in some hard to reproduce consistently cases, and ScrollView doesn't support nested scroll as you may need in your app. On the other hand, there's RecyclerView , which has none of these issues. This split provides a wrapInRecyclerView extension function for View that returns a RecyclerView wrapping the View is has been called on. It is vertical by default, but you can set the horizontal parameter to true Also, you can (should) specify the id so scrolling position is saved into instance state and restored when needed. And you have an optional lambda to configure the RecyclerView , which can be useful for things like setting the padding and disabling clipping, setting the background, etc. Here's two small examples: val content = textView { textResource = R . string . a_very_long_string }. wrapInRecyclerView ( id = R . id . main_content ) { verticalPadding = dip ( 8 ) horizontalPadding = dip ( 16 ) clipToPadding = false } val content = textView { textResource = R . string . good_luck_scrolling_these_10_thousand_characters textSize = 48f // This size is interpreted in sp unit BTW }. wrapInRecyclerView ( horizontal = true ) RecyclerView item layout parameters \u00b6 RecyclerView.onCreateViewHolder method passes the parent ViewGroup so layout parameters are properly generated when the item view is inflated from xml. When using Views DSL in a RecyclerView , you are not inflating xml, so this parent parameter is of no use. However, you can set the item view layout parameters manually. This split provides two extension functions on RecyclerView.LayoutManager to make it easy: verticalListLayoutParams and horizontalListLayoutParams .","title":"Views DSL RecyclerView"},{"location":"modules/views-dsl-recyclerview/#views-dsl-recyclerview","text":"RecyclerView extension of Views DSL Supported platforms: Android .","title":"Views DSL RecyclerView"},{"location":"modules/views-dsl-recyclerview/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsDslRecyclerview , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-dsl-recyclerview .","title":"Setup"},{"location":"modules/views-dsl-recyclerview/#table-of-contents","text":"RecyclerView with scrollbars Make any view scrollable RecyclerView item layout parameters","title":"Table of contents"},{"location":"modules/views-dsl-recyclerview/#recyclerview-with-scrollbars","text":"To get scrollbars on a View in Android, you need to enable it in the android:scrollbars xml attribute first. Only then you can disable and re-enable them back using the isHorizontalScrollBarEnabled and isVerticalScrollBarEnabled properties. To overcome this problem, this split provides a recyclerView function . This function inflates a RecyclerView with both horizontal and vertical scrollbars enabled in xml, but the scrollbars will only ever appear if your content can scroll in that direction, so you likely just have to use it.","title":"RecyclerView with scrollbars"},{"location":"modules/views-dsl-recyclerview/#make-any-view-scrollable","text":"Let's say you have a LinearLayout , or a TextView that is just a bit too long to fit into all screen sizes. In xml, you'd likely use NestedScrollView , or good old ScrollView . Unfortunately, NestedScrollView has bugs that may cut off the content in some hard to reproduce consistently cases, and ScrollView doesn't support nested scroll as you may need in your app. On the other hand, there's RecyclerView , which has none of these issues. This split provides a wrapInRecyclerView extension function for View that returns a RecyclerView wrapping the View is has been called on. It is vertical by default, but you can set the horizontal parameter to true Also, you can (should) specify the id so scrolling position is saved into instance state and restored when needed. And you have an optional lambda to configure the RecyclerView , which can be useful for things like setting the padding and disabling clipping, setting the background, etc. Here's two small examples: val content = textView { textResource = R . string . a_very_long_string }. wrapInRecyclerView ( id = R . id . main_content ) { verticalPadding = dip ( 8 ) horizontalPadding = dip ( 16 ) clipToPadding = false } val content = textView { textResource = R . string . good_luck_scrolling_these_10_thousand_characters textSize = 48f // This size is interpreted in sp unit BTW }. wrapInRecyclerView ( horizontal = true )","title":"Make any view scrollable"},{"location":"modules/views-dsl-recyclerview/#recyclerview-item-layout-parameters","text":"RecyclerView.onCreateViewHolder method passes the parent ViewGroup so layout parameters are properly generated when the item view is inflated from xml. When using Views DSL in a RecyclerView , you are not inflating xml, so this parent parameter is of no use. However, you can set the item view layout parameters manually. This split provides two extension functions on RecyclerView.LayoutManager to make it easy: verticalListLayoutParams and horizontalListLayoutParams .","title":"RecyclerView item layout parameters"},{"location":"modules/views-material/","text":"Views Material \u00b6 Material Components extension of Views . Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsMaterial , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-material . Content \u00b6 CollapsingToolbarLayout extensions \u00b6 contentScrimColor allows to set the content scrim color of a CollapsingToolbarLayout using property syntax. TextInputLayout extensions \u00b6 The text read/write extension property for TextInputLayout is an alias to the text property of the child EditText . The string read only extension property for TextInputLayout allows to easily get the String (immutable) representation of the text of the child EditText .","title":"Views Material"},{"location":"modules/views-material/#views-material","text":"Material Components extension of Views . Supported platforms: Android .","title":"Views Material"},{"location":"modules/views-material/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsMaterial , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-material .","title":"Setup"},{"location":"modules/views-material/#content","text":"","title":"Content"},{"location":"modules/views-material/#collapsingtoolbarlayout-extensions","text":"contentScrimColor allows to set the content scrim color of a CollapsingToolbarLayout using property syntax.","title":"CollapsingToolbarLayout extensions"},{"location":"modules/views-material/#textinputlayout-extensions","text":"The text read/write extension property for TextInputLayout is an alias to the text property of the child EditText . The string read only extension property for TextInputLayout allows to easily get the String (immutable) representation of the text of the child EditText .","title":"TextInputLayout extensions"},{"location":"modules/views-recyclerview/","text":"Views RecyclerView \u00b6 Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsRecyclerview , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-recyclerview . Content \u00b6 RecyclerView extensions \u00b6 The fixedSize extension property for RecyclerView is an alias to the hasFixedSize() and setHasFixedSize(\u2026) methods. functions to create a LinearLayoutManager \u00b6 The verticalLayoutManager and horizontalLayoutManager functions allow you to instantiate and customize a LinearLayoutManager with more idiomatic Kotlin code. functions to create a GridLayoutManager \u00b6 The gridLayoutManager and horizontalGridLayoutManager functions allow you to instantiate and customize a GridLayoutManager with more idiomatic Kotlin code.","title":"Views RecyclerView"},{"location":"modules/views-recyclerview/#views-recyclerview","text":"Supported platforms: Android .","title":"Views RecyclerView"},{"location":"modules/views-recyclerview/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsRecyclerview , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-recyclerview .","title":"Setup"},{"location":"modules/views-recyclerview/#content","text":"","title":"Content"},{"location":"modules/views-recyclerview/#recyclerview-extensions","text":"The fixedSize extension property for RecyclerView is an alias to the hasFixedSize() and setHasFixedSize(\u2026) methods.","title":"RecyclerView extensions"},{"location":"modules/views-recyclerview/#functions-to-create-a-linearlayoutmanager","text":"The verticalLayoutManager and horizontalLayoutManager functions allow you to instantiate and customize a LinearLayoutManager with more idiomatic Kotlin code.","title":"functions to create a LinearLayoutManager"},{"location":"modules/views-recyclerview/#functions-to-create-a-gridlayoutmanager","text":"The gridLayoutManager and horizontalGridLayoutManager functions allow you to instantiate and customize a GridLayoutManager with more idiomatic Kotlin code.","title":"functions to create a GridLayoutManager"},{"location":"modules/views-selectable/","text":"Selectable Views \u00b6 Selectable Views with foreground property before API 23. Supported platforms: Android . This split provides selectable LinearLayout and platform TextView . See also the AppCompat and ConstraintLayout versions. Selectable views are particularly handy for list items that can be clicked. They have a foregroundSelector property that is like foregound property available on FrameLayout and all Views on API 23+. It defaults to android.R.attr.selectableItemBackground , showing visual feedback when the user selects the View (ripple effect on Lollipop and newer Android versions). Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsSelectable , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-selectable . Usage \u00b6 Just use SelectableLinearLayout and SelectableTextView instead of LinearLayout and TextView , and change the foregroundSelector Drawable if the default doesn't suit your needs.","title":"Selectable Views"},{"location":"modules/views-selectable/#selectable-views","text":"Selectable Views with foreground property before API 23. Supported platforms: Android . This split provides selectable LinearLayout and platform TextView . See also the AppCompat and ConstraintLayout versions. Selectable views are particularly handy for list items that can be clicked. They have a foregroundSelector property that is like foregound property available on FrameLayout and all Views on API 23+. It defaults to android.R.attr.selectableItemBackground , showing visual feedback when the user selects the View (ripple effect on Lollipop and newer Android versions).","title":"Selectable Views"},{"location":"modules/views-selectable/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsSelectable , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-selectable .","title":"Setup"},{"location":"modules/views-selectable/#usage","text":"Just use SelectableLinearLayout and SelectableTextView instead of LinearLayout and TextView , and change the foregroundSelector Drawable if the default doesn't suit your needs.","title":"Usage"},{"location":"modules/views-selectable-appcompat/","text":"Selectable Views AppCompat \u00b6 Selectable Views for AppCompatTextView. Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsSelectableAppcompat , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-selectable-appcompat . Usage \u00b6 Just use SelectableTextView with the proper import instead of TextView or AppCompatTextView , and change the foregroundSelector Drawable if the default doesn't suit your needs.","title":"Selectable Views AppCompat"},{"location":"modules/views-selectable-appcompat/#selectable-views-appcompat","text":"Selectable Views for AppCompatTextView. Supported platforms: Android .","title":"Selectable Views AppCompat"},{"location":"modules/views-selectable-appcompat/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsSelectableAppcompat , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-selectable-appcompat .","title":"Setup"},{"location":"modules/views-selectable-appcompat/#usage","text":"Just use SelectableTextView with the proper import instead of TextView or AppCompatTextView , and change the foregroundSelector Drawable if the default doesn't suit your needs.","title":"Usage"},{"location":"modules/views-selectable-constraintlayout/","text":"Selectable Views ConstraintLayout \u00b6 Selectable Views for ConstraintLayout. Supported platforms: Android . Setup \u00b6 If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsSelectableConstraintlayout , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-selectable-constraintlayout . Usage \u00b6 Just use SelectableConstraintLayout with the proper import instead of ConstraintLayout , and change the foregroundSelector Drawable if the default doesn't suit your needs.","title":"Selectable Views ConstraintLayout"},{"location":"modules/views-selectable-constraintlayout/#selectable-views-constraintlayout","text":"Selectable Views for ConstraintLayout. Supported platforms: Android .","title":"Selectable Views ConstraintLayout"},{"location":"modules/views-selectable-constraintlayout/#setup","text":"If you want to use this dependency without using one of the fun packs , you can use Splitties.viewsSelectableConstraintlayout , provided you have refreshVersions added to the project. For reference, the maven coordinates of this module are com.louiscad.splitties:splitties-views-selectable-constraintlayout .","title":"Setup"},{"location":"modules/views-selectable-constraintlayout/#usage","text":"Just use SelectableConstraintLayout with the proper import instead of ConstraintLayout , and change the foregroundSelector Drawable if the default doesn't suit your needs.","title":"Usage"}]}